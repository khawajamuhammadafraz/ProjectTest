/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 72);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(73);
} else {
  module.exports = __webpack_require__(74);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function warning() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(87)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(88)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(52);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = __webpack_require__(10);

var ReactCurrentOwner = __webpack_require__(18);

var warning = __webpack_require__(5);
var canDefineProperty = __webpack_require__(19);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(53);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function warnAboutAccessingKey() {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function warnAboutAccessingRef() {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(6);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.createLocation = undefined;

var _resolvePathname = __webpack_require__(44);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(45);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function get() {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(12);
  var warning = __webpack_require__(16);
  var ReactPropTypesSecret = __webpack_require__(21);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _resolvePathname = __webpack_require__(44);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(45);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(13);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Router = __webpack_require__(25);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Router2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;

    (0, _invariant2.default)(children == null || _react2.default.Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? _react2.default.Children.only(children) : null;
  };

  return Router;
}(_react2.default.Component);

Router.propTypes = {
  history: _propTypes2.default.object.isRequired,
  children: _propTypes2.default.node
};
Router.contextTypes = {
  router: _propTypes2.default.object
};
Router.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Router;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pathToRegexp = __webpack_require__(96);

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = (0, _pathToRegexp2.default)(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

exports.default = matchPath;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

var _Provider = __webpack_require__(114);

var _Provider2 = _interopRequireDefault(_Provider);

var _connectAdvanced = __webpack_require__(64);

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _connect = __webpack_require__(137);

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Provider = _Provider2.default;
exports.createProvider = _Provider.createProvider;
exports.connectAdvanced = _connectAdvanced2.default;
exports.connect = _connect2.default;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(7);

var ReactNoopUpdateQueue = __webpack_require__(30);

var canDefineProperty = __webpack_require__(19);
var emptyObject = __webpack_require__(31);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(5);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function get() {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(5);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function enqueueCallback(publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(18);

var invariant = __webpack_require__(8);
var warning = __webpack_require__(5);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function setItem(id, item) {
    itemMap.set(id, item);
  };
  getItem = function getItem(id) {
    return itemMap.get(id);
  };
  removeItem = function removeItem(id) {
    itemMap['delete'](id);
  };
  getItemIDs = function getItemIDs() {
    return Array.from(itemMap.keys());
  };

  addRoot = function addRoot(id) {
    rootIDSet.add(id);
  };
  removeRoot = function removeRoot(id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function getRootIDs() {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function getKeyFromID(id) {
    return '.' + id;
  };
  var getIDFromKey = function getIDFromKey(key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function setItem(id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function getItem(id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function removeItem(id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function getItemIDs() {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function addRoot(id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function removeRoot(id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function getRootIDs() {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function _getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function onSetChildren(id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function onMountComponent(id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function onUpdateComponent(id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function onUnmountComponent(id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function purgeUnmountedComponents() {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function isMounted(id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
    var info = '';
    if (topElement) {
      var name = _getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function getStackAddendumByID(id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function getChildIDs(id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function getDisplayName(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return _getDisplayName(element);
  },
  getElement: function getElement(id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function getOwnerID(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function getParentID(id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function getSource(id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function getText(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function getUpdateCount(id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },

  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _baseGetTag = __webpack_require__(141);

var _baseGetTag2 = _interopRequireDefault(_baseGetTag);

var _getPrototype = __webpack_require__(146);

var _getPrototype2 = _interopRequireDefault(_getPrototype);

var _isObjectLike = __webpack_require__(148);

var _isObjectLike2 = _interopRequireDefault(_isObjectLike);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!(0, _isObjectLike2.default)(value) || (0, _baseGetTag2.default)(value) != objectTag) {
    return false;
  }
  var proto = (0, _getPrototype2.default)(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

exports.default = isPlainObject;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(6);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(77);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

exports.default = resolvePathname;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

exports.default = valueEqual;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;

          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    (0, _invariant2.default)(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(_react2.default.Component);

Link.propTypes = {
  onClick: _propTypes2.default.func,
  target: _propTypes2.default.string,
  replace: _propTypes2.default.bool,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,
  innerRef: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired,
      createHref: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Link;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Route = __webpack_require__(49);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Route2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _matchPath = __webpack_require__(26);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isEmptyChildren = function isEmptyChildren(children) {
  return _react2.default.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    (0, _invariant2.default)(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? (0, _matchPath2.default)(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    (0, _warning2.default)(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    (0, _warning2.default)(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? _react2.default.createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? _react2.default.Children.only(children) : null : null;
  };

  return Route;
}(_react2.default.Component);

Route.propTypes = {
  computedMatch: _propTypes2.default.object, // private, from <Switch>
  path: _propTypes2.default.string,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  sensitive: _propTypes2.default.bool,
  component: _propTypes2.default.func,
  render: _propTypes2.default.func,
  children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  location: _propTypes2.default.object
};
Route.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.object.isRequired,
    route: _propTypes2.default.object.isRequired,
    staticContext: _propTypes2.default.object
  })
};
Route.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Route;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(115);

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ReactCurrentOwner = __webpack_require__(18);
var ReactComponentTreeHook = __webpack_require__(32);
var ReactElement = __webpack_require__(9);

var checkReactTypeSpec = __webpack_require__(123);

var canDefineProperty = __webpack_require__(19);
var getIteratorFn = __webpack_require__(54);
var warning = __webpack_require__(5);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function createElement(type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function createFactory(type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function cloneElement(element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(57);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(131)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(133)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(33);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storeShape = exports.subscriptionShape = undefined;

var _propTypes = __webpack_require__(61);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
  trySubscribe: _propTypes2.default.func.isRequired,
  tryUnsubscribe: _propTypes2.default.func.isRequired,
  notifyNestedSubs: _propTypes2.default.func.isRequired,
  isSubscribed: _propTypes2.default.func.isRequired
});

var storeShape = exports.storeShape = _propTypes2.default.shape({
  subscribe: _propTypes2.default.func.isRequired,
  dispatch: _propTypes2.default.func.isRequired,
  getState: _propTypes2.default.func.isRequired
});

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = connectAdvanced;

var _hoistNonReactStatics = __webpack_require__(134);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = __webpack_require__(135);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(51);

var _Subscription = __webpack_require__(136);

var _Subscription2 = _interopRequireDefault(_Subscription);

var _PropTypes = __webpack_require__(63);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(_react.Component);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActionTypes = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = createStore;

var _isPlainObject = __webpack_require__(37);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = __webpack_require__(149);

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2.default)(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2.default] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2.default] = observable, _ref2;
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _root = __webpack_require__(142);

var _root2 = _interopRequireDefault(_root);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var _Symbol = _root2.default.Symbol;

exports.default = _Symbol;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  var last = funcs[funcs.length - 1];
  var rest = funcs.slice(0, -1);
  return function () {
    return rest.reduceRight(function (composed, f) {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
exports.getDependsOnOwnProps = getDependsOnOwnProps;
exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

var _verifyPlainObject = __webpack_require__(71);

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = verifyPlainObject;

var _isPlainObject = __webpack_require__(37);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = __webpack_require__(36);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verifyPlainObject(value, displayName, methodName) {
  if (!(0, _isPlainObject2.default)(value)) {
    (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(75);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _App = __webpack_require__(84);

var _App2 = _interopRequireDefault(_App);

var _application = __webpack_require__(162);

var _application2 = _interopRequireDefault(_application);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var aaa = 123;

_reactDom2.default.render(_react2.default.createElement(_App2.default, { n: aaa }), document.getElementById('root'));

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(11),
    n = __webpack_require__(15),
    p = __webpack_require__(6),
    q = "function" === typeof Symbol && Symbol["for"],
    r = q ? Symbol["for"]("react.element") : 60103,
    t = q ? Symbol["for"]("react.call") : 60104,
    u = q ? Symbol["for"]("react.return") : 60105,
    v = q ? Symbol["for"]("react.portal") : 60106,
    w = q ? Symbol["for"]("react.fragment") : 60107,
    x = "function" === typeof Symbol && Symbol.iterator;
function y(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);
  }b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var z = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function A(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}A.prototype.isReactComponent = {};A.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? y("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};A.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function B(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}function C() {}C.prototype = A.prototype;var D = B.prototype = new C();D.constructor = B;m(D, A.prototype);D.isPureReactComponent = !0;function E(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || z;
}var F = E.prototype = new C();F.constructor = E;m(F, A.prototype);F.unstable_isAsyncReactComponent = !0;F.render = function () {
  return this.props.children;
};var G = { current: null },
    H = Object.prototype.hasOwnProperty,
    I = { key: !0, ref: !0, __self: !0, __source: !0 };
function J(a, b, e) {
  var c,
      d = {},
      g = null,
      k = null;if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
    H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
  }var f = arguments.length - 2;if (1 === f) d.children = e;else if (1 < f) {
    for (var h = Array(f), l = 0; l < f; l++) {
      h[l] = arguments[l + 2];
    }d.children = h;
  }if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
    void 0 === d[c] && (d[c] = f[c]);
  }return { $$typeof: r, type: a, key: g, ref: k, props: d, _owner: G.current };
}function K(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === r;
}
function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var L = /\/+/g,
    M = [];function N(a, b, e, c) {
  if (M.length) {
    var d = M.pop();d.result = a;d.keyPrefix = b;d.func = e;d.context = c;d.count = 0;return d;
  }return { result: a, keyPrefix: b, func: e, context: c, count: 0 };
}function O(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > M.length && M.push(a);
}
function P(a, b, e, c) {
  var d = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === d || "boolean" === d) a = null;var g = !1;if (null === a) g = !0;else switch (d) {case "string":case "number":
      g = !0;break;case "object":
      switch (a.$$typeof) {case r:case t:case u:case v:
          g = !0;}}if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;g = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    d = a[k];var f = b + Q(d, k);g += P(d, f, e, c);
  } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) {
    d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);
  } else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));return g;
}function Q(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function R(a, b) {
  a.func.call(a.context, b, a.count++);
}
function S(a, b, e) {
  var c = a.result,
      d = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = { $$typeof: r, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), c.push(a));
}function T(a, b, e, c, d) {
  var g = "";null != e && (g = ("" + e).replace(L, "$\x26/") + "/");b = N(b, g, c, d);null == a || P(a, "", S, b);O(b);
}
var U = { Children: { map: function map(a, b, e) {
      if (null == a) return a;var c = [];T(a, c, null, b, e);return c;
    }, forEach: function forEach(a, b, e) {
      if (null == a) return a;b = N(null, null, b, e);null == a || P(a, "", R, b);O(b);
    }, count: function count(a) {
      return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
    }, toArray: function toArray(a) {
      var b = [];T(a, b, null, p.thatReturnsArgument);return b;
    }, only: function only(a) {
      K(a) ? void 0 : y("143");return a;
    } }, Component: A, PureComponent: B, unstable_AsyncComponent: E, Fragment: w, createElement: J, cloneElement: function cloneElement(a, b, e) {
    var c = m({}, a.props),
        d = a.key,
        g = a.ref,
        k = a._owner;if (null != b) {
      void 0 !== b.ref && (g = b.ref, k = G.current);void 0 !== b.key && (d = "" + b.key);if (a.type && a.type.defaultProps) var f = a.type.defaultProps;for (h in b) {
        H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
      }
    }var h = arguments.length - 2;if (1 === h) c.children = e;else if (1 < h) {
      f = Array(h);for (var l = 0; l < h; l++) {
        f[l] = arguments[l + 2];
      }c.children = f;
    }return { $$typeof: r, type: a.type, key: d, ref: g, props: c, _owner: k };
  }, createFactory: function createFactory(a) {
    var b = J.bind(null, a);b.type = a;return b;
  },
  isValidElement: K, version: "16.2.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: G, assign: m } },
    V = Object.freeze({ default: U }),
    W = V && U || V;module.exports = W["default"] ? W["default"] : W;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(11);
    var emptyObject = __webpack_require__(15);
    var invariant = __webpack_require__(12);
    var warning = __webpack_require__(16);
    var emptyFunction = __webpack_require__(6);
    var checkPropTypes = __webpack_require__(20);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.2.0';

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var propTypesMisspellWarningShown = false;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;
      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      Fragment: REACT_FRAGMENT_TYPE,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(76);
} else {
  module.exports = __webpack_require__(79);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(1),
    l = __webpack_require__(38),
    B = __webpack_require__(11),
    C = __webpack_require__(6),
    ba = __webpack_require__(39),
    da = __webpack_require__(40),
    ea = __webpack_require__(41),
    fa = __webpack_require__(42),
    ia = __webpack_require__(43),
    D = __webpack_require__(15);
function E(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : E("227");
var oa = { children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0 };function pa(a, b) {
  return (a & b) === b;
}
var ta = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = ta,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      ua.hasOwnProperty(f) ? E("48", f) : void 0;var g = f.toLowerCase(),
          h = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: pa(h, b.MUST_USE_PROPERTY),
        hasBooleanValue: pa(h, b.HAS_BOOLEAN_VALUE), hasNumericValue: pa(h, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: pa(h, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: pa(h, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: pa(h, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : E("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);ua[f] = g;
    }
  } },
    ua = {};
function va(a, b) {
  if (oa.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
      return oa.hasOwnProperty(a) ? a = !0 : (b = wa(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;case "undefined":case "number":case "string":case "object":
      return !0;default:
      return !1;}
}function wa(a) {
  return ua.hasOwnProperty(a) ? ua[a] : null;
}
var xa = ta,
    ya = xa.MUST_USE_PROPERTY,
    K = xa.HAS_BOOLEAN_VALUE,
    za = xa.HAS_NUMERIC_VALUE,
    Aa = xa.HAS_POSITIVE_NUMERIC_VALUE,
    Ba = xa.HAS_OVERLOADED_BOOLEAN_VALUE,
    Ca = xa.HAS_STRING_BOOLEAN_VALUE,
    Da = { Properties: { allowFullScreen: K, async: K, autoFocus: K, autoPlay: K, capture: Ba, checked: ya | K, cols: Aa, contentEditable: Ca, controls: K, "default": K, defer: K, disabled: K, download: Ba, draggable: Ca, formNoValidate: K, hidden: K, loop: K, multiple: ya | K, muted: ya | K, noValidate: K, open: K, playsInline: K, readOnly: K, required: K, reversed: K, rows: Aa, rowSpan: za,
    scoped: K, seamless: K, selected: ya | K, size: Aa, start: za, span: Aa, spellCheck: Ca, style: 0, tabIndex: 0, itemScope: K, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: Ca }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    Ea = xa.HAS_STRING_BOOLEAN_VALUE,
    M = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    Ga = { Properties: { autoReverse: Ea, externalResourcesRequired: Ea, preserveAlpha: Ea }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: M.xlink, xlinkArcrole: M.xlink, xlinkHref: M.xlink, xlinkRole: M.xlink, xlinkShow: M.xlink, xlinkTitle: M.xlink, xlinkType: M.xlink,
    xmlBase: M.xml, xmlLang: M.xml, xmlSpace: M.xml } },
    Ha = /[\-\:]([a-z])/g;function Ia(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Ha, Ia);Ga.Properties[b] = 0;Ga.DOMAttributeNames[b] = a;
});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? E("197") : void 0;Ja = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, h, k) {
    Ja.apply(P, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, h, k) {
    P.invokeGuardedCallback.apply(this, arguments);if (P.hasCaughtError()) {
      var q = P.clearCaughtError();P._hasRethrowError || (P._hasRethrowError = !0, P._rethrowError = q);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return Ka.apply(P, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return P._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (P._hasCaughtError) {
      var a = P._caughtError;P._caughtError = null;P._hasCaughtError = !1;return a;
    }E("198");
  } };function Ja(a, b, c, d, e, f, g, h, k) {
  P._hasCaughtError = !1;P._caughtError = null;var q = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, q);
  } catch (v) {
    P._caughtError = v, P._hasCaughtError = !0;
  }
}
function Ka() {
  if (P._hasRethrowError) {
    var a = P._rethrowError;P._rethrowError = null;P._hasRethrowError = !1;throw a;
  }
}var La = null,
    Ma = {};
function Na() {
  if (La) for (var a in Ma) {
    var b = Ma[a],
        c = La.indexOf(a);-1 < c ? void 0 : E("96", a);if (!Oa[c]) {
      b.extractEvents ? void 0 : E("97", a);Oa[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            h = d;Pa.hasOwnProperty(h) ? E("99", h) : void 0;Pa[h] = f;var k = f.phasedRegistrationNames;if (k) {
          for (e in k) {
            k.hasOwnProperty(e) && Qa(k[e], g, h);
          }e = !0;
        } else f.registrationName ? (Qa(f.registrationName, g, h), e = !0) : e = !1;e ? void 0 : E("98", d, a);
      }
    }
  }
}
function Qa(a, b, c) {
  Ra[a] ? E("100", a) : void 0;Ra[a] = b;Sa[a] = b.eventTypes[c].dependencies;
}var Oa = [],
    Pa = {},
    Ra = {},
    Sa = {};function Ta(a) {
  La ? E("101") : void 0;La = Array.prototype.slice.call(a);Na();
}function Ua(a) {
  var b = !1,
      c;for (c in a) {
    if (a.hasOwnProperty(c)) {
      var d = a[c];Ma.hasOwnProperty(c) && Ma[c] === d || (Ma[c] ? E("102", c) : void 0, Ma[c] = d, b = !0);
    }
  }b && Na();
}
var Va = Object.freeze({ plugins: Oa, eventNameDispatchConfigs: Pa, registrationNameModules: Ra, registrationNameDependencies: Sa, possibleRegistrationNames: null, injectEventPluginOrder: Ta, injectEventPluginsByName: Ua }),
    Wa = null,
    Xa = null,
    Ya = null;function Za(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
function $a(a, b) {
  null == b ? E("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}function ab(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var bb = null;
function cb(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      Za(a, b, c[e], d[e]);
    } else c && Za(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function db(a) {
  return cb(a, !0);
}function gb(a) {
  return cb(a, !1);
}var hb = { injectEventPluginOrder: Ta, injectEventPluginsByName: Ua };
function ib(a, b) {
  var c = a.stateNode;if (!c) return null;var d = Wa(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? E("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function jb(a, b, c, d) {
  for (var e, f = 0; f < Oa.length; f++) {
    var g = Oa[f];g && (g = g.extractEvents(a, b, c, d)) && (e = $a(e, g));
  }return e;
}function kb(a) {
  a && (bb = $a(bb, a));
}function lb(a) {
  var b = bb;bb = null;b && (a ? ab(b, db) : ab(b, gb), bb ? E("95") : void 0, P.rethrowCaughtError());
}var mb = Object.freeze({ injection: hb, getListener: ib, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb }),
    nb = Math.random().toString(36).slice(2),
    Q = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;
function pb(a) {
  if (a[Q]) return a[Q];for (var b = []; !a[Q];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = void 0,
      d = a[Q];if (5 === d.tag || 6 === d.tag) return d;for (; a && (d = a[Q]); a = b.pop()) {
    c = d;
  }return c;
}function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;E("33");
}function rb(a) {
  return a[ob] || null;
}
var sb = Object.freeze({ precacheFiberNode: function precacheFiberNode(a, b) {
    b[Q] = a;
  }, getClosestInstanceFromNode: pb, getInstanceFromNode: function getInstanceFromNode(a) {
    a = a[Q];return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps: function updateFiberProps(a, b) {
    a[ob] = b;
  } });function tb(a) {
  do {
    a = a["return"];
  } while (a && 5 !== a.tag);return a ? a : null;
}function ub(a, b, c) {
  for (var d = []; a;) {
    d.push(a), a = tb(a);
  }for (a = d.length; 0 < a--;) {
    b(d[a], "captured", c);
  }for (a = 0; a < d.length; a++) {
    b(d[a], "bubbled", c);
  }
}
function vb(a, b, c) {
  if (b = ib(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a);
}function wb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && ub(a._targetInst, vb, a);
}function xb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? tb(b) : null;ub(b, vb, a);
  }
}
function yb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = ib(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a));
}function zb(a) {
  a && a.dispatchConfig.registrationName && yb(a._targetInst, null, a);
}function Ab(a) {
  ab(a, wb);
}
function Bb(a, b, c, d) {
  if (c && d) a: {
    var e = c;for (var f = d, g = 0, h = e; h; h = tb(h)) {
      g++;
    }h = 0;for (var k = f; k; k = tb(k)) {
      h++;
    }for (; 0 < g - h;) {
      e = tb(e), g--;
    }for (; 0 < h - g;) {
      f = tb(f), h--;
    }for (; g--;) {
      if (e === f || e === f.alternate) break a;e = tb(e);f = tb(f);
    }e = null;
  } else e = null;f = e;for (e = []; c && c !== f;) {
    g = c.alternate;if (null !== g && g === f) break;e.push(c);c = tb(c);
  }for (c = []; d && d !== f;) {
    g = d.alternate;if (null !== g && g === f) break;c.push(d);d = tb(d);
  }for (d = 0; d < e.length; d++) {
    yb(e[d], "bubbled", a);
  }for (a = c.length; 0 < a--;) {
    yb(c[a], "captured", b);
  }
}
var Cb = Object.freeze({ accumulateTwoPhaseDispatches: Ab, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    ab(a, xb);
  }, accumulateEnterLeaveDispatches: Bb, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    ab(a, zb);
  } }),
    Db = null;function Eb() {
  !Db && l.canUseDOM && (Db = "textContent" in document.documentElement ? "textContent" : "innerText");return Db;
}var S = { _root: null, _startText: null, _fallbackText: null };
function Fb() {
  if (S._fallbackText) return S._fallbackText;var a,
      b = S._startText,
      c = b.length,
      d,
      e = Gb(),
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}S._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return S._fallbackText;
}function Gb() {
  return "value" in S._root ? S._root.value : S._root[Eb()];
}
var Hb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Ib = { type: null, target: null, currentTarget: C.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function T(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;this.isPropagationStopped = C.thatReturnsFalse;return this;
}
B(T.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = C.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = C.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = C.thatReturnsTrue;
  }, isPersistent: C.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Hb.length; a++) {
      this[Hb[a]] = null;
    }
  } });T.Interface = Ib;T.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();B(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = B({}, this.Interface, b);a.augmentClass = this.augmentClass;Jb(a);
};Jb(T);function Kb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function Lb(a) {
  a instanceof this ? void 0 : E("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Jb(a) {
  a.eventPool = [];a.getPooled = Kb;a.release = Lb;
}function Mb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Mb, { data: null });function Nb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Nb, { data: null });var Pb = [9, 13, 27, 32],
    Vb = l.canUseDOM && "CompositionEvent" in window,
    Wb = null;l.canUseDOM && "documentMode" in document && (Wb = document.documentMode);var Xb;
if (Xb = l.canUseDOM && "TextEvent" in window && !Wb) {
  var Yb = window.opera;Xb = !("object" === (typeof Yb === "undefined" ? "undefined" : _typeof(Yb)) && "function" === typeof Yb.version && 12 >= parseInt(Yb.version(), 10));
}
var Zb = Xb,
    $b = l.canUseDOM && (!Vb || Wb && 8 < Wb && 11 >= Wb),
    ac = String.fromCharCode(32),
    bc = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    cc = !1;
function dc(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== Pb.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function ec(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var fc = !1;function gc(a, b) {
  switch (a) {case "topCompositionEnd":
      return ec(b);case "topKeyPress":
      if (32 !== b.which) return null;cc = !0;return ac;case "topTextInput":
      return a = b.data, a === ac && cc ? null : a;default:
      return null;}
}
function hc(a, b) {
  if (fc) return "topCompositionEnd" === a || !Vb && dc(a, b) ? (a = Fb(), S._root = null, S._startText = null, S._fallbackText = null, fc = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return $b ? null : b.data;default:
      return null;}
}
var ic = { eventTypes: bc, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (Vb) b: {
      switch (a) {case "topCompositionStart":
          var f = bc.compositionStart;break b;case "topCompositionEnd":
          f = bc.compositionEnd;break b;case "topCompositionUpdate":
          f = bc.compositionUpdate;break b;}f = void 0;
    } else fc ? dc(a, c) && (f = bc.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = bc.compositionStart);f ? ($b && (fc || f !== bc.compositionStart ? f === bc.compositionEnd && fc && (e = Fb()) : (S._root = d, S._startText = Gb(), fc = !0)), f = Mb.getPooled(f, b, c, d), e ? f.data = e : (e = ec(c), null !== e && (f.data = e)), Ab(f), e = f) : e = null;(a = Zb ? gc(a, c) : hc(a, c)) ? (b = Nb.getPooled(bc.beforeInput, b, c, d), b.data = a, Ab(b)) : b = null;return [e, b];
  } },
    jc = null,
    kc = null,
    lc = null;function mc(a) {
  if (a = Xa(a)) {
    jc && "function" === typeof jc.restoreControlledState ? void 0 : E("194");var b = Wa(a.stateNode);jc.restoreControlledState(a.stateNode, a.type, b);
  }
}var nc = { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
    jc = a;
  } };function oc(a) {
  kc ? lc ? lc.push(a) : lc = [a] : kc = a;
}
function pc() {
  if (kc) {
    var a = kc,
        b = lc;lc = kc = null;mc(a);if (b) for (a = 0; a < b.length; a++) {
      mc(b[a]);
    }
  }
}var qc = Object.freeze({ injection: nc, enqueueStateRestore: oc, restoreStateIfNeeded: pc });function rc(a, b) {
  return a(b);
}var sc = !1;function tc(a, b) {
  if (sc) return rc(a, b);sc = !0;try {
    return rc(a, b);
  } finally {
    sc = !1, pc();
  }
}var uc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function vc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!uc[a.type] : "textarea" === b ? !0 : !1;
}function wc(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var xc;l.canUseDOM && (xc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function yc(a, b) {
  if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && xc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function zc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ac(a) {
  var b = zc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
function Bc(a) {
  a._valueTracker || (a._valueTracker = Ac(a));
}function Cc(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}var Dc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };
function Ec(a, b, c) {
  a = T.getPooled(Dc.change, a, b, c);a.type = "change";oc(c);Ab(a);return a;
}var Fc = null,
    Gc = null;function Hc(a) {
  kb(a);lb(!1);
}function Ic(a) {
  var b = qb(a);if (Cc(b)) return a;
}function Jc(a, b) {
  if ("topChange" === a) return b;
}var Kc = !1;l.canUseDOM && (Kc = yc("input") && (!document.documentMode || 9 < document.documentMode));function Lc() {
  Fc && (Fc.detachEvent("onpropertychange", Mc), Gc = Fc = null);
}function Mc(a) {
  "value" === a.propertyName && Ic(Gc) && (a = Ec(Gc, a, wc(a)), tc(Hc, a));
}
function Nc(a, b, c) {
  "topFocus" === a ? (Lc(), Fc = b, Gc = c, Fc.attachEvent("onpropertychange", Mc)) : "topBlur" === a && Lc();
}function Oc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Ic(Gc);
}function Pc(a, b) {
  if ("topClick" === a) return Ic(b);
}function $c(a, b) {
  if ("topInput" === a || "topChange" === a) return Ic(b);
}
var ad = { eventTypes: Dc, _isInputEventSupported: Kc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Jc;else if (vc(e)) {
      if (Kc) g = $c;else {
        g = Oc;var h = Nc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Pc);if (g && (g = g(a, b))) return Ec(g, c, d);h && h(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function bd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(bd, { view: null, detail: null });var cd = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function dd(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = cd[a]) ? !!b[a] : !1;
}function ed() {
  return dd;
}function fd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(fd, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: ed, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var gd = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    hd = { eventTypes: gd, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : qb(a);e = null == b ? e : qb(b);var g = fd.getPooled(gd.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = fd.getPooled(gd.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Bb(g, c, a, b);return [g, c];
  } },
    id = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a) {
  a = a.type;return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}
function kd(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }return 3 === b.tag ? 2 : 3;
}function ld(a) {
  return (a = a._reactInternalFiber) ? 2 === kd(a) : !1;
}function md(a) {
  2 !== kd(a) ? E("188") : void 0;
}
function nd(a) {
  var b = a.alternate;if (!b) return b = kd(a), 3 === b ? E("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return md(e), a;if (g === d) return md(e), b;g = g.sibling;
      }E("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }g ? void 0 : E("189");
      }
    }c.alternate !== d ? E("190") : void 0;
  }3 !== c.tag ? E("188") : void 0;return c.stateNode.current === c ? a : b;
}function od(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}
function pd(a) {
  a = nd(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}var qd = [];
function rd(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c;for (c = b; c["return"];) {
      c = c["return"];
    }c = 3 !== c.tag ? null : c.stateNode.containerInfo;if (!c) break;a.ancestors.push(b);b = pb(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], sd(a.topLevelType, b, a.nativeEvent, wc(a.nativeEvent));
  }
}var td = !0,
    sd = void 0;function ud(a) {
  td = !!a;
}function U(a, b, c) {
  return c ? ba.listen(c, b, vd.bind(null, a)) : null;
}function wd(a, b, c) {
  return c ? ba.capture(c, b, vd.bind(null, a)) : null;
}
function vd(a, b) {
  if (td) {
    var c = wc(b);c = pb(c);null === c || "number" !== typeof c.tag || 2 === kd(c) || (c = null);if (qd.length) {
      var d = qd.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      tc(rd, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > qd.length && qd.push(a);
    }
  }
}
var xd = Object.freeze({ get _enabled() {
    return td;
  }, get _handleTopLevel() {
    return sd;
  }, setHandleTopLevel: function setHandleTopLevel(a) {
    sd = a;
  }, setEnabled: ud, isEnabled: function isEnabled() {
    return td;
  }, trapBubbledEvent: U, trapCapturedEvent: wd, dispatchEvent: vd });function yd(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var zd = { animationend: yd("Animation", "AnimationEnd"), animationiteration: yd("Animation", "AnimationIteration"), animationstart: yd("Animation", "AnimationStart"), transitionend: yd("Transition", "TransitionEnd") },
    Ad = {},
    Bd = {};l.canUseDOM && (Bd = document.createElement("div").style, "AnimationEvent" in window || (delete zd.animationend.animation, delete zd.animationiteration.animation, delete zd.animationstart.animation), "TransitionEvent" in window || delete zd.transitionend.transition);
function Cd(a) {
  if (Ad[a]) return Ad[a];if (!zd[a]) return a;var b = zd[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in Bd) return Ad[a] = b[c];
  }return "";
}
var Dd = { topAbort: "abort", topAnimationEnd: Cd("animationend") || "animationend", topAnimationIteration: Cd("animationiteration") || "animationiteration", topAnimationStart: Cd("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: Cd("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    Ed = {},
    Fd = 0,
    Gd = "_reactListenersID" + ("" + Math.random()).slice(2);function Hd(a) {
  Object.prototype.hasOwnProperty.call(a, Gd) || (a[Gd] = Fd++, Ed[a[Gd]] = {});return Ed[a[Gd]];
}function Id(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Jd(a, b) {
  var c = Id(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Id(c);
  }
}function Kd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}
var Ld = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Md = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Nd = null,
    Od = null,
    Pd = null,
    Qd = !1;
function Rd(a, b) {
  if (Qd || null == Nd || Nd !== da()) return null;var c = Nd;"selectionStart" in c && Kd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return Pd && ea(Pd, c) ? null : (Pd = c, a = T.getPooled(Md.select, Od, a, b), a.type = "select", a.target = Nd, Ab(a), a);
}
var Sd = { eventTypes: Md, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Hd(e);f = Sa.onSelect;for (var g = 0; g < f.length; g++) {
          var h = f[g];if (!e.hasOwnProperty(h) || !e[h]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? qb(b) : window;switch (a) {case "topFocus":
        if (vc(e) || "true" === e.contentEditable) Nd = e, Od = b, Pd = null;break;case "topBlur":
        Pd = Od = Nd = null;break;case "topMouseDown":
        Qd = !0;break;case "topContextMenu":case "topMouseUp":
        return Qd = !1, Rd(c, d);case "topSelectionChange":
        if (Ld) break;
      case "topKeyDown":case "topKeyUp":
        return Rd(c, d);}return null;
  } };function Td(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Td, { animationName: null, elapsedTime: null, pseudoElement: null });function Ud(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(Ud, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function Vd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(Vd, { relatedTarget: null });
function Wd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var Xd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Yd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function Zd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}
bd.augmentClass(Zd, { key: function key(a) {
    if (a.key) {
      var b = Xd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = Wd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Yd[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: ed, charCode: function charCode(a) {
    return "keypress" === a.type ? Wd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? Wd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function $d(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass($d, { dataTransfer: null });function ae(a, b, c, d) {
  return T.call(this, a, b, c, d);
}bd.augmentClass(ae, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: ed });function be(a, b, c, d) {
  return T.call(this, a, b, c, d);
}T.augmentClass(be, { propertyName: null, elapsedTime: null, pseudoElement: null });
function ce(a, b, c, d) {
  return T.call(this, a, b, c, d);
}fd.augmentClass(ce, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var de = {},
    ee = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };de[a] = c;ee[b] = c;
});
var fe = { eventTypes: de, extractEvents: function extractEvents(a, b, c, d) {
    var e = ee[a];if (!e) return null;switch (a) {case "topKeyPress":
        if (0 === Wd(c)) return null;case "topKeyDown":case "topKeyUp":
        a = Zd;break;case "topBlur":case "topFocus":
        a = Vd;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        a = fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        a = $d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        a = ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        a = Td;break;case "topTransitionEnd":
        a = be;break;case "topScroll":
        a = bd;break;case "topWheel":
        a = ce;break;case "topCopy":case "topCut":case "topPaste":
        a = Ud;break;default:
        a = T;}b = a.getPooled(e, b, c, d);Ab(b);return b;
  } };sd = function sd(a, b, c, d) {
  a = jb(a, b, c, d);kb(a);lb(!1);
};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa = sb.getFiberCurrentPropsFromNode;Xa = sb.getInstanceFromNode;Ya = sb.getNodeFromInstance;hb.injectEventPluginsByName({ SimpleEventPlugin: fe, EnterLeaveEventPlugin: hd, ChangeEventPlugin: ad, SelectEventPlugin: Sd, BeforeInputEventPlugin: ic });var ge = [],
    he = -1;function V(a) {
  0 > he || (a.current = ge[he], ge[he] = null, he--);
}function W(a, b) {
  he++;ge[he] = a.current;a.current = b;
}new Set();var ie = { current: D },
    X = { current: !1 },
    je = D;function ke(a) {
  return le(a) ? je : ie.current;
}
function me(a, b) {
  var c = a.type.contextTypes;if (!c) return D;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function le(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}function ne(a) {
  le(a) && (V(X, a), V(ie, a));
}
function oe(a, b, c) {
  null != ie.cursor ? E("168") : void 0;W(ie, b, a);W(X, c, a);
}function pe(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : E("108", jd(a) || "Unknown", e);
  }return B({}, b, c);
}function qe(a) {
  if (!le(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || D;je = ie.current;W(ie, b, a);W(X, X.current, a);return !0;
}
function re(a, b) {
  var c = a.stateNode;c ? void 0 : E("169");if (b) {
    var d = pe(a, je);c.__reactInternalMemoizedMergedChildContext = d;V(X, a);V(ie, a);W(ie, d, a);
  } else V(X, a);W(X, b, a);
}
function Y(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.expirationTime = 0;this.alternate = null;
}
function se(a, b, c) {
  var d = a.alternate;null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.expirationTime = c;d.pendingProps = b;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.sibling = a.sibling;d.index = a.index;d.ref = a.ref;return d;
}
function te(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;"function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : E("130", null == e ? e : typeof e === "undefined" ? "undefined" : _typeof(e), "");d.expirationTime = c;return d;
}function ue(a, b, c, d) {
  b = new Y(10, d, b);b.pendingProps = a;b.expirationTime = c;return b;
}
function ve(a, b, c) {
  b = new Y(6, null, b);b.pendingProps = a;b.expirationTime = c;return b;
}function we(a, b, c) {
  b = new Y(7, a.key, b);b.type = a.handler;b.pendingProps = a;b.expirationTime = c;return b;
}function xe(a, b, c) {
  a = new Y(9, null, b);a.expirationTime = c;return a;
}function ye(a, b, c) {
  b = new Y(4, a.key, b);b.pendingProps = a.children || [];b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}var ze = null,
    Ae = null;
function Be(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}function Ce(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);ze = Be(function (a) {
      return b.onCommitFiberRoot(c, a);
    });Ae = Be(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}function De(a) {
  "function" === typeof ze && ze(a);
}function Ee(a) {
  "function" === typeof Ae && Ae(a);
}
function Fe(a) {
  return { baseState: a, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1 };
}function Ge(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}
function He(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = Fe(null));null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Fe(null))) : a = null;a = a !== d ? a : null;null === a ? Ge(d, b) : null === d.last || null === a.last ? (Ge(d, b), Ge(a, b)) : (Ge(d, b), a.last = b);
}function Ie(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
function Je(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = { baseState: c.baseState, expirationTime: c.expirationTime, first: c.first, last: c.last, isInitialized: c.isInitialized, callbackList: null, hasForceUpdate: !1 });c.expirationTime = 0;c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);for (var g = !0, h = c.first, k = !1; null !== h;) {
    var q = h.expirationTime;if (q > f) {
      var v = c.expirationTime;if (0 === v || v > q) c.expirationTime = q;k || (k = !0, c.baseState = a);
    } else {
      k || (c.first = h.next, null === c.first && (c.last = null));if (h.isReplace) a = Ie(h, d, a, e), g = !0;else if (q = Ie(h, d, a, e)) a = g ? B({}, a, q) : B(a, q), g = !1;h.isForced && (c.hasForceUpdate = !0);null !== h.callback && (q = c.callbackList, null === q && (q = c.callbackList = []), q.push(h));
    }h = h.next;
  }null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);k || (c.baseState = a);return a;
}
function Ke(a, b) {
  var c = a.callbackList;if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;d.callback = null;"function" !== typeof e ? E("191", e) : void 0;e.call(b);
  }
}
function Le(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;b._reactInternalFiber = a;
  }var f = { isMounted: ld, enqueueSetState: function enqueueSetState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !1, isForced: !1, nextCallback: null, next: null });a(c, g);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);He(c, { expirationTime: g, partialState: d, callback: e, isReplace: !0, isForced: !1, nextCallback: null, next: null });
      a(c, g);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = c._reactInternalFiber;d = void 0 === d ? null : d;var e = b(c);He(c, { expirationTime: e, partialState: null, callback: d, isReplace: !1, isForced: !0, nextCallback: null, next: null });a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = ke(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? me(a, d) : D;b = new c(b, g);e(a, b);f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : E("158");var h = ke(a);d.props = g;d.state = a.memoizedState = e;d.refs = D;d.context = me(a, h);null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);"function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Je(c, a, e, d, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= 4);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var h = b.memoizedProps,
          k = b.pendingProps;k || (k = h, null == k ? E("159") : void 0);var u = g.context,
          z = ke(b);z = me(b, z);"function" !== typeof g.componentWillReceiveProps || h === k && u === z || (u = g.state, g.componentWillReceiveProps(k, z), g.state !== u && f.enqueueReplaceState(g, g.state, null));u = b.memoizedState;e = null !== b.updateQueue ? Je(a, b, b.updateQueue, g, k, e) : u;if (!(h !== k || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;var G = k;if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) G = !0;else {
        var I = b.stateNode,
            L = b.type;G = "function" === typeof I.shouldComponentUpdate ? I.shouldComponentUpdate(G, e, z) : L.prototype && L.prototype.isPureReactComponent ? !ea(h, G) || !ea(u, e) : !0;
      }G ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, z), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, k), d(b, e));g.props = k;g.state = e;g.context = z;return G;
    } };
}var Qe = "function" === typeof Symbol && Symbol["for"],
    Re = Qe ? Symbol["for"]("react.element") : 60103,
    Se = Qe ? Symbol["for"]("react.call") : 60104,
    Te = Qe ? Symbol["for"]("react.return") : 60105,
    Ue = Qe ? Symbol["for"]("react.portal") : 60106,
    Ve = Qe ? Symbol["for"]("react.fragment") : 60107,
    We = "function" === typeof Symbol && Symbol.iterator;
function Xe(a) {
  if (null === a || "undefined" === typeof a) return null;a = We && a[We] || a["@@iterator"];return "function" === typeof a ? a : null;
}var Ye = Array.isArray;
function Ze(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && (2 !== b.tag ? E("110") : void 0, d = b.stateNode);d ? void 0 : E("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === D ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? E("148") : void 0;b._owner ? void 0 : E("149", c);
  }return c;
}
function $e(a, b) {
  "textarea" !== a.type && E("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function af(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;c.nextEffect = null;c.effectTag = 8;
    }
  }function c(c, d) {
    if (!a) return null;for (; null !== d;) {
      b(c, d), d = d.sibling;
    }return null;
  }function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function e(a, b, c) {
    a = se(a, b, c);a.index = 0;a.sibling = null;return a;
  }function f(b, c, d) {
    b.index = d;if (!a) return c;d = b.alternate;if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;b.effectTag = 2;return c;
  }function g(b) {
    a && null === b.alternate && (b.effectTag = 2);return b;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = ve(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function k(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ze(b, c), d["return"] = a, d;d = te(c, a.internalContextTag, d);d.ref = Ze(b, c);d["return"] = a;return d;
  }function q(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = we(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c, d);
    b["return"] = a;return b;
  }function v(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = xe(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = e(b, null, d);b.type = c.value;b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = ye(c, a.internalContextTag, d), b["return"] = a, b;b = e(b, c.children || [], d);b["return"] = a;return b;
  }function u(a, b, c, d, f) {
    if (null === b || 10 !== b.tag) return b = ue(c, a.internalContextTag, d, f), b["return"] = a, b;b = e(b, c, d);b["return"] = a;return b;
  }function z(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = ve("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Re:
          if (b.type === Ve) return b = ue(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;c = te(b, a.internalContextTag, c);c.ref = Ze(null, b);c["return"] = a;return c;case Se:
          return b = we(b, a.internalContextTag, c), b["return"] = a, b;case Te:
          return c = xe(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case Ue:
          return b = ye(b, a.internalContextTag, c), b["return"] = a, b;}if (Ye(b) || Xe(b)) return b = ue(b, a.internalContextTag, c, null), b["return"] = a, b;$e(a, b);
    }return null;
  }function G(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Re:
          return c.key === e ? c.type === Ve ? u(a, b, c.props.children, d, e) : k(a, b, c, d) : null;case Se:
          return c.key === e ? q(a, b, c, d) : null;case Te:
          return null === e ? v(a, b, c, d) : null;case Ue:
          return c.key === e ? y(a, b, c, d) : null;}if (Ye(c) || Xe(c)) return null !== e ? null : u(a, b, c, d, null);$e(a, c);
    }return null;
  }function I(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ve ? u(b, a, d.props.children, e, d.key) : k(b, a, d, e);case Se:
          return a = a.get(null === d.key ? c : d.key) || null, q(b, a, d, e);case Te:
          return a = a.get(c) || null, v(b, a, d, e);case Ue:
          return a = a.get(null === d.key ? c : d.key) || null, y(b, a, d, e);}if (Ye(d) || Xe(d)) return a = a.get(c) || null, u(b, a, d, e, null);$e(b, d);
    }return null;
  }function L(e, g, m, A) {
    for (var h = null, r = null, n = g, w = g = 0, k = null; null !== n && w < m.length; w++) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var x = G(e, n, m[w], A);if (null === x) {
        null === n && (n = k);break;
      }a && n && null === x.alternate && b(e, n);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;n = k;
    }if (w === m.length) return c(e, n), h;if (null === n) {
      for (; w < m.length; w++) {
        if (n = z(e, m[w], A)) g = f(n, g, w), null === r ? h = n : r.sibling = n, r = n;
      }return h;
    }for (n = d(e, n); w < m.length; w++) {
      if (k = I(n, e, w, m[w], A)) {
        if (a && null !== k.alternate) n["delete"](null === k.key ? w : k.key);g = f(k, g, w);null === r ? h = k : r.sibling = k;r = k;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }function N(e, g, m, A) {
    var h = Xe(m);"function" !== typeof h ? E("150") : void 0;m = h.call(m);null == m ? E("151") : void 0;for (var r = h = null, n = g, w = g = 0, k = null, x = m.next(); null !== n && !x.done; w++, x = m.next()) {
      n.index > w ? (k = n, n = null) : k = n.sibling;var J = G(e, n, x.value, A);if (null === J) {
        n || (n = k);break;
      }a && n && null === J.alternate && b(e, n);g = f(J, g, w);null === r ? h = J : r.sibling = J;r = J;n = k;
    }if (x.done) return c(e, n), h;if (null === n) {
      for (; !x.done; w++, x = m.next()) {
        x = z(e, x.value, A), null !== x && (g = f(x, g, w), null === r ? h = x : r.sibling = x, r = x);
      }return h;
    }for (n = d(e, n); !x.done; w++, x = m.next()) {
      if (x = I(n, e, w, x.value, A), null !== x) {
        if (a && null !== x.alternate) n["delete"](null === x.key ? w : x.key);g = f(x, g, w);null === r ? h = x : r.sibling = x;r = x;
      }
    }a && n.forEach(function (a) {
      return b(e, a);
    });return h;
  }return function (a, d, f, h) {
    "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && f.type === Ve && null === f.key && (f = f.props.children);
    var m = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f;if (m) switch (f.$$typeof) {case Re:
        a: {
          var r = f.key;for (m = d; null !== m;) {
            if (m.key === r) {
              if (10 === m.tag ? f.type === Ve : m.type === f.type) {
                c(a, m.sibling);d = e(m, f.type === Ve ? f.props.children : f.props, h);d.ref = Ze(m, f);d["return"] = a;a = d;break a;
              } else {
                c(a, m);break;
              }
            } else b(a, m);m = m.sibling;
          }f.type === Ve ? (d = ue(f.props.children, a.internalContextTag, h, f.key), d["return"] = a, a = d) : (h = te(f, a.internalContextTag, h), h.ref = Ze(d, f), h["return"] = a, a = h);
        }return g(a);case Se:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (7 === d.tag) {
                c(a, d.sibling);d = e(d, f, h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = we(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);case Te:
        a: {
          if (null !== d) if (9 === d.tag) {
            c(a, d.sibling);d = e(d, null, h);d.type = f.value;d["return"] = a;a = d;break a;
          } else c(a, d);d = xe(f, a.internalContextTag, h);d.type = f.value;d["return"] = a;a = d;
        }return g(a);case Ue:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);d = e(d, f.children || [], h);d["return"] = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = ye(f, a.internalContextTag, h);d["return"] = a;a = d;
        }return g(a);}if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f, h)) : (c(a, d), d = ve(f, a.internalContextTag, h)), d["return"] = a, a = d, g(a);if (Ye(f)) return L(a, d, f, h);if (Xe(f)) return N(a, d, f, h);m && $e(a, f);if ("undefined" === typeof f) switch (a.tag) {case 2:case 1:
        h = a.type, E("152", h.displayName || h.name || "Component");}return c(a, d);
  };
}var bf = af(!0),
    cf = af(!1);
function df(a, b, c, d, e) {
  function f(a, b, c) {
    var d = b.expirationTime;b.child = null === a ? cf(b, null, c, d) : bf(b, a.child, c, d);
  }function g(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= 128);
  }function h(a, b, c, d) {
    g(a, b);if (!c) return d && re(b, !1), q(a, b);c = b.stateNode;id.current = b;var e = c.render();b.effectTag |= 1;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && re(b, !0);return b.child;
  }function k(a) {
    var b = a.stateNode;b.pendingContext ? oe(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oe(a, b.context, !1);I(a, b.containerInfo);
  }function q(a, b) {
    null !== a && b.child !== a.child ? E("153") : void 0;if (null !== b.child) {
      a = b.child;var c = se(a, a.pendingProps, a.expirationTime);b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = se(a, a.pendingProps, a.expirationTime), c["return"] = b;
      }c.sibling = null;
    }return b.child;
  }function v(a, b) {
    switch (b.tag) {case 3:
        k(b);break;case 2:
        qe(b);break;case 4:
        I(b, b.stateNode.containerInfo);}return null;
  }var y = a.shouldSetTextContent,
      u = a.useSyncScheduling,
      z = a.shouldDeprioritizeSubtree,
      G = b.pushHostContext,
      I = b.pushHostContainer,
      L = c.enterHydrationState,
      N = c.resetHydrationState,
      J = c.tryToClaimNextHydratableInstance;a = Le(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var w = a.adoptClassInstance,
      m = a.constructClassInstance,
      A = a.mountClassInstance,
      Ob = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);switch (b.tag) {case 0:
          null !== a ? E("155") : void 0;var d = b.type,
              e = b.pendingProps,
              r = ke(b);r = me(b, r);d = d(e, r);b.effectTag |= 1;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = 2, e = qe(b), w(b, d), A(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case 1:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = q(a, b);break a;
            }d = ke(b);d = me(b, d);e = e(c, d);b.effectTag |= 1;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case 2:
          return e = qe(b), d = void 0, null === a ? b.stateNode ? E("153") : (m(b, b.pendingProps), A(b, c), d = !0) : d = Ob(a, b, c), h(a, b, d, e);case 3:
          return k(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Je(a, b, e, null, null, c), d === e ? (N(), b = q(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && L(b) ? (b.effectTag |= 2, b.child = cf(b, null, d, c)) : (N(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (N(), b = q(a, b)), b;case 5:
          G(b);null === a && J(b);e = b.type;var n = b.memoizedProps;d = b.pendingProps;null === d && (d = n, null === d ? E("154") : void 0);r = null !== a ? a.memoizedProps : null;X.current || null !== d && n !== d ? (n = d.children, y(e, d) ? n = null : r && y(e, r) && (b.effectTag |= 16), g(a, b), 2147483647 !== c && !u && z(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, n), b.memoizedProps = d, b = b.child)) : b = q(a, b);return b;case 6:
          return null === a && J(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case 8:
          b.tag = 7;case 7:
          e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null === e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;d = e.children;b.stateNode = null === a ? cf(b, b.stateNode, d, c) : bf(b, b.stateNode, d, c);b.memoizedProps = e;return b.stateNode;
        case 9:
          return null;case 4:
          a: {
            I(b, b.stateNode.containerInfo);e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null == e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = q(a, b);break a;
            }null === a ? b.child = bf(b, null, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case 10:
          a: {
            c = b.pendingProps;if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = q(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          E("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case 2:
          qe(b);break;case 3:
          k(b);break;default:
          E("157");}b.effectTag |= 64;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);b.firstEffect = null;b.lastEffect = null;b.child = null === a ? cf(b, null, null, c) : bf(b, a.child, null, c);2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
function ef(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      h = a.finalizeInitialChildren,
      k = a.prepareUpdate,
      q = a.persistence,
      v = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      z = b.popHostContainer,
      G = c.prepareToHydrateHostInstance,
      I = c.prepareToHydrateHostTextInstance,
      L = c.popHydrationState,
      N = void 0,
      J = void 0,
      w = void 0;a.mutation ? (N = function N() {}, J = function J(a, b, c) {
    (b.updateQueue = c) && d(b);
  }, w = function w(a, b, c, e) {
    c !== e && d(b);
  }) : q ? E("235") : E("236");
  return { completeWork: function completeWork(a, b, c) {
      var m = b.pendingProps;if (null === m) m = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;switch (b.tag) {case 1:
          return null;case 2:
          return ne(b), null;case 3:
          z(b);V(X, b);V(ie, b);m = b.stateNode;m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null);if (null === a || null === a.child) L(b), b.effectTag &= -3;N(b);return null;case 5:
          y(b);c = v();var A = b.type;if (null !== a && null != b.stateNode) {
            var p = a.memoizedProps,
                q = b.stateNode,
                x = u();q = k(q, A, p, m, c, x);J(a, b, q, A, p, m, c);a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!m) return null === b.stateNode ? E("166") : void 0, null;a = u();if (L(b)) G(b, c, a) && d(b);else {
              a = e(A, m, c, a, b);a: for (p = b.child; null !== p;) {
                if (5 === p.tag || 6 === p.tag) g(a, p.stateNode);else if (4 !== p.tag && null !== p.child) {
                  p.child["return"] = p;p = p.child;continue;
                }if (p === b) break;for (; null === p.sibling;) {
                  if (null === p["return"] || p["return"] === b) break a;p = p["return"];
                }p.sibling["return"] = p["return"];p = p.sibling;
              }h(a, A, m, c) && d(b);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= 128);
          }return null;case 6:
          if (a && null != b.stateNode) w(a, b, a.memoizedProps, m);else {
            if ("string" !== typeof m) return null === b.stateNode ? E("166") : void 0, null;a = v();c = u();L(b) ? I(b) && d(b) : b.stateNode = f(m, a, c, b);
          }return null;case 7:
          (m = b.memoizedProps) ? void 0 : E("165");b.tag = 8;A = [];a: for ((p = b.stateNode) && (p["return"] = b); null !== p;) {
            if (5 === p.tag || 6 === p.tag || 4 === p.tag) E("247");else if (9 === p.tag) A.push(p.type);else if (null !== p.child) {
              p.child["return"] = p;p = p.child;continue;
            }for (; null === p.sibling;) {
              if (null === p["return"] || p["return"] === b) break a;p = p["return"];
            }p.sibling["return"] = p["return"];p = p.sibling;
          }p = m.handler;m = p(m.props, A);b.child = bf(b, null !== a ? a.child : null, m, c);return b.child;case 8:
          return b.tag = 7, null;case 9:
          return null;case 10:
          return null;case 4:
          return z(b), N(b), null;case 0:
          E("167");default:
          E("156");}
    } };
}
function ff(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (A) {
      b(a, A);
    }
  }function d(a) {
    "function" === typeof Ee && Ee(a);switch (a.tag) {case 2:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (A) {
          b(a, A);
        }break;case 5:
        c(a);break;case 7:
        e(a.stateNode);break;case 4:
        k && g(a);}
  }function e(a) {
    for (var b = a;;) {
      if (d(b), null === b.child || k && 4 === b.tag) {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      } else b.child["return"] = b, b = b.child;
    }
  }function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? E("160") : void 0;switch (c.tag) {case 5:
              f = c.stateNode;g = !1;break a;case 3:
              f = c.stateNode.containerInfo;g = !0;break a;case 4:
              f = c.stateNode.containerInfo;g = !0;break a;}c = c["return"];
        }c = !0;
      }if (5 === b.tag || 6 === b.tag) e(b), g ? J(f, b.stateNode) : N(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];4 === b.tag && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }var h = a.getPublicInstance,
      k = a.mutation;a = a.persistence;k || (a ? E("235") : E("236"));var q = k.commitMount,
      v = k.commitUpdate,
      y = k.resetTextContent,
      u = k.commitTextUpdate,
      z = k.appendChild,
      G = k.appendChildToContainer,
      I = k.insertBefore,
      L = k.insertInContainerBefore,
      N = k.removeChild,
      J = k.removeChildFromContainer;return { commitResetTextContent: function commitResetTextContent(a) {
      y(a.stateNode);
    }, commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;break a;
          }b = b["return"];
        }E("160");c = void 0;
      }var d = b = void 0;switch (c.tag) {case 5:
          b = c.stateNode;d = !1;break;case 3:
          b = c.stateNode.containerInfo;d = !0;break;case 4:
          b = c.stateNode.containerInfo;d = !0;break;default:
          E("161");}c.effectTag & 16 && (y(b), c.effectTag &= -17);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & 2)) {
          c = c.stateNode;break a;
        }
      }for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? L(b, e.stateNode, c) : I(b, e.stateNode, c) : d ? G(b, e.stateNode) : z(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;e = e.child;continue;
        }if (e === a) break;for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;e = e["return"];
        }e.sibling["return"] = e["return"];e = e.sibling;
      }
    }, commitDeletion: function commitDeletion(a) {
      g(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case 2:
          break;case 5:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && v(c, f, e, a, d, b);
          }break;case 6:
          null === b.stateNode ? E("162") : void 0;c = b.memoizedProps;u(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case 3:
          break;default:
          E("163");}
    }, commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case 2:
          var c = b.stateNode;if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b = b.updateQueue;null !== b && Ke(b, c);break;case 3:
          c = b.updateQueue;null !== c && Ke(c, null !== b.child ? b.child.stateNode : null);break;case 5:
          c = b.stateNode;null === a && b.effectTag & 4 && q(c, b.type, b.memoizedProps, b);break;case 6:
          break;case 4:
          break;default:
          E("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case 5:
            b(h(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var gf = {};
function hf(a) {
  function b(a) {
    a === gf ? E("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = { current: gf },
      f = { current: gf },
      g = { current: gf };return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      V(e, a);V(f, a);V(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (V(e, a), V(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      W(g, b, a);b = d(b);W(f, a, a);W(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          h = b(e.current);
      d = c(h, a.type, d);h !== d && (W(f, a, a), W(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = gf;g.current = gf;
    } };
}
function jf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);c.type = "DELETED";c.stateNode = b;c["return"] = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case 5:
        return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;case 6:
        return b = g(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent;
  a = a.hydration;if (!a) return { enterHydrationState: function enterHydrationState() {
      return !1;
    }, resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      E("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      E("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      h = a.getNextHydratableSibling,
      k = a.getFirstHydratableChild,
      q = a.hydrateInstance,
      v = a.hydrateTextInstance,
      y = null,
      u = null,
      z = !1;return { enterHydrationState: function enterHydrationState(a) {
      u = k(a.stateNode.containerInfo);y = a;return z = !0;
    }, resetHydrationState: function resetHydrationState() {
      u = y = null;z = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (z) {
        var d = u;if (d) {
          if (!c(a, d)) {
            d = h(d);if (!d || !c(a, d)) {
              a.effectTag |= 2;z = !1;y = a;return;
            }b(y, u);
          }y = a;u = k(d);
        } else a.effectTag |= 2, z = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = q(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return v(a.stateNode, a.memoizedProps, a);
    }, popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!z) return d(a), z = !0, !1;var c = a.type;if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) {
        b(a, c), c = h(c);
      }d(a);u = y ? h(a.stateNode) : null;return !0;
    } };
}
function kf(a) {
  function b(a) {
    Qb = ja = !0;var b = a.stateNode;b.current === a ? E("177") : void 0;b.isReadyForCommit = !1;id.current = null;if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;yg();for (t = c; null !== t;) {
      var d = !1,
          e = void 0;try {
        for (; null !== t;) {
          var f = t.effectTag;f & 16 && zg(t);if (f & 128) {
            var g = t.alternate;null !== g && Ag(g);
          }switch (f & -242) {case 2:
              Ne(t);t.effectTag &= -3;break;case 6:
              Ne(t);t.effectTag &= -3;Oe(t.alternate, t);break;case 4:
              Oe(t.alternate, t);break;case 8:
              Sc = !0, Bg(t), Sc = !1;}t = t.nextEffect;
        }
      } catch (Tc) {
        d = !0, e = Tc;
      }d && (null === t ? E("178") : void 0, h(t, e), null !== t && (t = t.nextEffect));
    }Cg();b.current = a;for (t = c; null !== t;) {
      c = !1;d = void 0;try {
        for (; null !== t;) {
          var k = t.effectTag;k & 36 && Dg(t.alternate, t);k & 128 && Eg(t);if (k & 64) switch (e = t, f = void 0, null !== R && (f = R.get(e), R["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = R.get(e), R["delete"](e))), null == f ? E("184") : void 0, e.tag) {case 2:
              e.stateNode.componentDidCatch(f.error, { componentStack: f.componentStack });
              break;case 3:
              null === ca && (ca = f.error);break;default:
              E("157");}var Qc = t.nextEffect;t.nextEffect = null;t = Qc;
        }
      } catch (Tc) {
        c = !0, d = Tc;
      }c && (null === t ? E("178") : void 0, h(t, d), null !== t && (t = t.nextEffect));
    }ja = Qb = !1;"function" === typeof De && De(a.stateNode);ha && (ha.forEach(G), ha = null);null !== ca && (a = ca, ca = null, Ob(a));b = b.current.expirationTime;0 === b && (qa = R = null);return b;
  }function c(a) {
    for (;;) {
      var b = Fg(a.alternate, a, H),
          c = a["return"],
          d = a.sibling;var e = a;if (2147483647 === H || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }e.expirationTime = f;
      }if (null !== b) return b;null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;break;
      }
    }return null;
  }function d(a) {
    var b = rg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function e(a) {
    var b = Gg(a.alternate, a, H);null === b && (b = c(a));id.current = null;return b;
  }function f(a) {
    if (null !== R) {
      if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
        F = k(F) ? e(F) : d(F);
      } else for (; null !== F && !A();) {
        F = k(F) ? e(F) : d(F);
      }
    } else if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) {
      F = d(F);
    } else for (; null !== F && !A();) {
      F = d(F);
    }
  }function g(a, b) {
    ja ? E("243") : void 0;ja = !0;a.isReadyForCommit = !1;if (a !== ra || b !== H || null === F) {
      for (; -1 < he;) {
        ge[he] = null, he--;
      }je = D;ie.current = D;X.current = !1;x();ra = a;H = b;F = se(ra.current, null, b);
    }var c = !1,
        d = null;try {
      f(b);
    } catch (Rc) {
      c = !0, d = Rc;
    }for (; c;) {
      if (eb) {
        ca = d;break;
      }var g = F;if (null === g) eb = !0;else {
        var k = h(g, d);null === k ? E("183") : void 0;if (!eb) {
          try {
            c = k;d = b;for (k = c; null !== g;) {
              switch (g.tag) {case 2:
                  ne(g);break;case 5:
                  qg(g);break;case 3:
                  p(g);break;case 4:
                  p(g);}if (g === k || g.alternate === k) break;g = g["return"];
            }F = e(c);f(d);
          } catch (Rc) {
            c = !0;d = Rc;continue;
          }break;
        }
      }
    }b = ca;eb = ja = !1;ca = null;null !== b && Ob(b);return a.isReadyForCommit ? a.current.alternate : null;
  }function h(a, b) {
    var c = id.current = null,
        d = !1,
        e = !1,
        f = null;if (3 === a.tag) c = a, q(a) && (eb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = jd(g), c = g, e = !0) : 3 === g.tag && (c = g);if (q(g)) {
        if (Sc || null !== ha && (ha.has(g) || null !== g.alternate && ha.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === qa && (qa = new Set());qa.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case 0:case 1:case 2:case 5:
            var k = g._debugOwner,
                Qc = g._debugSource;var m = jd(g);var n = null;k && (n = jd(k));k = Qc;m = "\n    in " + (m || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");break a;default:
            m = "";}h += m;g = g["return"];
      } while (g);g = h;a = jd(a);null === R && (R = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };R.set(c, b);try {
        var p = b.error;p && p.suppressReactErrorLogging || console.error(p);
      } catch (Vc) {
        Vc && Vc.suppressReactErrorLogging || console.error(Vc);
      }Qb ? (null === ha && (ha = new Set()), ha.add(c)) : G(c);return c;
    }null === ca && (ca = b);return null;
  }function k(a) {
    return null !== R && (R.has(a) || null !== a.alternate && R.has(a.alternate));
  }function q(a) {
    return null !== qa && (qa.has(a) || null !== a.alternate && qa.has(a.alternate));
  }function v() {
    return 20 * (((I() + 100) / 20 | 0) + 1);
  }function y(a) {
    return 0 !== ka ? ka : ja ? Qb ? 1 : H : !Hg || a.internalContextTag & 1 ? v() : 1;
  }function u(a, b) {
    return z(a, b, !1);
  }function z(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;!ja && c === ra && b < H && (F = ra = null, H = 0);var d = c,
            e = b;Rb > Ig && E("185");if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === O ? (sa = O = d, d.nextScheduledRoot = d) : (O = O.nextScheduledRoot = d, O.nextScheduledRoot = sa);else {
          var f = d.remainingExpirationTime;if (0 === f || e < f) d.remainingExpirationTime = e;
        }Fa || (la ? Sb && (ma = d, na = 1, m(ma, na)) : 1 === e ? w(1, null) : L(e));!ja && c === ra && b < H && (F = ra = null, H = 0);
      } else break;a = a["return"];
    }
  }function G(a) {
    z(a, 1, !0);
  }function I() {
    return Uc = ((Wc() - Pe) / 10 | 0) + 2;
  }function L(a) {
    if (0 !== Tb) {
      if (a > Tb) return;Jg(Xc);
    }var b = Wc() - Pe;Tb = a;Xc = Kg(J, { timeout: 10 * (a - 2) - b });
  }function N() {
    var a = 0,
        b = null;if (null !== O) for (var c = O, d = sa; null !== d;) {
      var e = d.remainingExpirationTime;if (0 === e) {
        null === c || null === O ? E("244") : void 0;if (d === d.nextScheduledRoot) {
          sa = O = d.nextScheduledRoot = null;break;
        } else if (d === sa) sa = e = d.nextScheduledRoot, O.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === O) {
          O = c;O.nextScheduledRoot = sa;d.nextScheduledRoot = null;break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;if (d === O) break;c = d;d = d.nextScheduledRoot;
      }
    }c = ma;null !== c && c === b ? Rb++ : Rb = 0;ma = b;na = a;
  }function J(a) {
    w(0, a);
  }function w(a, b) {
    fb = b;for (N(); null !== ma && 0 !== na && (0 === a || na <= a) && !Yc;) {
      m(ma, na), N();
    }null !== fb && (Tb = 0, Xc = -1);0 !== na && L(na);fb = null;Yc = !1;Rb = 0;if (Ub) throw a = Zc, Zc = null, Ub = !1, a;
  }function m(a, c) {
    Fa ? E("245") : void 0;Fa = !0;if (c <= I()) {
      var d = a.finishedWork;null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (A() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));Fa = !1;
  }function A() {
    return null === fb || fb.timeRemaining() > Lg ? !1 : Yc = !0;
  }function Ob(a) {
    null === ma ? E("246") : void 0;ma.remainingExpirationTime = 0;Ub || (Ub = !0, Zc = a);
  }var r = hf(a),
      n = jf(a),
      p = r.popHostContainer,
      qg = r.popHostContext,
      x = r.resetHostContainer,
      Me = df(a, r, n, u, y),
      rg = Me.beginWork,
      Gg = Me.beginFailedWork,
      Fg = ef(a, r, n).completeWork;r = ff(a, h);var zg = r.commitResetTextContent,
      Ne = r.commitPlacement,
      Bg = r.commitDeletion,
      Oe = r.commitWork,
      Dg = r.commitLifeCycles,
      Eg = r.commitAttachRef,
      Ag = r.commitDetachRef,
      Wc = a.now,
      Kg = a.scheduleDeferredCallback,
      Jg = a.cancelDeferredCallback,
      Hg = a.useSyncScheduling,
      yg = a.prepareForCommit,
      Cg = a.resetAfterCommit,
      Pe = Wc(),
      Uc = 2,
      ka = 0,
      ja = !1,
      F = null,
      ra = null,
      H = 0,
      t = null,
      R = null,
      qa = null,
      ha = null,
      ca = null,
      eb = !1,
      Qb = !1,
      Sc = !1,
      sa = null,
      O = null,
      Tb = 0,
      Xc = -1,
      Fa = !1,
      ma = null,
      na = 0,
      Yc = !1,
      Ub = !1,
      Zc = null,
      fb = null,
      la = !1,
      Sb = !1,
      Ig = 1E3,
      Rb = 0,
      Lg = 1;return { computeAsyncExpiration: v, computeExpirationForFiber: y, scheduleWork: u, batchedUpdates: function batchedUpdates(a, b) {
      var c = la;la = !0;try {
        return a(b);
      } finally {
        (la = c) || Fa || w(1, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      if (la && !Sb) {
        Sb = !0;try {
          return a();
        } finally {
          Sb = !1;
        }
      }return a();
    }, flushSync: function flushSync(a) {
      var b = la;la = !0;try {
        a: {
          var c = ka;ka = 1;try {
            var d = a();break a;
          } finally {
            ka = c;
          }d = void 0;
        }return d;
      } finally {
        la = b, Fa ? E("187") : void 0, w(1, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = ka;ka = v();try {
        return a();
      } finally {
        ka = b;
      }
    } };
}
function lf(a) {
  function b(a) {
    a = od(a);return null === a ? null : a.stateNode;
  }var c = a.getPublicInstance;a = kf(a);var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;return { createContainer: function createContainer(a, b) {
      var c = new Y(3, null, 0);a = { current: c, containerInfo: a, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: b, nextScheduledRoot: null };return c.stateNode = a;
    }, updateContainer: function updateContainer(a, b, c, q) {
      var g = b.current;if (c) {
        c = c._reactInternalFiber;var h;b: {
          2 === kd(c) && 2 === c.tag ? void 0 : E("170");for (h = c; 3 !== h.tag;) {
            if (le(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }(h = h["return"]) ? void 0 : E("171");
          }h = h.stateNode.context;
        }c = le(c) ? pe(c, h) : h;
      } else c = D;null === b.context ? b.context = c : b.pendingContext = c;b = q;b = void 0 === b ? null : b;q = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);He(g, { expirationTime: q, partialState: { element: a }, callback: b, isReplace: !1, isForced: !1,
        nextCallback: null, next: null });f(g, q);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
          return c(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: b, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = pd(a);return null === a ? null : a.stateNode;
    }, injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;return Ce(B({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        }, findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        } }));
    } };
}var mf = Object.freeze({ default: lf }),
    nf = mf && lf || mf,
    of = nf["default"] ? nf["default"] : nf;function pf(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: Ue, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}var qf = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    rf = void 0;rf = qf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var sf = void 0,
    tf = void 0;
if (l.canUseDOM) {
  if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
    var uf = null,
        vf = !1,
        wf = -1,
        xf = !1,
        yf = 0,
        zf = 33,
        Af = 33,
        Bf;Bf = qf ? { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - performance.now();return 0 < a ? a : 0;
      } } : { didTimeout: !1, timeRemaining: function timeRemaining() {
        var a = yf - Date.now();return 0 < a ? a : 0;
      } };var Cf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      if (a.source === window && a.data === Cf) {
        vf = !1;a = rf();if (0 >= yf - a) {
          if (-1 !== wf && wf <= a) Bf.didTimeout = !0;else {
            xf || (xf = !0, requestAnimationFrame(Df));return;
          }
        } else Bf.didTimeout = !1;wf = -1;a = uf;uf = null;null !== a && a(Bf);
      }
    }, !1);var Df = function Df(a) {
      xf = !1;var b = a - yf + Af;b < Af && zf < Af ? (8 > b && (b = 8), Af = b < zf ? zf : b) : zf = b;yf = a + Af;vf || (vf = !0, window.postMessage(Cf, "*"));
    };sf = function sf(a, b) {
      uf = a;null != b && "number" === typeof b.timeout && (wf = rf() + b.timeout);xf || (xf = !0, requestAnimationFrame(Df));return 0;
    };tf = function tf() {
      uf = null;vf = !1;wf = -1;
    };
  } else sf = window.requestIdleCallback, tf = window.cancelIdleCallback;
} else sf = function sf(a) {
  return setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });
}, tf = function tf(a) {
  clearTimeout(a);
};var Ef = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Ff = {},
    Gf = {};
function Hf(a) {
  if (Gf.hasOwnProperty(a)) return !0;if (Ff.hasOwnProperty(a)) return !1;if (Ef.test(a)) return Gf[a] = !0;Ff[a] = !0;return !1;
}
function If(a, b, c) {
  var d = wa(b);if (d && va(b, c)) {
    var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Jf(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Kf(a, b, va(b, c) ? c : null);
}
function Kf(a, b, c) {
  Hf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}function Jf(a, b) {
  var c = wa(b);c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}
function Lf(a, b) {
  var c = b.value,
      d = b.checked;return B({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
}function Mf(a, b) {
  var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function Nf(a, b) {
  b = b.checked;null != b && If(a, "checked", b);
}function Of(a, b) {
  Nf(a, b);var c = b.value;if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Pf(a, b) {
  switch (b.type) {case "submit":case "reset":
      break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
      a.value = "";a.value = a.defaultValue;break;default:
      a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
}function Qf(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}
function Rf(a, b) {
  a = B({ children: void 0 }, b);if (b = Qf(b.children)) a.children = b;return a;
}function Sf(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + c;b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function Tf(a, b) {
  var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
}function Uf(a, b) {
  null != b.dangerouslySetInnerHTML ? E("91") : void 0;return B({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function Vf(a, b) {
  var c = b.value;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? E("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : E("93"), b = b[0]), c = "" + b), null == c && (c = ""));a._wrapperState = { initialValue: "" + c };
}
function Wf(a, b) {
  var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
}function Xf(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var Yf = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Zf(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function $f(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Zf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var ag = void 0,
    bg = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Yf.svg || "innerHTML" in a) a.innerHTML = b;else {
    ag = ag || document.createElement("div");ag.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";for (b = ag.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});
function cg(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
var dg = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0,
  stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    eg = ["Webkit", "ms", "Moz", "O"];Object.keys(dg).forEach(function (a) {
  eg.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);dg[b] = dg[a];
  });
});
function fg(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || dg.hasOwnProperty(e) && dg[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var gg = B({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function hg(a, b, c) {
  b && (gg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? E("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? E("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : E("61")), null != b.style && "object" !== _typeof(b.style) ? E("62", c()) : void 0);
}
function ig(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}var jg = Yf.html,
    kg = C.thatReturns("");
function lg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Hd(a);b = Sa[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? wd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (wd("topFocus", "focus", a), wd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (yc("cancel", !0) && wd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (yc("close", !0) && wd("topClose", "close", a), c.topClose = !0) : Dd.hasOwnProperty(e) && U(e, Dd[e], a), c[e] = !0);
  }
}
var mg = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" };function ng(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;d === jg && (d = Zf(a));d === jg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
}function og(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}
function pg(a, b, c, d) {
  var e = ig(b, c);switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);var f = c;break;case "video":case "audio":
      for (f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }f = c;break;case "source":
      U("topError", "error", a);f = c;break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);f = c;break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);f = c;break;case "details":
      U("topToggle", "toggle", a);f = c;break;case "input":
      Mf(a, c);f = Lf(a, c);U("topInvalid", "invalid", a);
      lg(d, "onChange");break;case "option":
      f = Rf(a, c);break;case "select":
      Tf(a, c);f = B({}, c, { value: void 0 });U("topInvalid", "invalid", a);lg(d, "onChange");break;case "textarea":
      Vf(a, c);f = Uf(a, c);U("topInvalid", "invalid", a);lg(d, "onChange");break;default:
      f = c;}hg(b, f, kg);var g = f,
      h;for (h in g) {
    if (g.hasOwnProperty(h)) {
      var k = g[h];"style" === h ? fg(a, k, kg) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, null != k && bg(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && cg(a, k) : "number" === typeof k && cg(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (Ra.hasOwnProperty(h) ? null != k && lg(d, h) : e ? Kf(a, h, k) : null != k && If(a, h, k));
    }
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "option":
      null != c.value && a.setAttribute("value", c.value);break;case "select":
      a.multiple = !!c.multiple;b = c.value;null != b ? Sf(a, !!c.multiple, b, !1) : null != c.defaultValue && Sf(a, !!c.multiple, c.defaultValue, !0);break;default:
      "function" === typeof f.onClick && (a.onclick = C);}
}
function sg(a, b, c, d, e) {
  var f = null;switch (b) {case "input":
      c = Lf(a, c);d = Lf(a, d);f = [];break;case "option":
      c = Rf(a, c);d = Rf(a, d);f = [];break;case "select":
      c = B({}, c, { value: void 0 });d = B({}, d, { value: void 0 });f = [];break;case "textarea":
      c = Uf(a, c);d = Uf(a, d);f = [];break;default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);}hg(b, d, kg);var g, h;a = null;for (g in c) {
    if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], b) {
      b.hasOwnProperty(h) && (a || (a = {}), a[h] = "");
    } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Ra.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
  }for (g in d) {
    var k = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) {
      if (b) {
        for (h in b) {
          !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), a[h] = "");
        }for (h in k) {
          k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
        }
      } else a || (f || (f = []), f.push(g, a)), a = k;
    } else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Ra.hasOwnProperty(g) ? (null != k && lg(e, g), f || b === k || (f = [])) : (f = f || []).push(g, k));
  }a && (f = f || []).push("style", a);return f;
}
function tg(a, b, c, d, e) {
  "input" === c && "radio" === e.type && null != e.name && Nf(a, e);ig(c, d);d = ig(c, e);for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        h = b[f + 1];"style" === g ? fg(a, h, kg) : "dangerouslySetInnerHTML" === g ? bg(a, h) : "children" === g ? cg(a, h) : d ? null != h ? Kf(a, g, h) : a.removeAttribute(g) : null != h ? If(a, g, h) : Jf(a, g);
  }switch (c) {case "input":
      Of(a, e);break;case "textarea":
      Wf(a, e);break;case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Sf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Sf(a, !!e.multiple, e.defaultValue, !0) : Sf(a, !!e.multiple, e.multiple ? [] : "", !1));}
}
function ug(a, b, c, d, e) {
  switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);break;case "video":case "audio":
      for (var f in mg) {
        mg.hasOwnProperty(f) && U(f, mg[f], a);
      }break;case "source":
      U("topError", "error", a);break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);break;case "details":
      U("topToggle", "toggle", a);break;case "input":
      Mf(a, c);U("topInvalid", "invalid", a);lg(e, "onChange");break;case "select":
      Tf(a, c);
      U("topInvalid", "invalid", a);lg(e, "onChange");break;case "textarea":
      Vf(a, c), U("topInvalid", "invalid", a), lg(e, "onChange");}hg(b, c, kg);d = null;for (var g in c) {
    c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Ra.hasOwnProperty(g) && null != f && lg(e, g));
  }switch (b) {case "input":
      Bc(a);Pf(a, c);break;case "textarea":
      Bc(a);Xf(a, c);break;case "select":case "option":
      break;default:
      "function" === typeof c.onClick && (a.onclick = C);}return d;
}function vg(a, b) {
  return a.nodeValue !== b;
}
var wg = Object.freeze({ createElement: ng, createTextNode: og, setInitialProperties: pg, diffProperties: sg, updateProperties: tg, diffHydratedProperties: ug, diffHydratedText: vg, warnForUnmatchedText: function warnForUnmatchedText() {}, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        Of(a, c);b = c.name;if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) {
            c = c.parentNode;
          }c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
            var d = c[b];if (d !== a && d.form === a.form) {
              var e = rb(d);e ? void 0 : E("90");Cc(d);Of(d, e);
            }
          }
        }break;case "textarea":
        Wf(a, c);break;case "select":
        b = c.value, null != b && Sf(a, !!c.multiple, b, !1);}
  } });nc.injectFiberControlledHostComponent(wg);var xg = null,
    Mg = null;function Ng(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function Og(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}
var Z = of({ getRootHostContext: function getRootHostContext(a) {
    var b = a.nodeType;switch (b) {case 9:case 11:
        a = (a = a.documentElement) ? a.namespaceURI : $f(null, "");break;default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = $f(a, b);}return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return $f(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    xg = td;var a = da();if (Kd(a)) {
      if ("selectionStart" in a) var b = { start: a.selectionStart, end: a.selectionEnd };else a: {
        var c = window.getSelection && window.getSelection();
        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;var d = c.anchorOffset,
              e = c.focusNode;c = c.focusOffset;try {
            b.nodeType, e.nodeType;
          } catch (z) {
            b = null;break a;
          }var f = 0,
              g = -1,
              h = -1,
              k = 0,
              q = 0,
              v = a,
              y = null;b: for (;;) {
            for (var u;;) {
              v !== b || 0 !== d && 3 !== v.nodeType || (g = f + d);v !== e || 0 !== c && 3 !== v.nodeType || (h = f + c);3 === v.nodeType && (f += v.nodeValue.length);if (null === (u = v.firstChild)) break;y = v;v = u;
            }for (;;) {
              if (v === a) break b;y === b && ++k === d && (g = f);y === e && ++q === c && (h = f);if (null !== (u = v.nextSibling)) break;v = y;y = v.parentNode;
            }v = u;
          }b = -1 === g || -1 === h ? null : { start: g, end: h };
        } else b = null;
      }b = b || { start: 0, end: 0 };
    } else b = null;Mg = { focusedElem: a, selectionRange: b };ud(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    var a = Mg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;if (b !== c && fa(document.documentElement, c)) {
      if (Kd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();var e = c[Eb()].length;a = Math.min(d.start, e);d = void 0 === d.end ? a : Math.min(d.end, e);!b.extend && a > d && (e = d, d = a, a = e);e = Jd(c, a);var f = Jd(c, d);if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();g.setStart(e.node, e.offset);b.removeAllRanges();a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }b = [];for (a = c; a = a.parentNode;) {
        1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ia(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }Mg = null;ud(xg);xg = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = ng(a, b, c, d);a[Q] = e;a[ob] = b;return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    pg(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return sg(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = og(a, b);a[Q] = d;return a;
  }, now: rf, mutation: { commitMount: function commitMount(a) {
      a.focus();
    }, commitUpdate: function commitUpdate(a, b, c, d, e) {
      a[ob] = e;tg(a, b, c, d, e);
    }, resetTextContent: function resetTextContent(a) {
      a.textContent = "";
    }, commitTextUpdate: function commitTextUpdate(a, b, c) {
      a.nodeValue = c;
    }, appendChild: function appendChild(a, b) {
      a.appendChild(b);
    }, appendChildToContainer: function appendChildToContainer(a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    }, insertBefore: function insertBefore(a, b, c) {
      a.insertBefore(b, c);
    }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    }, removeChild: function removeChild(a, b) {
      a.removeChild(b);
    }, removeChildFromContainer: function removeChildFromContainer(a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    } }, hydration: { canHydrateInstance: function canHydrateInstance(a, b) {
      return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
      return "" === b || 3 !== a.nodeType ? null : a;
    }, getNextHydratableSibling: function getNextHydratableSibling(a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, getFirstHydratableChild: function getFirstHydratableChild(a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
      a[Q] = f;a[ob] = c;return ug(a, b, c, e, d);
    }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
      a[Q] = c;return vg(a, b);
    }, didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance() {},
    didNotHydrateContainerInstance: function didNotHydrateContainerInstance() {}, didNotHydrateInstance: function didNotHydrateInstance() {}, didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance: function didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance() {} }, scheduleDeferredCallback: sf, cancelDeferredCallback: tf, useSyncScheduling: !0 });rc = Z.batchedUpdates;
function Pg(a, b, c, d, e) {
  Ng(c) ? void 0 : E("200");var f = c._reactRootContainer;if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Og(c);if (!d) for (f = void 0; f = c.lastChild;) {
      c.removeChild(f);
    }var g = Z.createContainer(c, d);f = c._reactRootContainer = g;Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }return Z.getPublicRootInstance(f);
}function Qg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Ng(b) ? void 0 : E("200");return pf(a, b, null, c);
}
function Rg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}Rg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};Rg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};
var Sg = { createPortal: Qg, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;if (b) return Z.findHostInstance(b);"function" === typeof a.render ? E("188") : E("213", Object.keys(a));
  }, hydrate: function hydrate(a, b, c) {
    return Pg(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Pg(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? E("38") : void 0;return Pg(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Ng(a) ? void 0 : E("40");return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Pg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: Qg, unstable_batchedUpdates: tc, unstable_deferredUpdates: Z.deferredUpdates, flushSync: Z.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: mb, EventPluginRegistry: Va, EventPropagators: Cb, ReactControlledComponent: qc, ReactDOMComponentTree: sb, ReactDOMEventListener: xd } };
Z.injectIntoDevTools({ findFiberByHostInstance: pb, bundleType: 0, version: "16.2.0", rendererPackageName: "react-dom" });var Tg = Object.freeze({ default: Sg }),
    Ug = Tg && Sg || Tg;module.exports = Ug["default"] ? Ug["default"] : Ug;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(78);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(1);var invariant=__webpack_require__(12);var warning=__webpack_require__(16);var ExecutionEnvironment=__webpack_require__(38);var _assign=__webpack_require__(11);var emptyFunction=__webpack_require__(6);var EventListener=__webpack_require__(39);var getActiveElement=__webpack_require__(40);var shallowEqual=__webpack_require__(41);var containsNode=__webpack_require__(42);var focusNode=__webpack_require__(43);var emptyObject=__webpack_require__(15);var checkPropTypes=__webpack_require__(20);var hyphenateStyleName=__webpack_require__(80);var camelizeStyleName=__webpack_require__(82);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
autoFocus:HAS_BOOLEAN_VALUE,autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_OVERLOADED_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode$$1=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback...)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new *//* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and named imports.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;// Invoke setState callback an extra time to help detect side-effects.
if(debugRenderPhaseSideEffects){updateFn.call(instance,prevState,props);}return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.shouldComponentUpdate(newProps,newState,newContext);}{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){warning(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){warning(_typeof(workInProgress.type.childContextTypes)==='object','%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',getComponentName(workInProgress));}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillMount();}if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillReceiveProps(newProps,newContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillUpdate(newProps,newState,newContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol['for'];var REACT_ELEMENT_TYPE=hasSymbol?Symbol['for']('react.element'):0xeac7;var REACT_CALL_TYPE=hasSymbol?Symbol['for']('react.call'):0xeac8;var REACT_RETURN_TYPE=hasSymbol?Symbol['for']('react.return'):0xeac9;var REACT_PORTAL_TYPE=hasSymbol?Symbol['for']('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol['for']('react.fragment'):0xeacb;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted  the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work  work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,cancelDeferredCallback=config.cancelDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary - we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
var suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function checkRootNeedsClearing(root,fiber,expirationTime){if(!isWorking&&root===nextRoot&&expirationTime<nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;checkRootNeedsClearing(root,fiber,expirationTime);requestWork(root,expirationTime);checkRootNeedsClearing(root,fiber,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=-1;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
cancelDeferredCallback(callbackID);}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.
var currentMs=now()-startTime;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else{scheduleCallbackWithExpiration(expirationTime);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadline.
findHighestPriorityRoot();if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();stopRequestCallbackTimer(didExpire);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=-1;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.2.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;var cIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){return setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});};cIC=function cIC(timeoutID){clearTimeout(timeoutID);};}else if(typeof requestIdleCallback!=='function'||typeof cancelIdleCallback!=='function'){// Polyfill requestIdleCallback and cancelIdleCallback
var scheduledRICCallback=null;var isIdleScheduled=false;var timeoutTime=-1;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
var remaining=frameDeadline-performance.now();return remaining>0?remaining:0;}};}else{frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// Fallback to Date.now()
var remaining=frameDeadline-Date.now();return remaining>0?remaining:0;}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var currentTime=now();if(frameDeadline-currentTime<=0){// There's no time left in this idle period. Check if the callback has
// a timeout and whether it's been exceeded.
if(timeoutTime!==-1&&timeoutTime<=currentTime){// Exceeded the timeout. Invoke the callback even though there's no
// time left.
frameDeadlineObject.didTimeout=true;}else{// No timeout.
if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}// Exit without invoking the callback.
return;}}else{// There's still time left in this idle period.
frameDeadlineObject.didTimeout=false;}timeoutTime=-1;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback,options){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now()+options.timeout;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};cIC=function cIC(){scheduledRICCallback=null;isIdleScheduled=false;timeoutTime=-1;};}else{rIC=window.requestIdleCallback;cIC=window.cancelIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,cancelDeferredCallback:cIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(81);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(83);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(85);

var _reactRedux = __webpack_require__(28);

var _Show = __webpack_require__(160);

var _Show2 = _interopRequireDefault(_Show);

var _Home = __webpack_require__(161);

var _Home2 = _interopRequireDefault(_Home);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_React$Component) {
  _inherits(App, _React$Component);

  _createClass(App, [{
    key: 'styles',
    value: function styles() {
      return {
        navlink: {
          color: 'white'
        }
      };
    }
  }]);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.goHome = _this.goHome.bind(_this);

    return _this;
  }

  _createClass(App, [{
    key: 'goHome',
    value: function goHome() {
      this.context.router.push('/Show');
    }
  }, {
    key: 'render',
    value: function render() {
      var styles = this.styles();
      return _react2.default.createElement(
        _reactRouterDom.BrowserRouter,
        null,
        _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(
              'span',
              { 'class': 'btn btn-primary' },
              _react2.default.createElement(
                _reactRouterDom.NavLink,
                { style: styles.navlink, to: '/' },
                'Home'
              )
            ),
            _react2.default.createElement(
              'span',
              { 'class': 'btn btn-primary' },
              _react2.default.createElement(
                _reactRouterDom.NavLink,
                { style: styles.navlink, to: '/Show' },
                'Show'
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'content' },
            _react2.default.createElement(_reactRouterDom.Route, { exact: true, path: '/', component: _Home2.default }),
            _react2.default.createElement(_reactRouterDom.Route, { path: '/Show', component: _Show2.default })
          )
        )
      );
    }
  }]);

  return App;
}(_react2.default.Component);

exports.default = App;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = undefined;

var _BrowserRouter2 = __webpack_require__(86);

var _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2);

var _HashRouter2 = __webpack_require__(90);

var _HashRouter3 = _interopRequireDefault(_HashRouter2);

var _Link2 = __webpack_require__(47);

var _Link3 = _interopRequireDefault(_Link2);

var _MemoryRouter2 = __webpack_require__(92);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _NavLink2 = __webpack_require__(95);

var _NavLink3 = _interopRequireDefault(_NavLink2);

var _Prompt2 = __webpack_require__(98);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(100);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(48);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(24);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(106);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(108);

var _Switch3 = _interopRequireDefault(_Switch2);

var _matchPath2 = __webpack_require__(110);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(111);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BrowserRouter = _BrowserRouter3.default;
exports.HashRouter = _HashRouter3.default;
exports.Link = _Link3.default;
exports.MemoryRouter = _MemoryRouter3.default;
exports.NavLink = _NavLink3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createBrowserHistory = __webpack_require__(89);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _Router = __webpack_require__(24);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createBrowserHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(_react2.default.Component);

BrowserRouter.propTypes = {
  basename: _propTypes2.default.string,
  forceRefresh: _propTypes2.default.bool,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = BrowserRouter;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(12);
var warning = __webpack_require__(16);
var assign = __webpack_require__(11);

var ReactPropTypesSecret = __webpack_require__(21);
var checkPropTypes = __webpack_require__(20);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(12);
var ReactPropTypesSecret = __webpack_require__(21);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(22);

var _PathUtils = __webpack_require__(13);

var _createTransitionManager = __webpack_require__(23);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(46);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createHashHistory = __webpack_require__(91);

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _Router = __webpack_require__(24);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createHashHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(_react2.default.Component);

HashRouter.propTypes = {
  basename: _propTypes2.default.string,
  getUserConfirmation: _propTypes2.default.func,
  hashType: _propTypes2.default.oneOf(['hashbang', 'noslash', 'slash']),
  children: _propTypes2.default.node
};

exports.default = HashRouter;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(22);

var _PathUtils = __webpack_require__(13);

var _createTransitionManager = __webpack_require__(23);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(46);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MemoryRouter = __webpack_require__(93);

var _MemoryRouter2 = _interopRequireDefault(_MemoryRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _MemoryRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createMemoryHistory = __webpack_require__(94);

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

var _Router = __webpack_require__(25);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createMemoryHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(_react2.default.Component);

MemoryRouter.propTypes = {
  initialEntries: _propTypes2.default.array,
  initialIndex: _propTypes2.default.number,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = MemoryRouter;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(13);

var _LocationUtils = __webpack_require__(22);

var _createTransitionManager = __webpack_require__(23);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Route = __webpack_require__(48);

var _Route2 = _interopRequireDefault(_Route);

var _Link = __webpack_require__(47);

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return _react2.default.createElement(_Route2.default, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return _react2.default.createElement(_Link2.default, _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: _Link2.default.propTypes.to,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  location: _propTypes2.default.object,
  activeClassName: _propTypes2.default.string,
  className: _propTypes2.default.string,
  activeStyle: _propTypes2.default.object,
  style: _propTypes2.default.object,
  isActive: _propTypes2.default.func,
  ariaCurrent: _propTypes2.default.oneOf(['page', 'step', 'location', 'true'])
};

NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

exports.default = NavLink;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isarray = __webpack_require__(97);

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;
module.exports.parse = parse;
module.exports.compile = compile;
module.exports.tokensToFunction = tokensToFunction;
module.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Prompt = __webpack_require__(99);

var _Prompt2 = _interopRequireDefault(_Prompt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Prompt2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(_react2.default.Component);

Prompt.propTypes = {
  when: _propTypes2.default.bool,
  message: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      block: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Prompt;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Redirect = __webpack_require__(101);

var _Redirect2 = _interopRequireDefault(_Redirect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Redirect2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _history = __webpack_require__(102);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = (0, _history.createLocation)(prevProps.to);
    var nextTo = (0, _history.createLocation)(this.props.to);

    if ((0, _history.locationsAreEqual)(prevTo, nextTo)) {
      (0, _warning2.default)(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(_react2.default.Component);

Redirect.propTypes = {
  push: _propTypes2.default.bool,
  from: _propTypes2.default.string,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired
    }).isRequired,
    staticContext: _propTypes2.default.object
  }).isRequired
};

exports.default = Redirect;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.locationsAreEqual = exports.createLocation = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = undefined;

var _LocationUtils = __webpack_require__(17);

Object.defineProperty(exports, 'createLocation', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.createLocation;
  }
});
Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _PathUtils = __webpack_require__(14);

Object.defineProperty(exports, 'parsePath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.parsePath;
  }
});
Object.defineProperty(exports, 'createPath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.createPath;
  }
});

var _createBrowserHistory2 = __webpack_require__(103);

var _createBrowserHistory3 = _interopRequireDefault(_createBrowserHistory2);

var _createHashHistory2 = __webpack_require__(104);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(105);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createBrowserHistory = _createBrowserHistory3.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(17);

var _PathUtils = __webpack_require__(14);

var _createTransitionManager = __webpack_require__(27);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(17);

var _PathUtils = __webpack_require__(14);

var _createTransitionManager = __webpack_require__(27);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(50);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(14);

var _LocationUtils = __webpack_require__(17);

var _createTransitionManager = __webpack_require__(27);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StaticRouter = __webpack_require__(107);

var _StaticRouter2 = _interopRequireDefault(_StaticRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _StaticRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PathUtils = __webpack_require__(13);

var _Router = __webpack_require__(25);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: (0, _PathUtils.addLeadingSlash)(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = (0, _PathUtils.addLeadingSlash)(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createLocation = function createLocation(location) {
  return typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : normalizeLocation(location);
};

var createURL = function createURL(location) {
  return typeof location === 'string' ? location : (0, _PathUtils.createPath)(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    (0, _invariant2.default)(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return (0, _PathUtils.addLeadingSlash)(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler('go'),
      goBack: staticHandler('goBack'),
      goForward: staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return _react2.default.createElement(_Router2.default, _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(_react2.default.Component);

StaticRouter.propTypes = {
  basename: _propTypes2.default.string,
  context: _propTypes2.default.object.isRequired,
  location: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};
StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = StaticRouter;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Switch = __webpack_require__(109);

var _Switch2 = _interopRequireDefault(_Switch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Switch2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(2);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(4);

var _invariant2 = _interopRequireDefault(_invariant);

var _matchPath = __webpack_require__(26);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    _react2.default.Children.forEach(children, function (element) {
      if (!_react2.default.isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? (0, _matchPath2.default)(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? _react2.default.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(_react2.default.Component);

Switch.contextTypes = {
  router: _propTypes2.default.shape({
    route: _propTypes2.default.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: _propTypes2.default.node,
  location: _propTypes2.default.object
};

exports.default = Switch;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _matchPath = __webpack_require__(26);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _matchPath2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _withRouter = __webpack_require__(112);

var _withRouter2 = _interopRequireDefault(_withRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _withRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(113);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _Route = __webpack_require__(49);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);

    return _react2.default.createElement(_Route2.default, { render: function render(routeComponentProps) {
        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: _propTypes2.default.func
  };

  return (0, _hoistNonReactStatics2.default)(C, Component);
};

exports.default = withRouter;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.createProvider = createProvider;

var _react = __webpack_require__(51);

var _propTypes = __webpack_require__(61);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PropTypes = __webpack_require__(63);

var _warning = __webpack_require__(36);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return _react.Children.only(this.props.children);
    };

    return Provider;
  }(_react.Component);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: _PropTypes.storeShape.isRequired,
    children: _propTypes2.default.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);

  return Provider;
}

exports.default = createProvider();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var ReactChildren = __webpack_require__(116);
var ReactComponent = __webpack_require__(29);
var ReactPureComponent = __webpack_require__(120);
var ReactClass = __webpack_require__(121);
var ReactDOMFactories = __webpack_require__(122);
var ReactElement = __webpack_require__(9);
var ReactPropTypes = __webpack_require__(125);
var ReactVersion = __webpack_require__(129);

var onlyChild = __webpack_require__(130);
var warning = __webpack_require__(5);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var canDefineProperty = __webpack_require__(19);
  var ReactElementValidator = __webpack_require__(56);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function __spread() {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function createMixin(mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

// TODO: Fix tests so that this deprecation warning doesn't cause failures.
if (process.env.NODE_ENV !== 'production') {
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function get() {
        process.env.NODE_ENV !== 'production' ? warning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated. Use ' + 'the prop-types package from npm instead.') : void 0;
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });
  }
}

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(117);
var ReactElement = __webpack_require__(9);

var emptyFunction = __webpack_require__(52);
var traverseAllChildren = __webpack_require__(118);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(7);

var invariant = __webpack_require__(8);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(7);

var ReactCurrentOwner = __webpack_require__(18);
var REACT_ELEMENT_TYPE = __webpack_require__(53);

var getIteratorFn = __webpack_require__(54);
var invariant = __webpack_require__(8);
var KeyEscapeUtils = __webpack_require__(119);
var warning = __webpack_require__(5);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(10);

var ReactComponent = __webpack_require__(29);
var ReactNoopUpdateQueue = __webpack_require__(30);

var emptyObject = __webpack_require__(31);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(7),
    _assign = __webpack_require__(10);

var ReactComponent = __webpack_require__(29);
var ReactElement = __webpack_require__(9);
var ReactPropTypeLocationNames = __webpack_require__(55);
var ReactNoopUpdateQueue = __webpack_require__(30);

var emptyObject = __webpack_require__(31);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(5);

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */

var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function displayName(Constructor, _displayName) {
    Constructor.displayName = _displayName;
  },
  mixins: function mixins(Constructor, _mixins) {
    if (_mixins) {
      for (var i = 0; i < _mixins.length; i++) {
        mixSpecIntoComponent(Constructor, _mixins[i]);
      }
    }
  },
  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
  },
  contextTypes: function contextTypes(Constructor, _contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
    } else {
      Constructor.getDefaultProps = _getDefaultProps;
    }
  },
  propTypes: function propTypes(Constructor, _propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, _propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
  },
  statics: function statics(Constructor, _statics) {
    mixStaticSpecIntoComponent(Constructor, _statics);
  },
  autobind: function autobind() {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (process.env.NODE_ENV !== 'production') {
      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function replaceState(newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted() {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function ReactClassComponent() {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

var didWarnDeprecated = false;

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function createClass(spec) {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(didWarnDeprecated, '%s: React.createClass is deprecated and will be removed in version 16. ' + 'Use plain JavaScript classes instead. If you\'re not yet ready to ' + 'migrate, create-react-class is available on npm as a ' + 'drop-in replacement.', spec && spec.displayName || 'A Component') : void 0;
      didWarnDeprecated = true;
    }

    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function injectMixin(mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(9);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(56);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(7);

var ReactPropTypeLocationNames = __webpack_require__(55);
var ReactPropTypesSecret = __webpack_require__(124);

var invariant = __webpack_require__(8);
var warning = __webpack_require__(5);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(32);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(32);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(9),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(126);

module.exports = factory(isValidElement);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.

var factory = __webpack_require__(127);
module.exports = function (isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(57);
var invariant = __webpack_require__(58);
var warning = __webpack_require__(59);
var assign = __webpack_require__(10);

var ReactPropTypesSecret = __webpack_require__(60);
var checkPropTypes = __webpack_require__(128);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(58);
  var warning = __webpack_require__(59);
  var ReactPropTypesSecret = __webpack_require__(60);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.5.3';

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(7);

var ReactElement = __webpack_require__(9);

var invariant = __webpack_require__(8);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(33);
var invariant = __webpack_require__(34);
var warning = __webpack_require__(62);
var assign = __webpack_require__(10);

var ReactPropTypesSecret = __webpack_require__(35);
var checkPropTypes = __webpack_require__(132);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(34);
  var warning = __webpack_require__(62);
  var ReactPropTypesSecret = __webpack_require__(35);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(33);
var invariant = __webpack_require__(34);
var ReactPropTypesSecret = __webpack_require__(35);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();

exports.default = Subscription;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.createConnect = createConnect;

var _connectAdvanced = __webpack_require__(64);

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _shallowEqual = __webpack_require__(138);

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _mapDispatchToProps = __webpack_require__(139);

var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

var _mapStateToProps = __webpack_require__(156);

var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

var _mergeProps = __webpack_require__(157);

var _mergeProps2 = _interopRequireDefault(_mergeProps);

var _selectorFactory = __webpack_require__(158);

var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

exports.default = createConnect();

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

var _redux = __webpack_require__(140);

var _wrapMapToProps = __webpack_require__(70);

function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && (typeof mapDispatchToProps === 'undefined' ? 'undefined' : _typeof(mapDispatchToProps)) === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
  }) : undefined;
}

exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = __webpack_require__(65);

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = __webpack_require__(153);

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = __webpack_require__(154);

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = __webpack_require__(155);

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = __webpack_require__(69);

var _compose2 = _interopRequireDefault(_compose);

var _warning = __webpack_require__(68);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2.default)('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2.default;
exports.combineReducers = _combineReducers2.default;
exports.bindActionCreators = _bindActionCreators2.default;
exports.applyMiddleware = _applyMiddleware2.default;
exports.compose = _compose2.default;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Symbol2 = __webpack_require__(66);

var _Symbol3 = _interopRequireDefault(_Symbol2);

var _getRawTag = __webpack_require__(144);

var _getRawTag2 = _interopRequireDefault(_getRawTag);

var _objectToString = __webpack_require__(145);

var _objectToString2 = _interopRequireDefault(_objectToString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol3.default ? _Symbol3.default.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? (0, _getRawTag2.default)(value) : (0, _objectToString2.default)(value);
}

exports.default = baseGetTag;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _freeGlobal = __webpack_require__(143);

var _freeGlobal2 = _interopRequireDefault(_freeGlobal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal2.default || freeSelf || Function('return this')();

exports.default = root;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

exports.default = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Symbol2 = __webpack_require__(66);

var _Symbol3 = _interopRequireDefault(_Symbol2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol3.default ? _Symbol3.default.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

exports.default = getRawTag;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

exports.default = objectToString;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _overArg = __webpack_require__(147);

var _overArg2 = _interopRequireDefault(_overArg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var getPrototype = (0, _overArg2.default)(Object.getPrototypeOf, Object);

exports.default = getPrototype;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

exports.default = overArg;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

exports.default = isObjectLike;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(150);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(152);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var root; /* global window */

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67), __webpack_require__(151)(module)))

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = combineReducers;

var _createStore = __webpack_require__(65);

var _isPlainObject = __webpack_require__(37);

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = __webpack_require__(68);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2.default)(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2.default)('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  if (process.env.NODE_ENV !== 'production') {
    var unexpectedKeyCache = {};
  }

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2.default)(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyMiddleware;

var _compose = __webpack_require__(69);

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2.default.apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

var _wrapMapToProps = __webpack_require__(70);

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
    return {};
  }) : undefined;
}

exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultMergeProps = defaultMergeProps;
exports.wrapMergePropsFunc = wrapMergePropsFunc;
exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

var _verifyPlainObject = __webpack_require__(71);

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
exports.default = finalPropsSelectorFactory;

var _verifySubselectors = __webpack_require__(159);

var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = verifySubselectors;

var _warning = __webpack_require__(36);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactRedux = __webpack_require__(28);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Show = function (_Component) {
   _inherits(Show, _Component);

   function Show() {
      _classCallCheck(this, Show);

      return _possibleConstructorReturn(this, (Show.__proto__ || Object.getPrototypeOf(Show)).apply(this, arguments));
   }

   _createClass(Show, [{
      key: 'render',
      value: function render() {
         var UserName = this.props.params.UserName;

         return _react2.default.createElement(
            'div',
            null,
            _react2.default.createElement(
               'h1',
               null,
               Usname,
               ' '
            )
         );
      }
   }]);

   return Show;
}(_react.Component);

exports.default = Show;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactRedux = __webpack_require__(28);

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var API = 'https://api.github.com/users';

var Home = function (_Component) {
  _inherits(Home, _Component);

  function Home(props) {
    _classCallCheck(this, Home);

    var _this = _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).call(this, props));

    _this.state = {
      UserName: "",
      name: "",
      repos: "",
      followers: "",
      following: ""

    };

    return _this;
  }

  _createClass(Home, [{
    key: 'fetchProfile',
    value: function fetchProfile(username) {
      var _this2 = this;

      alert("Hi");

      var url = API + '/' + username;
      fetch(url).then(function (res) {
        return res.json();
      }).then(function (data) {
        _this2.setState({
          UserName: data.login,
          name: data.name,

          repos: data.public_repos,
          followers: data.followers,
          following: data.following,
          notFound: data.message
        });
      }).catch(function (error) {
        return console.log('Oops! . There Is A Problem');
      });
    }
  }, {
    key: 'Hi',
    value: function Hi() {
      this.fetchProfile(this.state.UserName);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this,
          _React$createElement;

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'form',
          {
            onSubmit: function onSubmit(e) {
              alert("Values Added");_this3.Hi();
            } },
          _react2.default.createElement(
            'div',
            { 'class': 'form-row' },
            _react2.default.createElement(
              'div',
              { 'class': 'col-12  col-md-5 mb-2 mb-md-0' },
              _react2.default.createElement('input', (_React$createElement = {
                required: 'required',
                name: 'firstname',
                'class': 'form-control form-control-lg ',
                placeholder: 'UserName'
              }, _defineProperty(_React$createElement, 'required', true), _defineProperty(_React$createElement, 'pattern', '[a-zA-Z]+'), _defineProperty(_React$createElement, 'value', this.state.UserName), _defineProperty(_React$createElement, 'onChange', function onChange(e) {
                return _this3.setState({ UserName: e.target.value });
              }), _React$createElement))
            )
          )
        ),
        _react2.default.createElement(
          'h1',
          null,
          'Hi kashif'
        )
      );
    }
  }]);

  return Home;
}(_react.Component);

exports.default = Home;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(163);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(165)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./application.scss", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./application.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(164)(false);
// imports


// module
exports.push([module.i, "body {\n  background: #ACCEEC;\n  color: #005CC5; }\n", ""]);

// exports


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(166);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2Y3ZDI5YzRlMTIxNjBhZTU4YmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvRE9NVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jb21wb3NlLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9BcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzIiwid2VicGFjazovLy8vaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvU2hvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvSG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L3Njc3MvYXBwbGljYXRpb24uc2Nzcz80OTU4Iiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvc2Nzcy9hcHBsaWNhdGlvbi5zY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIk5PREVfRU5WIiwicmVxdWlyZSIsIndhcm5pbmciLCJjb25kaXRpb24iLCJmb3JtYXQiLCJrZXkiLCJ1bmRlZmluZWQiLCJ0ZXN0IiwiYXJnSW5kZXgiLCJtZXNzYWdlIiwicmVwbGFjZSIsImNvbnNvbGUiLCJlcnJvciIsIngiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsImludmFyaWFudCIsImEiLCJiIiwiYyIsImQiLCJmIiwiZnJhbWVzVG9Qb3AiLCJlbXB0eUZ1bmN0aW9uIiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJpbmRleE9mIiwiX2xlbjIiLCJfa2V5MiIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsInJlYWN0UHJvZEludmFyaWFudCIsImNvZGUiLCJhcmdDb3VudCIsImFyZ0lkeCIsImVuY29kZVVSSUNvbXBvbmVudCIsInZhbGlkYXRlRm9ybWF0IiwiX2Fzc2lnbiIsIlJlYWN0Q3VycmVudE93bmVyIiwiY2FuRGVmaW5lUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsIlJFU0VSVkVEX1BST1BTIiwicmVmIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJwcm9wcyIsImRpc3BsYXlOYW1lIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsInR5cGUiLCJzZWxmIiwic291cmNlIiwib3duZXIiLCJlbGVtZW50IiwiX293bmVyIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJ2YWxpZGF0ZWQiLCJfc2VsZiIsIl9zb3VyY2UiLCJmcmVlemUiLCJjcmVhdGVFbGVtZW50IiwiY2hpbGRyZW4iLCJwcm9wTmFtZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImN1cnJlbnQiLCJjcmVhdGVGYWN0b3J5IiwiZmFjdG9yeSIsImJpbmQiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsImNsb25lRWxlbWVudCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsInRhcmdldCIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwiX19lc01vZHVsZSIsImFkZExlYWRpbmdTbGFzaCIsInBhdGgiLCJjaGFyQXQiLCJzdHJpcExlYWRpbmdTbGFzaCIsInN1YnN0ciIsImhhc0Jhc2VuYW1lIiwicHJlZml4IiwiUmVnRXhwIiwic3RyaXBCYXNlbmFtZSIsInN0cmlwVHJhaWxpbmdTbGFzaCIsInNsaWNlIiwicGFyc2VQYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiaGFzaEluZGV4Iiwic2VhcmNoSW5kZXgiLCJjcmVhdGVQYXRoIiwibG9jYXRpb24iLCJlbXB0eU9iamVjdCIsIl9leHRlbmRzIiwiY3JlYXRlTG9jYXRpb24iLCJzdGF0ZSIsImN1cnJlbnRMb2NhdGlvbiIsImRlY29kZVVSSSIsIlVSSUVycm9yIiwibG9jYXRpb25zQXJlRXF1YWwiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwiY29tcG9uZW50TmFtZSIsImdldFN0YWNrIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJzdGFjayIsIl9yZXNvbHZlUGF0aG5hbWUiLCJfcmVzb2x2ZVBhdGhuYW1lMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfdmFsdWVFcXVhbCIsIl92YWx1ZUVxdWFsMiIsIl9QYXRoVXRpbHMiLCJvYmoiLCJkZWZhdWx0IiwiX3dhcm5pbmciLCJfd2FybmluZzIiLCJjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsInByb21wdCIsInNldFByb21wdCIsIm5leHRQcm9tcHQiLCJjb25maXJtVHJhbnNpdGlvblRvIiwiYWN0aW9uIiwiZ2V0VXNlckNvbmZpcm1hdGlvbiIsImNhbGxiYWNrIiwicmVzdWx0IiwiYXBwZW5kTGlzdGVuZXIiLCJmbiIsImlzQWN0aXZlIiwibGlzdGVuZXIiLCJmaWx0ZXIiLCJpdGVtIiwibm90aWZ5TGlzdGVuZXJzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiUm91dGVyIiwiX1JlYWN0JENvbXBvbmVudCIsIl90ZW1wIiwiX3RoaXMiLCJfcmV0IiwibWF0Y2giLCJjb21wdXRlTWF0Y2giLCJoaXN0b3J5IiwiZ2V0Q2hpbGRDb250ZXh0Iiwicm91dGVyIiwiY29udGV4dCIsInJvdXRlIiwidXJsIiwicGFyYW1zIiwiaXNFeGFjdCIsImNvbXBvbmVudFdpbGxNb3VudCIsIl90aGlzMiIsIl9wcm9wcyIsIkNoaWxkcmVuIiwiY291bnQiLCJ1bmxpc3RlbiIsImxpc3RlbiIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5leHRQcm9wcyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwib25seSIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsImlzUmVxdWlyZWQiLCJub2RlIiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwYXR0ZXJuQ2FjaGUiLCJjYWNoZUxpbWl0IiwiY2FjaGVDb3VudCIsImNvbXBpbGVQYXRoIiwicGF0dGVybiIsIm9wdGlvbnMiLCJjYWNoZUtleSIsImVuZCIsInN0cmljdCIsInNlbnNpdGl2ZSIsImNhY2hlIiwicmUiLCJjb21waWxlZFBhdHRlcm4iLCJtYXRjaFBhdGgiLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBhdGgiLCJfb3B0aW9ucyRleGFjdCIsImV4YWN0IiwiX29wdGlvbnMkc3RyaWN0IiwiX29wdGlvbnMkc2Vuc2l0aXZlIiwiX2NvbXBpbGVQYXRoIiwiZXhlYyIsInJlZHVjZSIsIm1lbW8iLCJpbmRleCIsIlByb3ZpZGVyIiwiY3JlYXRlUHJvdmlkZXIiLCJjb25uZWN0QWR2YW5jZWQiLCJjb25uZWN0IiwiX3Byb2RJbnZhcmlhbnQiLCJSZWFjdE5vb3BVcGRhdGVRdWV1ZSIsIlJlYWN0Q29tcG9uZW50IiwidXBkYXRlciIsInJlZnMiLCJpc1JlYWN0Q29tcG9uZW50IiwicGFydGlhbFN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiZW5xdWV1ZUNhbGxiYWNrIiwiZm9yY2VVcGRhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJkZXByZWNhdGVkQVBJcyIsImlzTW91bnRlZCIsInJlcGxhY2VTdGF0ZSIsImRlZmluZURlcHJlY2F0aW9uV2FybmluZyIsIm1ldGhvZE5hbWUiLCJpbmZvIiwiZm5OYW1lIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsImlzTmF0aXZlIiwiZnVuY1RvU3RyaW5nIiwiRnVuY3Rpb24iLCJ0b1N0cmluZyIsInJlSXNOYXRpdmUiLCJjYW5Vc2VDb2xsZWN0aW9ucyIsIk1hcCIsIlNldCIsInNldEl0ZW0iLCJnZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEl0ZW1JRHMiLCJhZGRSb290IiwicmVtb3ZlUm9vdCIsImdldFJvb3RJRHMiLCJpdGVtTWFwIiwicm9vdElEU2V0IiwiaWQiLCJzZXQiLCJhZGQiLCJpdGVtQnlLZXkiLCJyb290QnlLZXkiLCJnZXRLZXlGcm9tSUQiLCJnZXRJREZyb21LZXkiLCJwYXJzZUludCIsInVubW91bnRlZElEcyIsInB1cmdlRGVlcCIsImNoaWxkSURzIiwiZGVzY3JpYmVDb21wb25lbnRGcmFtZSIsIm93bmVyTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldERpc3BsYXlOYW1lIiwiZGVzY3JpYmVJRCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJnZXRFbGVtZW50Iiwib3duZXJJRCIsImdldE93bmVySUQiLCJvblNldENoaWxkcmVuIiwibmV4dENoaWxkSURzIiwibmV4dENoaWxkSUQiLCJuZXh0Q2hpbGQiLCJwYXJlbnRJRCIsIm9uQmVmb3JlTW91bnRDb21wb25lbnQiLCJ0ZXh0IiwidXBkYXRlQ291bnQiLCJvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCIsIm9uTW91bnRDb21wb25lbnQiLCJpc1Jvb3QiLCJvblVwZGF0ZUNvbXBvbmVudCIsIm9uVW5tb3VudENvbXBvbmVudCIsInB1cmdlVW5tb3VudGVkQ29tcG9uZW50cyIsIl9wcmV2ZW50UHVyZ2luZyIsImdldEN1cnJlbnRTdGFja0FkZGVuZHVtIiwidG9wRWxlbWVudCIsImdldE5hbWUiLCJjdXJyZW50T3duZXIiLCJfZGVidWdJRCIsImdldFN0YWNrQWRkZW5kdW1CeUlEIiwiZ2V0UGFyZW50SUQiLCJnZXRDaGlsZElEcyIsImdldFNvdXJjZSIsImdldFRleHQiLCJnZXRVcGRhdGVDb3VudCIsImdldFJlZ2lzdGVyZWRJRHMiLCJvYmplY3RUYWciLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwicHJvdG8iLCJDdG9yIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJFeGVjdXRpb25FbnZpcm9ubWVudCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsIkV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJjYXB0dXJlIiwicmVnaXN0ZXJEZWZhdWx0IiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiaXMiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiaXNUZXh0Tm9kZSIsImNvbnRhaW5zTm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJpc0Fic29sdXRlIiwic3BsaWNlT25lIiwibGlzdCIsImsiLCJwb3AiLCJyZXNvbHZlUGF0aG5hbWUiLCJ0b1BhcnRzIiwiZnJvbVBhcnRzIiwiaXNUb0FicyIsImlzRnJvbUFicyIsIm11c3RFbmRBYnMiLCJoYXNUcmFpbGluZ1NsYXNoIiwibGFzdCIsInVwIiwicGFydCIsInVuc2hpZnQiLCJfdHlwZW9mIiwiaXRlcmF0b3IiLCJ2YWx1ZUVxdWFsIiwiaXNBcnJheSIsImV2ZXJ5IiwiYVR5cGUiLCJiVHlwZSIsImFWYWx1ZSIsInZhbHVlT2YiLCJiVmFsdWUiLCJhS2V5cyIsImJLZXlzIiwiZXZlbnQiLCJnZXRDb25maXJtYXRpb24iLCJjb25maXJtIiwic3VwcG9ydHNIaXN0b3J5IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlIiwic3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2giLCJpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiaXNNb2RpZmllZEV2ZW50IiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIkxpbmsiLCJoYW5kbGVDbGljayIsIm9uQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiYnV0dG9uIiwicHJldmVudERlZmF1bHQiLCJfdGhpcyRwcm9wcyIsImlubmVyUmVmIiwiaHJlZiIsImNyZWF0ZUhyZWYiLCJmdW5jIiwic3RyaW5nIiwiYm9vbCIsIm9uZU9mVHlwZSIsInNoYXBlIiwiaXNFbXB0eUNoaWxkcmVuIiwiUm91dGUiLCJfcmVmIiwiY29tcHV0ZWRNYXRjaCIsImNvbXBvbmVudCIsIm5leHRDb250ZXh0IiwiX2NvbnRleHQkcm91dGVyIiwic3RhdGljQ29udGV4dCIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJwcm9wIiwiY2hpbGRDb250ZXh0IiwiY2hlY2tSZWFjdFR5cGVTcGVjIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwibWVtb2l6ZXIiLCJ1bmlxdWVLZXkiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwiY2hpbGQiLCJlbnRyaWVzIiwic3RlcCIsIm5leHQiLCJkb25lIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiUmVhY3RFbGVtZW50VmFsaWRhdG9yIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInZhbGlkYXRlZEZhY3RvcnkiLCJzdWJzY3JpcHRpb25TaGFwZSIsInRyeVN1YnNjcmliZSIsInRyeVVuc3Vic2NyaWJlIiwibm90aWZ5TmVzdGVkU3VicyIsImlzU3Vic2NyaWJlZCIsInN0b3JlU2hhcGUiLCJzdWJzY3JpYmUiLCJkaXNwYXRjaCIsImdldFN0YXRlIiwiaG90UmVsb2FkaW5nVmVyc2lvbiIsImR1bW15U3RhdGUiLCJtYWtlU2VsZWN0b3JTdGF0ZWZ1bCIsInNvdXJjZVNlbGVjdG9yIiwic3RvcmUiLCJzZWxlY3RvciIsInJ1bkNvbXBvbmVudFNlbGVjdG9yIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2VsZWN0b3JGYWN0b3J5IiwiX2NvbnRleHRUeXBlcyIsIl9jaGlsZENvbnRleHRUeXBlcyIsIl9yZWYkZ2V0RGlzcGxheU5hbWUiLCJfcmVmJG1ldGhvZE5hbWUiLCJfcmVmJHJlbmRlckNvdW50UHJvcCIsInJlbmRlckNvdW50UHJvcCIsIl9yZWYkc2hvdWxkSGFuZGxlU3RhdCIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsIl9yZWYkc3RvcmVLZXkiLCJzdG9yZUtleSIsIl9yZWYkd2l0aFJlZiIsIndpdGhSZWYiLCJjb25uZWN0T3B0aW9ucyIsInN1YnNjcmlwdGlvbktleSIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJKU09OIiwic3RyaW5naWZ5Iiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdCIsIl9Db21wb25lbnQiLCJyZW5kZXJDb3VudCIsInByb3BzTW9kZSIsIkJvb2xlYW4iLCJzZXRXcmFwcGVkSW5zdGFuY2UiLCJpbml0U2VsZWN0b3IiLCJpbml0U3Vic2NyaXB0aW9uIiwiX3JlZjIiLCJzdWJzY3JpcHRpb24iLCJjb21wb25lbnREaWRNb3VudCIsImdldFdyYXBwZWRJbnN0YW5jZSIsIndyYXBwZWRJbnN0YW5jZSIsInBhcmVudFN1YiIsIm9uU3RhdGVDaGFuZ2UiLCJjb21wb25lbnREaWRVcGRhdGUiLCJub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUiLCJhZGRFeHRyYVByb3BzIiwid2l0aEV4dHJhcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJvbGRMaXN0ZW5lcnMiLCJjcmVhdGVTdG9yZSIsIkFjdGlvblR5cGVzIiwiSU5JVCIsInJlZHVjZXIiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VyIiwiY3VycmVudFJlZHVjZXIiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50TGlzdGVuZXJzIiwibmV4dExpc3RlbmVycyIsImlzRGlzcGF0Y2hpbmciLCJlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzIiwidW5zdWJzY3JpYmUiLCJzcGxpY2UiLCJyZXBsYWNlUmVkdWNlciIsIm5leHRSZWR1Y2VyIiwib2JzZXJ2YWJsZSIsIm91dGVyU3Vic2NyaWJlIiwib2JzZXJ2ZXIiLCJvYnNlcnZlU3RhdGUiLCJnIiwiZXZhbCIsImNvbXBvc2UiLCJmdW5jcyIsInJlc3QiLCJyZWR1Y2VSaWdodCIsImNvbXBvc2VkIiwid3JhcE1hcFRvUHJvcHNDb25zdGFudCIsImdldERlcGVuZHNPbk93blByb3BzIiwid3JhcE1hcFRvUHJvcHNGdW5jIiwiZ2V0Q29uc3RhbnQiLCJpbml0Q29uc3RhbnRTZWxlY3RvciIsImNvbnN0YW50IiwiY29uc3RhbnRTZWxlY3RvciIsImRlcGVuZHNPbk93blByb3BzIiwibWFwVG9Qcm9wcyIsImluaXRQcm94eVNlbGVjdG9yIiwicHJveHkiLCJtYXBUb1Byb3BzUHJveHkiLCJzdGF0ZU9yRGlzcGF0Y2giLCJvd25Qcm9wcyIsImRldGVjdEZhY3RvcnlBbmRWZXJpZnkiLCJ2ZXJpZnlQbGFpbk9iamVjdCIsImFhYSIsImdldEVsZW1lbnRCeUlkIiwibSIsInAiLCJxIiwiciIsInQiLCJ1IiwidiIsInciLCJ6IiwiQSIsIkIiLCJDIiwiRCIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiRSIsIkYiLCJ1bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQiLCJHIiwiSCIsIkkiLCJKIiwiaCIsImwiLCJLIiwiZXNjYXBlIiwiTCIsIk0iLCJOIiwia2V5UHJlZml4IiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJUIiwiVSIsInRvQXJyYXkiLCJQdXJlQ29tcG9uZW50IiwidW5zdGFibGVfQXN5bmNDb21wb25lbnQiLCJGcmFnbWVudCIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiViIsIlciLCJSZWFjdFZlcnNpb24iLCJoYXNTeW1ib2wiLCJSRUFDVF9DQUxMX1RZUEUiLCJSRUFDVF9SRVRVUk5fVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIm1heWJlSXRlcmF0b3IiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuaW5nS2V5IiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiQXN5bmNDb21wb25lbnQiLCJhc3luY0NvbXBvbmVudFByb3RvdHlwZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJQT09MX1NJWkUiLCJ0cmF2ZXJzZUNvbnRleHRQb29sIiwiZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0IiwibWFwUmVzdWx0IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwidHJhdmVyc2VDb250ZXh0IiwicmVsZWFzZVRyYXZlcnNlQ29udGV4dCIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJnZXRDb21wb25lbnRLZXkiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaWkiLCJhZGRlbmR1bSIsImNoaWxkcmVuU3RyaW5nIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJnZXRDb21wb25lbnROYW1lIiwiZmliZXIiLCJjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiVkFMSURfRlJBR01FTlRfUFJPUFMiLCJQcm9wVHlwZXMiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJoYXMiLCJjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsIlJlYWN0IiwiUmVhY3QkMiIsIlJlYWN0JDMiLCJyZWFjdCIsImNoZWNrRENFIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiYWEiLCJiYSIsImRhIiwiZWEiLCJmYSIsImlhIiwib2EiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGVja2VkIiwiaW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwic3R5bGUiLCJwYSIsInRhIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwidG9Mb3dlckNhc2UiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJoYXNTdHJpbmdCb29sZWFuVmFsdWUiLCJ2YSIsIndhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJCYSIsIkNhIiwiRGEiLCJhbGxvd0Z1bGxTY3JlZW4iLCJhc3luYyIsImF1dG9Gb2N1cyIsImF1dG9QbGF5IiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImZvcm1Ob1ZhbGlkYXRlIiwiaGlkZGVuIiwibG9vcCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub1ZhbGlkYXRlIiwib3BlbiIsInBsYXlzSW5saW5lIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm93cyIsInJvd1NwYW4iLCJzY29wZWQiLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZSIsInN0YXJ0Iiwic3BhbiIsInNwZWxsQ2hlY2siLCJ0YWJJbmRleCIsIml0ZW1TY29wZSIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwicmVtb3ZlQXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidmFsaWRpdHkiLCJiYWRJbnB1dCIsIm93bmVyRG9jdW1lbnQiLCJFYSIsInhsaW5rIiwieG1sIiwiR2EiLCJhdXRvUmV2ZXJzZSIsImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQiLCJwcmVzZXJ2ZUFscGhhIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJIYSIsIklhIiwidG9VcHBlckNhc2UiLCJfY2F1Z2h0RXJyb3IiLCJfaGFzQ2F1Z2h0RXJyb3IiLCJfcmV0aHJvd0Vycm9yIiwiX2hhc1JldGhyb3dFcnJvciIsImluamVjdGlvbiIsImluamVjdEVycm9yVXRpbHMiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJKYSIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsImhhc0NhdWdodEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsIkthIiwiTGEiLCJNYSIsIk5hIiwiT2EiLCJleHRyYWN0RXZlbnRzIiwiZXZlbnRUeXBlcyIsIlBhIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJRYSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJSYSIsIlNhIiwiZGVwZW5kZW5jaWVzIiwiVGEiLCJVYSIsIlZhIiwicGx1Z2lucyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiV2EiLCJYYSIsIllhIiwiWmEiLCJjdXJyZW50VGFyZ2V0IiwiJGEiLCJhYiIsImJiIiwiY2IiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzUGVyc2lzdGVudCIsInJlbGVhc2UiLCJkYiIsImdiIiwiaGIiLCJpYiIsInN0YXRlTm9kZSIsImpiIiwia2IiLCJsYiIsIm1iIiwiZ2V0TGlzdGVuZXIiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJuYiIsIk1hdGgiLCJyYW5kb20iLCJvYiIsInBiIiwidGFnIiwicWIiLCJyYiIsInNiIiwicHJlY2FjaGVGaWJlck5vZGUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJ0YiIsInViIiwidmIiLCJkaXNwYXRjaENvbmZpZyIsIndiIiwiX3RhcmdldEluc3QiLCJ4YiIsInliIiwiemIiLCJBYiIsIkJiIiwiYWx0ZXJuYXRlIiwiQ2IiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkRiIiwiRWIiLCJkb2N1bWVudEVsZW1lbnQiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJfZmFsbGJhY2tUZXh0IiwiRmIiLCJHYiIsIkhiIiwiSWIiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJEYXRlIiwibm93IiwiaXNUcnVzdGVkIiwibmF0aXZlRXZlbnQiLCJJbnRlcmZhY2UiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZXR1cm5WYWx1ZSIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJkZXN0cnVjdG9yIiwiYXVnbWVudENsYXNzIiwiSmIiLCJLYiIsImV2ZW50UG9vbCIsIkxiIiwiZ2V0UG9vbGVkIiwiTWIiLCJkYXRhIiwiTmIiLCJQYiIsIlZiIiwiV2IiLCJkb2N1bWVudE1vZGUiLCJYYiIsIlliIiwib3BlcmEiLCJaYiIsIiRiIiwiYWMiLCJiYyIsImJlZm9yZUlucHV0IiwiYnViYmxlZCIsImNhcHR1cmVkIiwiY29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJjYyIsImRjIiwia2V5Q29kZSIsImVjIiwiZGV0YWlsIiwiZmMiLCJnYyIsIndoaWNoIiwiaGMiLCJjaGFyIiwiaWMiLCJqYyIsImtjIiwibGMiLCJtYyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJuYyIsImluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQiLCJvYyIsInBjIiwicWMiLCJlbnF1ZXVlU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyYyIsInNjIiwidGMiLCJ1YyIsImNvbG9yIiwiZGF0ZSIsImRhdGV0aW1lIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInBhc3N3b3JkIiwicmFuZ2UiLCJ0ZWwiLCJ0aW1lIiwid2VlayIsInZjIiwibm9kZU5hbWUiLCJ3YyIsInNyY0VsZW1lbnQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIm5vZGVUeXBlIiwieGMiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJ5YyIsInpjIiwiQWMiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwiX3ZhbHVlVHJhY2tlciIsIkJjIiwiQ2MiLCJEYyIsImNoYW5nZSIsIkVjIiwiRmMiLCJHYyIsIkhjIiwiSWMiLCJKYyIsIktjIiwiTGMiLCJNYyIsIk5jIiwiT2MiLCJQYyIsIiRjIiwiYWQiLCJfaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwiX3dyYXBwZXJTdGF0ZSIsImNvbnRyb2xsZWQiLCJnZXRBdHRyaWJ1dGUiLCJiZCIsInZpZXciLCJjZCIsIkFsdCIsIkNvbnRyb2wiLCJNZXRhIiwiU2hpZnQiLCJkZCIsImdldE1vZGlmaWVyU3RhdGUiLCJlZCIsImZkIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInBhZ2VYIiwicGFnZVkiLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50IiwidG9FbGVtZW50IiwiZ2QiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsImhkIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJqZCIsImtkIiwiZWZmZWN0VGFnIiwibGQiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwibWQiLCJuZCIsInNpYmxpbmciLCJvZCIsInBkIiwicWQiLCJyZCIsInRhcmdldEluc3QiLCJhbmNlc3RvcnMiLCJjb250YWluZXJJbmZvIiwic2QiLCJ0b3BMZXZlbFR5cGUiLCJ0ZCIsInVkIiwidmQiLCJ3ZCIsInhkIiwiX2VuYWJsZWQiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzZXRIYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJpc0VuYWJsZWQiLCJ0cmFwQnViYmxlZEV2ZW50IiwidHJhcENhcHR1cmVkRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwieWQiLCJ6ZCIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsIkFkIiwiQmQiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwiQ2QiLCJEZCIsInRvcEFib3J0IiwidG9wQW5pbWF0aW9uRW5kIiwidG9wQW5pbWF0aW9uSXRlcmF0aW9uIiwidG9wQW5pbWF0aW9uU3RhcnQiLCJ0b3BCbHVyIiwidG9wQ2FuY2VsIiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDbG9zZSIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRHVyYXRpb25DaGFuZ2UiLCJ0b3BFbXB0aWVkIiwidG9wRW5jcnlwdGVkIiwidG9wRW5kZWQiLCJ0b3BFcnJvciIsInRvcEZvY3VzIiwidG9wSW5wdXQiLCJ0b3BLZXlEb3duIiwidG9wS2V5UHJlc3MiLCJ0b3BLZXlVcCIsInRvcExvYWRlZERhdGEiLCJ0b3BMb2FkIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZURvd24iLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXN0ZSIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG9nZ2xlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BUcmFuc2l0aW9uRW5kIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwiRWQiLCJGZCIsIkdkIiwiSGQiLCJJZCIsImZpcnN0Q2hpbGQiLCJKZCIsInRleHRDb250ZW50Iiwib2Zmc2V0IiwibmV4dFNpYmxpbmciLCJLZCIsIkxkIiwiTWQiLCJzZWxlY3QiLCJOZCIsIk9kIiwiUGQiLCJRZCIsIlJkIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJnZXRTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJTZCIsIm9uU2VsZWN0IiwiVGQiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiVWQiLCJjbGlwYm9hcmREYXRhIiwiVmQiLCJXZCIsImNoYXJDb2RlIiwiWGQiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwiWWQiLCJaZCIsInJlcGVhdCIsImxvY2FsZSIsIiRkIiwiZGF0YVRyYW5zZmVyIiwiYWUiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiYmUiLCJjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiZGUiLCJlZSIsImZlIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIsImdlIiwiaGUiLCJpZSIsIlgiLCJqZSIsImtlIiwibGUiLCJtZSIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsIm5lIiwib2UiLCJjdXJzb3IiLCJwZSIsInFlIiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJZIiwibWVtb2l6ZWRTdGF0ZSIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRQcm9wcyIsInBlbmRpbmdQcm9wcyIsImludGVybmFsQ29udGV4dFRhZyIsImxhc3RFZmZlY3QiLCJmaXJzdEVmZmVjdCIsIm5leHRFZmZlY3QiLCJleHBpcmF0aW9uVGltZSIsInNlIiwidGUiLCJ1ZSIsInZlIiwid2UiLCJoYW5kbGVyIiwieGUiLCJ5ZSIsInBlbmRpbmdDaGlsZHJlbiIsInplIiwiQWUiLCJCZSIsIkNlIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiRGUiLCJFZSIsIkZlIiwiYmFzZVN0YXRlIiwiZmlyc3QiLCJjYWxsYmFja0xpc3QiLCJoYXNGb3JjZVVwZGF0ZSIsImlzSW5pdGlhbGl6ZWQiLCJHZSIsIkhlIiwiSWUiLCJKZSIsImlzUmVwbGFjZSIsImlzRm9yY2VkIiwiS2UiLCJMZSIsIm5leHRDYWxsYmFjayIsImFkb3B0Q2xhc3NJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtb3VudENsYXNzSW5zdGFuY2UiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiUWUiLCJSZSIsIlNlIiwiVGUiLCJVZSIsIlZlIiwiV2UiLCJYZSIsIlllIiwiWmUiLCJfc3RyaW5nUmVmIiwiJGUiLCJhZiIsImJmIiwiY2YiLCJkZiIsInBlbmRpbmdDb250ZXh0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJ1c2VTeW5jU2NoZWR1bGluZyIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJwdXNoSG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRhaW5lciIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJPYiIsImJlZ2luV29yayIsImh5ZHJhdGUiLCJiZWdpbkZhaWxlZFdvcmsiLCJlZiIsImNyZWF0ZUluc3RhbmNlIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJwcmVwYXJlVXBkYXRlIiwicGVyc2lzdGVuY2UiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInBvcEhvc3RDb250ZXh0IiwiZ2V0SG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIiwicG9wSHlkcmF0aW9uU3RhdGUiLCJtdXRhdGlvbiIsImNvbXBsZXRlV29yayIsImZmIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRMaWZlQ3ljbGVzIiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiZ2YiLCJoZiIsImdldENoaWxkSG9zdENvbnRleHQiLCJnZXRSb290SG9zdENvbnRleHQiLCJyZXNldEhvc3RDb250YWluZXIiLCJqZiIsImh5ZHJhdGlvbiIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJrZiIsIlFiIiwiamEiLCJpc1JlYWR5Rm9yQ29tbWl0IiwieWciLCJ6ZyIsIkFnIiwiTmUiLCJPZSIsIlNjIiwiQmciLCJUYyIsIkRnIiwiRWciLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudFN0YWNrIiwiY2EiLCJRYyIsImhhIiwicWEiLCJGZyIsInJnIiwiR2ciLCJVYyIsInJhIiwiUmMiLCJlYiIsInFnIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJlcnJvckJvdW5kYXJ5IiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ3aWxsUmV0cnkiLCJzdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nIiwiVmMiLCJrYSIsIkhnIiwiUmIiLCJJZyIsIm5leHRTY2hlZHVsZWRSb290IiwicmVtYWluaW5nRXhwaXJhdGlvblRpbWUiLCJzYSIsImxhIiwiU2IiLCJtYSIsIm5hIiwiV2MiLCJQZSIsIlRiIiwiSmciLCJYYyIsIktnIiwiZmIiLCJZYyIsIlViIiwiWmMiLCJGYSIsImZpbmlzaGVkV29yayIsInRpbWVSZW1haW5pbmciLCJMZyIsIk1lIiwic2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrIiwiY2FuY2VsRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJDZyIsInJlc2V0QWZ0ZXJDb21taXQiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwiY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciIsInNjaGVkdWxlV29yayIsImJhdGNoZWRVcGRhdGVzIiwidW5iYXRjaGVkVXBkYXRlcyIsImZsdXNoU3luYyIsImRlZmVycmVkVXBkYXRlcyIsImxmIiwiY3JlYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsIm1mIiwibmYiLCJvZiIsInBmIiwicWYiLCJwZXJmb3JtYW5jZSIsInJmIiwic2YiLCJ0ZiIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJ1ZiIsInZmIiwid2YiLCJ4ZiIsInlmIiwiemYiLCJBZiIsIkJmIiwiZGlkVGltZW91dCIsIkNmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiRGYiLCJwb3N0TWVzc2FnZSIsIkluZmluaXR5IiwiRWYiLCJGZiIsIkdmIiwiSGYiLCJJZiIsImlzTmFOIiwiSmYiLCJzZXRBdHRyaWJ1dGVOUyIsIktmIiwiTGYiLCJtaW4iLCJtYXgiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsIk1mIiwiTmYiLCJPZiIsInBhcnNlRmxvYXQiLCJQZiIsIlFmIiwiUmYiLCJTZiIsImRlZmF1bHRTZWxlY3RlZCIsIlRmIiwid2FzTXVsdGlwbGUiLCJVZiIsIlZmIiwiV2YiLCJYZiIsIllmIiwiaHRtbCIsIm1hdGhtbCIsInN2ZyIsIlpmIiwiJGYiLCJhZyIsImJnIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsIm5hbWVzcGFjZVVSSSIsImNnIiwibGFzdENoaWxkIiwibm9kZVZhbHVlIiwiZGciLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJlZyIsInN1YnN0cmluZyIsImZnIiwidHJpbSIsInNldFByb3BlcnR5IiwiZ2ciLCJtZW51aXRlbSIsImFyZWEiLCJiYXNlIiwiYnIiLCJjb2wiLCJlbWJlZCIsImhyIiwiaW1nIiwiaW5wdXQiLCJrZXlnZW4iLCJsaW5rIiwibWV0YSIsInBhcmFtIiwidHJhY2siLCJ3YnIiLCJoZyIsImlnIiwiamciLCJrZyIsImxnIiwibWciLCJuZyIsImNyZWF0ZUVsZW1lbnROUyIsIm9nIiwiY3JlYXRlVGV4dE5vZGUiLCJwZyIsIl9faHRtbCIsIm9uY2xpY2siLCJzZyIsInRnIiwidWciLCJ2ZyIsIndnIiwic2V0SW5pdGlhbFByb3BlcnRpZXMiLCJkaWZmUHJvcGVydGllcyIsInVwZGF0ZVByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzIiwiZGlmZkh5ZHJhdGVkVGV4dCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9ybSIsInhnIiwiTWciLCJOZyIsIk9nIiwiWiIsInRhZ05hbWUiLCJyYW5nZUNvdW50IiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImV4dGVuZCIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwidG9wIiwic2Nyb2xsVG9wIiwiZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJQZyIsIl9yZWFjdFJvb3RDb250YWluZXIiLCJRZyIsIlJnIiwidW5tb3VudCIsIlNnIiwiY3JlYXRlUG9ydGFsIiwiZmluZERPTU5vZGUiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bnN0YWJsZV9jcmVhdGVQb3J0YWwiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyIsIkV2ZW50UGx1Z2luSHViIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIkV2ZW50UHJvcGFnYXRvcnMiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnQiLCJSZWFjdERPTUNvbXBvbmVudFRyZWUiLCJSZWFjdERPTUV2ZW50TGlzdGVuZXIiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsIlRnIiwiVWciLCJpc05vZGUiLCJOb2RlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwiY2FtZWxpemVTdHlsZU5hbWUiLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJkb21Qcm9wZXJ0eUNvbmZpZyIsIkluamVjdGlvbiIsInByb3BlcnRpZXMiLCJsb3dlckNhc2VkIiwicHJvcENvbmZpZyIsInByb3BlcnR5SW5mbyIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiUk9PVF9BVFRSSUJVVEVfTkFNRSIsInNob3VsZFNldEF0dHJpYnV0ZSIsImlzUmVzZXJ2ZWRQcm9wIiwic2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlIiwiZ2V0UHJvcGVydHlJbmZvIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEiLCJOUyIsIkFUVFJTIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJDQU1FTElaRSIsImNhcGl0YWxpemUiLCJ0b2tlbiIsIm9yaWdpbmFsIiwicmVhY3ROYW1lIiwiUmVhY3RFcnJvclV0aWxzIiwiaW5qZWN0ZWRFcnJvclV0aWxzIiwiZnVuY0FyZ3MiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZGlkRXJyb3IiLCJjYWxsQ2FsbGJhY2siLCJldnRUeXBlIiwiZGlkU2V0RXJyb3IiLCJpc0Nyb3NzT3JpZ2luRXJyb3IiLCJvbkVycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJldnQiLCJpbml0RXZlbnQiLCJldmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5Nb2R1bGUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50TmFtZSIsInB1Ymxpc2hFdmVudEZvclBsdWdpbiIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsImxvd2VyQ2FzZWROYW1lIiwib25kYmxjbGljayIsImluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJpbmplY3Rpb24kMiIsImluamVjdENvbXBvbmVudFRyZWUiLCJJbmplY3RlZCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJzaW11bGF0ZWQiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwibGVhdmUiLCJlbnRlciIsImNvbnRlbnRLZXkiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwiY29tcG9zaXRpb25TdGF0ZSIsImluaXRpYWxpemUiLCJyZXNldCIsImdldERhdGEiLCJzdGFydFZhbHVlIiwic3RhcnRMZW5ndGgiLCJlbmRWYWx1ZSIsImVuZExlbmd0aCIsIm1pbkVuZCIsInNsaWNlVGFpbCIsImRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IiwiaXNQcm94eVN1cHBvcnRlZCIsIlByb3h5IiwiRVZFTlRfUE9PTF9TSVpFIiwic2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMiLCJFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0V2ZW50Iiwibm9ybWFsaXplIiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsIkNsYXNzIiwiU3VwZXIiLCJhZGRFdmVudFBvb2xpbmdUbyIsImNvbnN0cnVjdCIsInRoYXQiLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwid2FybmluZ0NvbmRpdGlvbiIsImdldFBvb2xlZEV2ZW50IiwibmF0aXZlSW5zdCIsIkV2ZW50Q29uc3RydWN0b3IiLCJyZWxlYXNlUG9vbGVkRXZlbnQiLCJTeW50aGV0aWNFdmVudCQxIiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJkaXNwYXRjaE1hcmtlciIsIklucHV0RXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsImlzUHJlc3RvIiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImdldENvbXBvc2l0aW9uRXZlbnRUeXBlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiaXNDb21wb3NpbmciLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImZhbGxiYWNrRGF0YSIsImN1c3RvbURhdGEiLCJnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsImZpYmVySG9zdENvbXBvbmVudCIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbiIsImhvc3RDb21wb25lbnRJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsImluamVjdGlvbiQzIiwicXVldWVkVGFyZ2V0cyIsImZpYmVyQmF0Y2hlZFVwZGF0ZXMiLCJib29ra2VlcGluZyIsImlzTmVzdGluZ0JhdGNoZWQiLCJSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiIsImluamVjdEZpYmVyQmF0Y2hlZFVwZGF0ZXMiLCJfYmF0Y2hlZFVwZGF0ZXMiLCJpbmplY3Rpb24kNCIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJlbGVtIiwiRUxFTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwiQ09NTUVOVF9OT0RFIiwiRE9DVU1FTlRfTk9ERSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJnZXRFdmVudFRhcmdldCIsInVzZUhhc0ZlYXR1cmUiLCJpc0V2ZW50U3VwcG9ydGVkIiwiZXZlbnROYW1lU3VmZml4IiwiaXNTdXBwb3J0ZWQiLCJpc0NoZWNrYWJsZSIsImdldFRyYWNrZXIiLCJkZXRhY2hUcmFja2VyIiwiZ2V0VmFsdWVGcm9tTm9kZSIsInRyYWNrVmFsdWVPbk5vZGUiLCJ2YWx1ZUZpZWxkIiwiZGVzY3JpcHRvciIsImN1cnJlbnRWYWx1ZSIsInRyYWNrZXIiLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsImV2ZW50VHlwZXMkMSIsImNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudCIsImFjdGl2ZUVsZW1lbnRJbnN0Iiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCIsImhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsIkRPTUV2ZW50UGx1Z2luT3JkZXIiLCJVSUV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVUlFdmVudCIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsIk1vdXNlRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwiZXZlbnRUeXBlcyQyIiwid2luIiwicmVsYXRlZCIsImZyb21Ob2RlIiwidG9Ob2RlIiwiUmVhY3RJbnRlcm5hbHMiLCJOb0VmZmVjdCIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJVcGRhdGUiLCJQbGFjZW1lbnRBbmRVcGRhdGUiLCJEZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRXJyIiwiUmVmIiwiTU9VTlRJTkciLCJNT1VOVEVEIiwiVU5NT1VOVEVEIiwiaXNGaWJlck1vdW50ZWRJbXBsIiwiaXNGaWJlck1vdW50ZWQiLCJvd25lckZpYmVyIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyIsIkNBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSIsImNhbGxiYWNrQm9va2tlZXBpbmdQb29sIiwiZmluZFJvb3RDb250YWluZXJOb2RlIiwiZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwicmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsImhhbmRsZVRvcExldmVsSW1wbCIsImFuY2VzdG9yIiwicm9vdCIsImhhbmRsZVRvcExldmVsIiwiZW5hYmxlZCIsImhhbmRsZXJCYXNlTmFtZSIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJwcmVmaXhlcyIsInZlbmRvclByZWZpeGVzIiwicHJlZml4ZWRFdmVudE5hbWVzIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJwcmVmaXhNYXAiLCJ0b3BMZXZlbFR5cGVzJDEiLCJCcm93c2VyRXZlbnRDb25zdGFudHMiLCJ0b3BMZXZlbFR5cGVzIiwicnVuRXZlbnRRdWV1ZUluQmF0Y2giLCJhbHJlYWR5TGlzdGVuaW5nVG8iLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsImxpc3RlblRvIiwiY29udGVudERvY3VtZW50SGFuZGxlIiwiaXNMaXN0ZW5pbmciLCJkZXBlbmRlbmN5IiwiaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Iiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsImdldE9mZnNldHMiLCJzZWxlY3Rpb24iLCJmb2N1c05vZGUkJDEiLCJnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyIsImluZGV4V2l0aGluQW5jaG9yIiwiaW5kZXhXaXRoaW5Gb2N1cyIsIm91dGVyIiwic2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJpc0luRG9jdW1lbnQiLCJoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMiLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImdldFNlbGVjdGlvbiQxIiwicmVzdG9yZVNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwiZXZlbnRUeXBlcyQzIiwiYWN0aXZlRWxlbWVudCQxIiwiYWN0aXZlRWxlbWVudEluc3QkMSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJBbmltYXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIkZvY3VzRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNGb2N1c0V2ZW50IiwiZ2V0RXZlbnRDaGFyQ29kZSIsIm5vcm1hbGl6ZUtleSIsInRyYW5zbGF0ZVRvS2V5IiwiZ2V0RXZlbnRLZXkiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIkRyYWdFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiV2hlZWxFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJldmVudFR5cGVzJDQiLCJ0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWciLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsInRvcEV2ZW50Iiwia25vd25IVE1MVG9wTGV2ZWxUeXBlcyIsImVuYWJsZUFzeW5jU3VidHJlZUFQSSIsImVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00iLCJlbmFibGVDcmVhdGVSb290IiwiZW5hYmxlVXNlclRpbWluZ0FQSSIsImVuYWJsZU11dGF0aW5nUmVjb25jaWxlciIsImVuYWJsZU5vb3BSZWNvbmNpbGVyIiwiZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIiLCJkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImNyZWF0ZUN1cnNvciIsInJlc2V0JDEiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciIsIndvcmtJblByb2dyZXNzIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lIiwiUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0iLCJyZXNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRQaGFzZSIsInJlYWN0RW1vamkiLCJ3YXJuaW5nRW1vamkiLCJzdXBwb3J0c1VzZXJUaW1pbmciLCJtYXJrIiwiY2xlYXJNYXJrcyIsIm1lYXN1cmUiLCJjbGVhck1lYXN1cmVzIiwiY3VycmVudEZpYmVyIiwiY3VycmVudFBoYXNlIiwiY3VycmVudFBoYXNlRmliZXIiLCJpc0NvbW1pdHRpbmciLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQiLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSIsImNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AiLCJlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCIsImlzV2FpdGluZ0ZvckNhbGxiYWNrIiwibGFiZWxzSW5DdXJyZW50Q29tbWl0IiwiZm9ybWF0TWFya05hbWUiLCJtYXJrTmFtZSIsImZvcm1hdExhYmVsIiwibGFiZWwiLCJ3YXJuaW5nJCQxIiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJiZWdpbkZpYmVyTWFyayIsImNsZWFyRmliZXJNYXJrIiwiZW5kRmliZXJNYXJrIiwic2hvdWxkSWdub3JlRmliZXIiLCJjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50IiwicGF1c2VUaW1lcnMiLCJfZGVidWdJc0N1cnJlbnRseVRpbWluZyIsInJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5IiwicmVzdW1lVGltZXJzIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwiZGlkRXhwaXJlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJzdGFydENvbW1pdFRpbWVyIiwiY2xlYXIiLCJzdG9wQ29tbWl0VGltZXIiLCJzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwic3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJoYXNPd25Db250ZXh0IiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJwb3BDb250ZXh0UHJvdmlkZXIiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJyZXNldENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImV4cGlyYXRpb25UaW1lVG9NcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJOb0NvbnRleHQiLCJBc3luY1VwZGF0ZXMiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiZWxlbWVudHMiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY29udGVudCIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiY3JlYXRlRmliZXJGcm9tQ2FsbCIsImNyZWF0ZUZpYmVyRnJvbVJldHVybiIsInJldHVybk5vZGUiLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJjcmVhdGVGaWJlclJvb3QiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJoYXNMb2dnZWRFcnJvciIsImNhdGNoRXJyb3JzIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsInJlbmRlcmVySUQiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3JlYXRlVXBkYXRlUXVldWUiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiX2NhbGxiYWNrTGlzdCIsImNvbW1pdENhbGxiYWNrcyIsIl9jYWxsYmFjayIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Iiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50IiwibWVtb2l6ZVByb3BzIiwibWVtb2l6ZVN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsIm5ld0NvbnRleHQiLCJzaG91bGRVcGRhdGUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50Iiwibm9HZXRJbml0aWFsU3RhdGVPbkVTNiIsImdldEluaXRpYWxTdGF0ZSIsIm5vR2V0RGVmYXVsdFByb3BzT25FUzYiLCJub0luc3RhbmNlUHJvcFR5cGVzIiwibm9JbnN0YW5jZUNvbnRleHRUeXBlcyIsIm5vQ29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwibm9Db21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkVW5tb3VudCIsIm5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwibm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJyZXNldElucHV0UG9pbnRlcnMiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY3RvciIsIm5lZWRzQ29udGV4dCIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsImlzQXJyYXkkMSIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwicmV0dXJuRmliZXIiLCJuZXdDaGlsZCIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZCIsInVzZUZpYmVyIiwiY2xvbmUiLCJwbGFjZUNoaWxkIiwibmV3RmliZXIiLCJsYXN0UGxhY2VkSW5kZXgiLCJuZXdJbmRleCIsIm9sZEluZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwiY3JlYXRlZCIsImV4aXN0aW5nIiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZUNhbGwiLCJ1cGRhdGVSZXR1cm4iLCJ1cGRhdGVQb3J0YWwiLCJ1cGRhdGVGcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX2NyZWF0ZWQiLCJfY3JlYXRlZDIiLCJfY3JlYXRlZDMiLCJfY3JlYXRlZDQiLCJfY3JlYXRlZDUiLCJfY3JlYXRlZDYiLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwibWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIyIiwiX21hdGNoZWRGaWJlcjMiLCJfbWF0Y2hlZEZpYmVyNCIsIl9tYXRjaGVkRmliZXI1Iiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwiX25ld0ZpYmVyIiwiX25ld0ZpYmVyMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwicG9zc2libGVNYXAiLCJfbmV3Q2hpbGRyZW4iLCJfbmV3RmliZXIzIiwiX25ld0ZpYmVyNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9jcmVhdGVkNyIsInJlY29uY2lsZVNpbmdsZUNhbGwiLCJyZWNvbmNpbGVTaW5nbGVSZXR1cm4iLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzT2JqZWN0IiwiX2lzTW9ja0Z1bmN0aW9uIiwibW91bnRDaGlsZEZpYmVycyIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJ3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMiLCJSZWFjdEZpYmVyQmVnaW5Xb3JrIiwiaG9zdENvbnRleHQiLCJoeWRyYXRpb25Db250ZXh0IiwiX1JlYWN0RmliZXJDbGFzc0NvbXBvIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJyZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUiLCJiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrIiwibWFya1JlZiIsInVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsImhhc0NvbnRleHQiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJwcmV2UHJvcHMiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwibW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50IiwiZGVidWdTb3VyY2UiLCJ1cGRhdGVDYWxsQ29tcG9uZW50IiwibmV4dENhbGwiLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJiYWlsb3V0T25Mb3dQcmlvcml0eSIsIm5leHRTdGF0ZSIsIlJlYWN0RmliZXJDb21wbGV0ZVdvcmsiLCJtYXJrVXBkYXRlIiwiYXBwZW5kQWxsUmV0dXJucyIsInJldHVybnMiLCJtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwidXBkYXRlUGF5bG9hZCIsInJvb3RDb250YWluZXJJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiY2xvbmVJbnN0YW5jZSIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsInBvcnRhbE9yUm9vdCIsImNoaWxkcmVuVW5jaGFuZ2VkIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjdXJyZW50SW5zdGFuY2UiLCJyZWN5Y2xhYmxlSW5zdGFuY2UiLCJuZXdJbnN0YW5jZSIsImN1cnJlbnRIb3N0Q29udGV4dCIsImZpYmVyUm9vdCIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl9pbnN0YW5jZSIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0MiIsIl93YXNIeWRyYXRlZCIsImludm9rZUd1YXJkZWRDYWxsYmFjayQyIiwiaGFzQ2F1Z2h0RXJyb3IkMSIsImNsZWFyQ2F1Z2h0RXJyb3IkMSIsIlJlYWN0RmliZXJDb21taXRXb3JrIiwiY2FwdHVyZUVycm9yIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJfdXBkYXRlUXVldWUiLCJfaW5zdGFuY2UyIiwiY3VycmVudFJlZiIsImNvbW1pdFVubW91bnQiLCJjb21taXROZXN0ZWRVbm1vdW50cyIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiZGV0YWNoRmliZXIiLCJjb21taXRDb250YWluZXIiLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJlbXB0eUNoaWxkU2V0IiwiX3BlbmRpbmdDaGlsZHJlbiIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJwYXJlbnRGaWJlciIsImlzQ29udGFpbmVyIiwiYmVmb3JlIiwiY3VycmVudFBhcmVudElzVmFsaWQiLCJjdXJyZW50UGFyZW50SXNDb250YWluZXIiLCJmaW5kUGFyZW50IiwidGV4dEluc3RhbmNlIiwiTk9fQ09OVEVYVCIsIlJlYWN0RmliZXJIb3N0Q29udGV4dCIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJyZXF1aXJlZENvbnRleHQiLCJyb290SW5zdGFuY2UiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfdGV4dCIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJzdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiY2hlY2tSb290TmVlZHNDbGVhcmluZyIsImlzRXJyb3JSZWNvdmVyeSIsInJlcXVlc3RXb3JrIiwicHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsImlzUmVuZGVyaW5nIiwibmV4dEZsdXNoZWRSb290IiwibmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSIsImRlYWRsaW5lRGlkRXhwaXJlIiwiaGFzVW5oYW5kbGVkRXJyb3IiLCJ1bmhhbmRsZWRFcnJvciIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwidGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24iLCJjdXJyZW50TXMiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDEiLCJfUmVhY3RGaWJlclNjaGVkdWxlciIsInNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUiLCJob3N0RmliZXIiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJjb250YWluZXJGaWJlciIsImRldlRvb2xzQ29uZmlnIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMiIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDMiLCJyZWFjdFJlY29uY2lsZXIiLCJjcmVhdGVQb3J0YWwkMSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicklDIiwiY0lDIiwiZnJhbWVDYWxsYmFjayIsInRpbWVvdXRJRCIsInNjaGVkdWxlZFJJQ0NhbGxiYWNrIiwiaXNJZGxlU2NoZWR1bGVkIiwidGltZW91dFRpbWUiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlQ2hlY2tlZCIsInVwZGF0ZVdyYXBwZXIiLCJ2YWx1ZUFzTnVtYmVyIiwicG9zdE1vdW50V3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJvdGhlck5vZGUiLCJvdGhlclByb3BzIiwiZmxhdHRlbkNoaWxkcmVuIiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsInBvc3RNb3VudFdyYXBwZXIkMiIsInBvc3RVcGRhdGVXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1IiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJnZXRIb3N0UHJvcHMkMyIsImluaXRXcmFwcGVyU3RhdGUkMiIsInVwZGF0ZVdyYXBwZXIkMSIsIm5ld1ZhbHVlIiwicG9zdE1vdW50V3JhcHBlciQzIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwiSFRNTF9OQU1FU1BBQ0UkMSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJzdmdOb2RlIiwic2V0VGV4dENvbnRlbnQiLCJpc1VuaXRsZXNzTnVtYmVyIiwicHJlZml4S2V5IiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc0VtcHR5Iiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwib21pdHRlZENsb3NlVGFncyIsInZvaWRFbGVtZW50VGFncyIsIkhUTUwkMSIsImFzc2VydFZhbGlkUHJvcHMiLCJpc0N1c3RvbUNvbXBvbmVudCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwiZ2V0U3RhY2tBZGRlbmR1bSQxIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJlbmN0eXBlIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZ2giLCJocmVmbGFuZyIsImh0bWxmb3IiLCJodHRwZXF1aXYiLCJpY29uIiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaW50ZWdyaXR5IiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhbmciLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbndpZHRoIiwibWFyZ2luaGVpZ2h0IiwibWF4bGVuZ3RoIiwibWVkaWEiLCJtZWRpYWdyb3VwIiwibWV0aG9kIiwibWlubGVuZ3RoIiwibm9uY2UiLCJub3ZhbGlkYXRlIiwib3B0aW11bSIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicm9sZSIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2Nyb2xsaW5nIiwic2l6ZXMiLCJzcGVsbGNoZWNrIiwic3JjIiwic3JjZG9jIiwic3JjbGFuZyIsInNyY3NldCIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInVzZW1hcCIsIndpZHRoIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJhY2NlbnRoZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRiYXNlbGluZSIsImFsbG93cmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNmb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlbmFtZSIsImF0dHJpYnV0ZXR5cGUiLCJhdXRvcmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlZnJlcXVlbmN5IiwiYmFzZWxpbmVzaGlmdCIsImJhc2Vwcm9maWxlIiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY21vZGUiLCJjYXBoZWlnaHQiLCJjbGlwIiwiY2xpcHBhdGgiLCJjbGlwcGF0aHVuaXRzIiwiY2xpcHJ1bGUiLCJjb2xvcmludGVycG9sYXRpb24iLCJjb2xvcmludGVycG9sYXRpb25maWx0ZXJzIiwiY29sb3Jwcm9maWxlIiwiY29sb3JyZW5kZXJpbmciLCJjb250ZW50c2NyaXB0dHlwZSIsImNvbnRlbnRzdHlsZXR5cGUiLCJjeCIsImN5IiwiZGF0YXR5cGUiLCJkZWNlbGVyYXRlIiwiZGVzY2VudCIsImRpZmZ1c2Vjb25zdGFudCIsImRpcmVjdGlvbiIsImRpc3BsYXkiLCJkaXZpc29yIiwiZG9taW5hbnRiYXNlbGluZSIsImR1ciIsImR4IiwiZHkiLCJlZGdlbW9kZSIsImVsZXZhdGlvbiIsImVuYWJsZWJhY2tncm91bmQiLCJleHBvbmVudCIsImV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQiLCJmaWxsIiwiZmlsbG9wYWNpdHkiLCJmaWxscnVsZSIsImZpbHRlcnJlcyIsImZpbHRlcnVuaXRzIiwiZmxvb2RvcGFjaXR5IiwiZmxvb2Rjb2xvciIsImZvY3VzYWJsZSIsImZvbnRmYW1pbHkiLCJmb250c2l6ZSIsImZvbnRzaXplYWRqdXN0IiwiZm9udHN0cmV0Y2giLCJmb250c3R5bGUiLCJmb250dmFyaWFudCIsImZvbnR3ZWlnaHQiLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImlubGlzdCIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidHJhbnNmb3JtIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmVjdG9yZWZmZWN0IiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInpvb21hbmRwYW4iLCJnZXRTdGFja0FkZGVuZHVtJDIiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJoYXNPd25Qcm9wZXJ0eSQxIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBJDEiLCJyQVJJQUNhbWVsJDEiLCJ2YWxpZGF0ZVByb3BlcnR5JDEiLCJjYW5Vc2VFdmVudFN5c3RlbSIsImlzUmVzZXJ2ZWQiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMiIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyIiwiZGlkV2FybkludmFsaWRIeWRyYXRpb24iLCJkaWRXYXJuU2hhZHlET00iLCJEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCIsIlNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFIiwiSFRNTCIsIkhUTUxfTkFNRVNQQUNFIiwid2FybmVkVW5rbm93blRhZ3MiLCJkaWFsb2ciLCJ2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50IiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwibWFya3VwIiwibWFya3VwU3RyaW5nIiwid2FybkZvclRleHREaWZmZXJlbmNlIiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJub3JtYWxpemVkQ2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRTZXJ2ZXJUZXh0Iiwid2FybkZvclByb3BEaWZmZXJlbmNlIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRDbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSIsIndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVOYW1lcyIsIm5hbWVzIiwid2FybkZvckludmFsaWRFdmVudExpc3RlbmVyIiwibm9ybWFsaXplSFRNTCIsInRlc3RFbGVtZW50IiwiZW5zdXJlTGlzdGVuaW5nVG8iLCJyb290Q29udGFpbmVyRWxlbWVudCIsImlzRG9jdW1lbnRPckZyYWdtZW50IiwiZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyIiwibWVkaWFFdmVudHMiLCJ0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCIsInNldEluaXRpYWxET01Qcm9wZXJ0aWVzIiwiZG9tRWxlbWVudCIsImlzQ3VzdG9tQ29tcG9uZW50VGFnIiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJjcmVhdGVFbGVtZW50JDEiLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSQxIiwic2V0SW5pdGlhbFByb3BlcnRpZXMkMSIsInJhd1Byb3BzIiwic2hhZHlSb290IiwiZGlmZlByb3BlcnRpZXMkMSIsImxhc3RSYXdQcm9wcyIsIm5leHRSYXdQcm9wcyIsImxhc3RQcm9wcyIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImxhc3RQcm9wIiwibGFzdEh0bWwiLCJ1cGRhdGVQcm9wZXJ0aWVzJDEiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInJhd0h0bWwiLCJzZXJ2ZXJIVE1MIiwiZXhwZWN0ZWRIVE1MIiwiZXhwZWN0ZWRTdHlsZSIsIm93bk5hbWVzcGFjZSIsImRpZmZIeWRyYXRlZFRleHQkMSIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMSIsIlJlYWN0RE9NRmliZXJDb21wb25lbnQiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyQxIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImRpZFdhcm4iLCJjaGlsZFRhZyIsImNoaWxkVGV4dCIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwiaW52YWxpZFBhcmVudE9yQW5jZXN0b3IiLCJhbmNlc3RvclRhZyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJ2YWxpZGF0ZURPTU5lc3RpbmckMSIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiZXZlbnRzRW5hYmxlZCIsInNlbGVjdGlvbkluZm9ybWF0aW9uIiwiaXNWYWxpZENvbnRhaW5lciIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50Iiwic2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCIsIkRPTVJlbmRlcmVyIiwidmFsaWRhdGVkVGFnIiwiX2FuY2VzdG9ySW5mbyIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJfbmFtZXNwYWNlIiwiX2FuY2VzdG9ySW5mbzIiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJiZWZvcmVDaGlsZCIsIndhcm5lZEFib3V0SHlkcmF0ZUFQSSIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiZm9yY2VIeWRyYXRlIiwiaG9zdEluc3RhbmNlIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwic2hvdWxkSHlkcmF0ZSIsIndhcm5lZCIsInJvb3RTaWJsaW5nIiwibmV3Um9vdCIsIlJlYWN0Um9vdCIsIlJlYWN0RE9NIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJjb250YWluZXJOb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiX3Jvb3RFbCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY3JlYXRlUm9vdCIsImZvdW5kRGV2VG9vbHMiLCJwcm90b2NvbCIsIlJlYWN0RE9NJDIiLCJSZWFjdERPTSQzIiwicmVhY3REb20iLCJoeXBoZW5hdGUiLCJtc1BhdHRlcm4iLCJfdXBwZXJjYXNlUGF0dGVybiIsImNhbWVsaXplIiwiX2h5cGhlblBhdHRlcm4iLCJfIiwiY2hhcmFjdGVyIiwiQXBwIiwibmF2bGluayIsImdvSG9tZSIsIkJyb3dzZXJSb3V0ZXIiLCJIYXNoUm91dGVyIiwiTWVtb3J5Um91dGVyIiwiTmF2TGluayIsIlByb21wdCIsIlJlZGlyZWN0IiwiU3RhdGljUm91dGVyIiwiU3dpdGNoIiwid2l0aFJvdXRlciIsImJhc2VuYW1lIiwiZm9yY2VSZWZyZXNoIiwia2V5TGVuZ3RoIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZW50cnkiLCJpc1N5bWJvbCIsInNoaW0iLCJnZXRTaGltIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiX0xvY2F0aW9uVXRpbHMiLCJfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyIiwiX0RPTVV0aWxzIiwiUG9wU3RhdGVFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsImdldEhpc3RvcnlTdGF0ZSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiZ2xvYmFsSGlzdG9yeSIsImNhblVzZUhpc3RvcnkiLCJuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciIsIl9wcm9wcyRmb3JjZVJlZnJlc2giLCJfcHJvcHMkZ2V0VXNlckNvbmZpcm0iLCJfcHJvcHMka2V5TGVuZ3RoIiwiZ2V0RE9NTG9jYXRpb24iLCJoaXN0b3J5U3RhdGUiLCJfd2luZG93JGxvY2F0aW9uIiwiY3JlYXRlS2V5IiwidHJhbnNpdGlvbk1hbmFnZXIiLCJoYW5kbGVQb3BTdGF0ZSIsImhhbmRsZVBvcCIsImhhbmRsZUhhc2hDaGFuZ2UiLCJmb3JjZU5leHRQb3AiLCJvayIsInJldmVydFBvcCIsImZyb21Mb2NhdGlvbiIsInRvTG9jYXRpb24iLCJ0b0luZGV4IiwiZnJvbUluZGV4IiwiZGVsdGEiLCJnbyIsImluaXRpYWxMb2NhdGlvbiIsInB1c2hTdGF0ZSIsInByZXZJbmRleCIsIm5leHRLZXlzIiwiZ29CYWNrIiwiZ29Gb3J3YXJkIiwibGlzdGVuZXJDb3VudCIsImNoZWNrRE9NTGlzdGVuZXJzIiwiaXNCbG9ja2VkIiwiYmxvY2siLCJ1bmJsb2NrIiwiaGFzaFR5cGUiLCJIYXNoUGF0aENvZGVycyIsImhhc2hiYW5nIiwiZW5jb2RlUGF0aCIsImRlY29kZVBhdGgiLCJub3NsYXNoIiwic2xhc2giLCJnZXRIYXNoUGF0aCIsInB1c2hIYXNoUGF0aCIsInJlcGxhY2VIYXNoUGF0aCIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiY2FuR29XaXRob3V0UmVsb2FkIiwiX3Byb3BzJGhhc2hUeXBlIiwiX0hhc2hQYXRoQ29kZXJzJGhhc2hUIiwiaWdub3JlUGF0aCIsImVuY29kZWRQYXRoIiwicHJldkxvY2F0aW9uIiwiYWxsUGF0aHMiLCJsYXN0SW5kZXhPZiIsImhhc2hDaGFuZ2VkIiwibmV4dFBhdGhzIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJjbGFtcCIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIl9wcm9wcyRpbml0aWFsRW50cmllcyIsIl9wcm9wcyRpbml0aWFsSW5kZXgiLCJuZXh0SW5kZXgiLCJuZXh0RW50cmllcyIsImNhbkdvIiwiYWN0aXZlQ2xhc3NOYW1lIiwiYWN0aXZlU3R5bGUiLCJnZXRJc0FjdGl2ZSIsImFyaWFDdXJyZW50IiwiaXNhcnJheSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwic3RyIiwidG9rZW5zIiwiZGVmYXVsdERlbGltaXRlciIsInJlcyIsImVzY2FwZWQiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicGFydGlhbCIsIm9wdGlvbmFsIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJjaGFyQ29kZUF0IiwiZW5jb2RlQXN0ZXJpc2siLCJtYXRjaGVzIiwib3B0cyIsImVuY29kZSIsInByZXR0eSIsInNlZ21lbnQiLCJqIiwiYXR0YWNoS2V5cyIsImZsYWdzIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwicGFydHMiLCJyZWdleHAiLCJzdHJpbmdUb1JlZ2V4cCIsImVuZHNXaXRoRGVsaW1pdGVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsIndoZW4iLCJpc1N0YXRpYyIsInBlcmZvcm0iLCJwcmV2VG8iLCJuZXh0VG8iLCJub3JtYWxpemVMb2NhdGlvbiIsIl9vYmplY3QkcGF0aG5hbWUiLCJfb2JqZWN0JHNlYXJjaCIsIl9vYmplY3QkaGFzaCIsImFkZEJhc2VuYW1lIiwiY3JlYXRlVVJMIiwic3RhdGljSGFuZGxlciIsImhhbmRsZVB1c2giLCJoYW5kbGVSZXBsYWNlIiwiX3RoaXMkcHJvcHMyIiwiaGFuZGxlTGlzdGVuIiwiaGFuZGxlQmxvY2siLCJfZWxlbWVudCRwcm9wcyIsInBhdGhQcm9wIiwid3JhcHBlZENvbXBvbmVudFJlZiIsInJlbWFpbmluZ1Byb3BzIiwicm91dGVDb21wb25lbnRQcm9wcyIsIlJFQUNUX1NUQVRJQ1MiLCJtaXhpbnMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwiZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUiLCJ3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSIsIl9Qcm92aWRlciRjaGlsZENvbnRleCIsInN1YktleSIsIlJlYWN0Q2hpbGRyZW4iLCJSZWFjdFB1cmVDb21wb25lbnQiLCJSZWFjdENsYXNzIiwiUmVhY3RET01GYWN0b3JpZXMiLCJkaWRXYXJuUHJvcFR5cGVzRGVwcmVjYXRlZCIsIl9fc3ByZWFkIiwiY3JlYXRlQ2xhc3MiLCJjcmVhdGVNaXhpbiIsIm1peGluIiwiRE9NIiwiUG9vbGVkQ2xhc3MiLCJ0d29Bcmd1bWVudFBvb2xlciIsImZvdXJBcmd1bWVudFBvb2xlciIsIkZvckVhY2hCb29rS2VlcGluZyIsImZvckVhY2hGdW5jdGlvbiIsImFkZFBvb2xpbmdUbyIsIk1hcEJvb2tLZWVwaW5nIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJvbmVBcmd1bWVudFBvb2xlciIsImNvcHlGaWVsZHNGcm9tIiwiS2xhc3MiLCJpbnN0YW5jZVBvb2wiLCJhMSIsImEyIiwidGhyZWVBcmd1bWVudFBvb2xlciIsImEzIiwiYTQiLCJzdGFuZGFyZFJlbGVhc2VyIiwicG9vbFNpemUiLCJERUZBVUxUX1BPT0xfU0laRSIsIkRFRkFVTFRfUE9PTEVSIiwiQ29weUNvbnN0cnVjdG9yIiwicG9vbGVyIiwiTmV3S2xhc3MiLCJLZXlFc2NhcGVVdGlscyIsIm1hcHNBc0NoaWxkcmVuQWRkZW5kdW0iLCJtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSIsIl9pc1JlYWN0RWxlbWVudCIsInVuZXNjYXBlIiwidW5lc2NhcGVSZWdleCIsInVuZXNjYXBlckxvb2t1cCIsImtleVN1YnN0cmluZyIsIk1JWElOU19LRVkiLCJpZGVudGl0eSIsImluamVjdGVkTWl4aW5zIiwiUmVhY3RDbGFzc0ludGVyZmFjZSIsInN0YXRpY3MiLCJ1cGRhdGVDb21wb25lbnQiLCJSRVNFUlZFRF9TUEVDX0tFWVMiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJ2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlIiwiaXNBbHJlYWR5RGVmaW5lZCIsInNwZWNQb2xpY3kiLCJSZWFjdENsYXNzTWl4aW4iLCJzcGVjIiwidHlwZW9mU3BlYyIsImlzTWl4aW5WYWxpZCIsImF1dG9CaW5kUGFpcnMiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsImlzUmVhY3RDbGFzc01ldGhvZCIsInNob3VsZEF1dG9CaW5kIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNJbmhlcml0ZWQiLCJtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzIiwib25lIiwidHdvIiwibWVyZ2VkUmVzdWx0IiwiY2hhaW5lZEZ1bmN0aW9uIiwiYmluZEF1dG9CaW5kTWV0aG9kIiwiYm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRDb250ZXh0IiwiX19yZWFjdEJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQXJndW1lbnRzIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJwYWlycyIsImF1dG9CaW5kS2V5IiwiUmVhY3RDbGFzc0NvbXBvbmVudCIsImRpZFdhcm5EZXByZWNhdGVkIiwiaW5pdGlhbFN0YXRlIiwiaW5qZWN0TWl4aW4iLCJjcmVhdGVET01GYWN0b3J5IiwiYWJiciIsImFkZHJlc3MiLCJhcnRpY2xlIiwiYXNpZGUiLCJhdWRpbyIsImJkaSIsImJkbyIsImJpZyIsImJsb2NrcXVvdGUiLCJjYW52YXMiLCJjYXB0aW9uIiwiY29sZ3JvdXAiLCJkYXRhbGlzdCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkdCIsImVtIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhlYWRlciIsImhncm91cCIsImlmcmFtZSIsImlucyIsImtiZCIsImxlZ2VuZCIsImxpIiwibWFpbiIsIm1lbnUiLCJtZXRlciIsIm5hdiIsIm5vc2NyaXB0Iiwib2wiLCJvcHRncm91cCIsIm9wdGlvbiIsIm91dHB1dCIsInBpY3R1cmUiLCJwcmUiLCJwcm9ncmVzcyIsInJwIiwicnQiLCJydWJ5Iiwic2FtcCIsInNjcmlwdCIsInNlY3Rpb24iLCJzbWFsbCIsInN0cm9uZyIsInN1YiIsInN1cCIsInRhYmxlIiwidGJvZHkiLCJ0ZXh0YXJlYSIsInRmb290IiwidGgiLCJ0aGVhZCIsInRyIiwidWwiLCJ2aWRlbyIsImNpcmNsZSIsImNsaXBQYXRoIiwiZGVmcyIsImVsbGlwc2UiLCJsaW5lIiwibGluZWFyR3JhZGllbnQiLCJwb2x5Z29uIiwicG9seWxpbmUiLCJyYWRpYWxHcmFkaWVudCIsInJlY3QiLCJzdG9wIiwidHNwYW4iLCJjb21wb25lbnRTdGFja0luZm8iLCJfcmVxdWlyZSIsIkNMRUFSRUQiLCJudWxsTGlzdGVuZXJzIiwibm90aWZ5IiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiU3Vic2NyaXB0aW9uIiwiYWRkTmVzdGVkU3ViIiwiY3JlYXRlQ29ubmVjdCIsImZhY3RvcmllcyIsInN0cmljdEVxdWFsIiwiX3JlZiRjb25uZWN0SE9DIiwiY29ubmVjdEhPQyIsIl9yZWYkbWFwU3RhdGVUb1Byb3BzRiIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyIsIl9yZWYkbWFwRGlzcGF0Y2hUb1BybyIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyIsIl9yZWYkbWVyZ2VQcm9wc0ZhY3RvciIsIm1lcmdlUHJvcHNGYWN0b3JpZXMiLCJfcmVmJHNlbGVjdG9yRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIm1lcmdlUHJvcHMiLCJfcmVmMiRwdXJlIiwicHVyZSIsIl9yZWYyJGFyZVN0YXRlc0VxdWFsIiwiYXJlU3RhdGVzRXF1YWwiLCJfcmVmMiRhcmVPd25Qcm9wc0VxdWEiLCJhcmVPd25Qcm9wc0VxdWFsIiwiX3JlZjIkYXJlU3RhdGVQcm9wc0VxIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiX3JlZjIkYXJlTWVyZ2VkUHJvcHNFIiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImV4dHJhT3B0aW9ucyIsImluaXRNYXBTdGF0ZVRvUHJvcHMiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwiaW5pdE1lcmdlUHJvcHMiLCJoYXNPd24iLCJ3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiIsIndoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmciLCJ3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QiLCJpc0NydXNoZWQiLCJjb21iaW5lUmVkdWNlcnMiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhcHBseU1pZGRsZXdhcmUiLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJmcmVlU2VsZiIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsImdldFJhd1RhZyIsImlzT3duIiwidW5tYXNrZWQiLCJvYmplY3RUb1N0cmluZyIsImdldFByb3RvdHlwZSIsIm92ZXJBcmciLCJpc09iamVjdExpa2UiLCJfcG9ueWZpbGwiLCJfcG9ueWZpbGwyIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwiLCJfU3ltYm9sIiwiZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UiLCJhY3Rpb25UeXBlIiwiYWN0aW9uTmFtZSIsImdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UiLCJpbnB1dFN0YXRlIiwicmVkdWNlcnMiLCJ1bmV4cGVjdGVkS2V5Q2FjaGUiLCJyZWR1Y2VyS2V5cyIsImFyZ3VtZW50TmFtZSIsInVuZXhwZWN0ZWRLZXlzIiwiYXNzZXJ0UmVkdWNlclNhbml0eSIsImZpbmFsUmVkdWNlcnMiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2FuaXR5RXJyb3IiLCJjb21iaW5hdGlvbiIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsInByZXZpb3VzU3RhdGVGb3JLZXkiLCJuZXh0U3RhdGVGb3JLZXkiLCJlcnJvck1lc3NhZ2UiLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJtaWRkbGV3YXJlcyIsIl9kaXNwYXRjaCIsImNoYWluIiwibWlkZGxld2FyZUFQSSIsIm1pZGRsZXdhcmUiLCJ3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiIsIndoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmciLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsIndoZW5NZXJnZVByb3BzSXNGdW5jdGlvbiIsIndoZW5NZXJnZVByb3BzSXNPbWl0dGVkIiwic3RhdGVQcm9wcyIsImRpc3BhdGNoUHJvcHMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiaGFzUnVuT25jZSIsIm1lcmdlZFByb3BzIiwibWVyZ2VQcm9wc1Byb3h5IiwibmV4dE1lcmdlZFByb3BzIiwiaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSIsImltcHVyZUZpbmFsUHJvcHNTZWxlY3RvciIsImhhc1J1bkF0TGVhc3RPbmNlIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiaGFuZGxlTmV3UHJvcHMiLCJoYW5kbGVOZXdTdGF0ZSIsIm5leHRTdGF0ZVByb3BzIiwic3RhdGVQcm9wc0NoYW5nZWQiLCJoYW5kbGVTdWJzZXF1ZW50Q2FsbHMiLCJuZXh0T3duUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJzdGF0ZUNoYW5nZWQiLCJwdXJlRmluYWxQcm9wc1NlbGVjdG9yIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwidmVyaWZ5IiwiU2hvdyIsIlVzZXJOYW1lIiwiVXNuYW1lIiwiQVBJIiwiSG9tZSIsInJlcG9zIiwiZm9sbG93ZXJzIiwiZm9sbG93aW5nIiwidXNlcm5hbWUiLCJhbGVydCIsImZldGNoIiwidGhlbiIsImpzb24iLCJsb2dpbiIsInB1YmxpY19yZXBvcyIsIm5vdEZvdW5kIiwiY2F0Y2giLCJsb2ciLCJmZXRjaFByb2ZpbGUiLCJIaSIsInVzZVNvdXJjZU1hcCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJjc3MiLCJiYXNlVXJsIiwiaG9zdCIsImN1cnJlbnREaXIiLCJmaXhlZENzcyIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCJ1bnF1b3RlZE9yaWdVcmwiLCJvIiwiJDEiLCJuZXdVcmwiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FB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LENBQVkscURBQVosRUFBbUUsVUFBUzR4SCxTQUFULEVBQW9CQyxPQUFwQixFQUE2QjtBQUM5RztBQUNBLE1BQUlDLGtCQUFrQkQsUUFDcEJqdEUsSUFEb0IsR0FFcEI1a0QsT0FGb0IsQ0FFWixVQUZZLEVBRUEsVUFBUyt4SCxDQUFULEVBQVlDLEVBQVosRUFBZTtBQUFFLFVBQU9BLEVBQVA7QUFBWSxHQUY3QixFQUdwQmh5SCxPQUhvQixDQUdaLFVBSFksRUFHQSxVQUFTK3hILENBQVQsRUFBWUMsRUFBWixFQUFlO0FBQUUsVUFBT0EsRUFBUDtBQUFZLEdBSDdCLENBQXRCOztBQUtBO0FBQ0EsTUFBSSwrQ0FBK0NueUgsSUFBL0MsQ0FBb0RpeUgsZUFBcEQsQ0FBSixFQUEwRTtBQUN4RSxVQUFPRixTQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJSyxNQUFKOztBQUVBLE1BQUlILGdCQUFnQnh3SCxPQUFoQixDQUF3QixJQUF4QixNQUFrQyxDQUF0QyxFQUF5QztBQUN0QztBQUNGMndILFlBQVNILGVBQVQ7QUFDQSxHQUhELE1BR08sSUFBSUEsZ0JBQWdCeHdILE9BQWhCLENBQXdCLEdBQXhCLE1BQWlDLENBQXJDLEVBQXdDO0FBQzlDO0FBQ0Eyd0gsWUFBU1QsVUFBVU0sZUFBbkIsQ0FGOEMsQ0FFVjtBQUNwQyxHQUhNLE1BR0E7QUFDTjtBQUNBRyxZQUFTUCxhQUFhSSxnQkFBZ0I5eEgsT0FBaEIsQ0FBd0IsT0FBeEIsRUFBaUMsRUFBakMsQ0FBdEIsQ0FGTSxDQUVzRDtBQUM1RDs7QUFFRDtBQUNBLFNBQU8sU0FBU29oQixLQUFLQyxTQUFMLENBQWU0d0csTUFBZixDQUFULEdBQWtDLEdBQXpDO0FBQ0EsRUE1QmMsQ0FBZjs7QUE4QkE7QUFDQSxRQUFPTixRQUFQO0FBQ0EsQ0ExRUQsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3Mik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgY2Y3ZDI5YzRlMTIxNjBhZTU4YmUiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5fc2VsZiA9IHNlbGY7XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBleHBvcnRzLmFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG52YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbnZhciBoYXNCYXNlbmFtZSA9IGV4cG9ydHMuaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBleHBvcnRzLnN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbnZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVQYXRoID0gZXhwb3J0cy5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzIiwiZXhwb3J0IHZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIGhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBwYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbmV4cG9ydCB2YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIC8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lID0gcmVxdWlyZSgncmVzb2x2ZS1wYXRobmFtZScpO1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXNvbHZlUGF0aG5hbWUpO1xuXG52YXIgX3ZhbHVlRXF1YWwgPSByZXF1aXJlKCd2YWx1ZS1lcXVhbCcpO1xuXG52YXIgX3ZhbHVlRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsdWVFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICgwLCBfcmVzb2x2ZVBhdGhuYW1lMi5kZWZhdWx0KShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxudmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5sb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiAoMCwgX3ZhbHVlRXF1YWwyLmRlZmF1bHQpKGEuc3RhdGUsIGIuc3RhdGUpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9Mb2NhdGlvblV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogJy8nLFxuICAgICAgdXJsOiAnLycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09ICcvJ1xuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcblxuXG4gICAgaW52YXJpYW50KGNoaWxkcmVuID09IG51bGwgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxLCAnQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50Jyk7XG5cbiAgICAvLyBEbyB0aGlzIGhlcmUgc28gd2UgY2FuIHNldFN0YXRlIHdoZW4gYSA8UmVkaXJlY3Q+IGNoYW5nZXMgdGhlXG4gICAgLy8gbG9jYXRpb24gaW4gY29tcG9uZW50V2lsbE1vdW50LiBUaGlzIGhhcHBlbnMgZS5nLiB3aGVuIGRvaW5nXG4gICAgLy8gc2VydmVyIHJlbmRlcmluZyB1c2luZyBhIDxTdGF0aWNSb3V0ZXI+LlxuICAgIHRoaXMudW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBtYXRjaDogX3RoaXMyLmNvbXB1dGVNYXRjaChoaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKHRoaXMucHJvcHMuaGlzdG9yeSA9PT0gbmV4dFByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+Jyk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJpbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gJ3BhdGgtdG8tcmVnZXhwJztcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVQYXRoID0gZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSAnJyArIG9wdGlvbnMuZW5kICsgb3B0aW9ucy5zdHJpY3QgKyBvcHRpb25zLnNlbnNpdGl2ZTtcbiAgdmFyIGNhY2hlID0gcGF0dGVybkNhY2hlW2NhY2hlS2V5XSB8fCAocGF0dGVybkNhY2hlW2NhY2hlS2V5XSA9IHt9KTtcblxuICBpZiAoY2FjaGVbcGF0dGVybl0pIHJldHVybiBjYWNoZVtwYXR0ZXJuXTtcblxuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgcmUgPSBwYXRoVG9SZWdleHAocGF0dGVybiwga2V5cywgb3B0aW9ucyk7XG4gIHZhciBjb21waWxlZFBhdHRlcm4gPSB7IHJlOiByZSwga2V5czoga2V5cyB9O1xuXG4gIGlmIChjYWNoZUNvdW50IDwgY2FjaGVMaW1pdCkge1xuICAgIGNhY2hlW3BhdHRlcm5dID0gY29tcGlsZWRQYXR0ZXJuO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb21waWxlZFBhdHRlcm47XG59O1xuXG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgVVJMIHBhdGhuYW1lIHRvIGEgcGF0aCBwYXR0ZXJuLlxuICovXG52YXIgbWF0Y2hQYXRoID0gZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdGhuYW1lKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSBvcHRpb25zID0geyBwYXRoOiBvcHRpb25zIH07XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBhdGggPSBfb3B0aW9ucy5wYXRoLFxuICAgICAgcGF0aCA9IF9vcHRpb25zJHBhdGggPT09IHVuZGVmaW5lZCA/ICcvJyA6IF9vcHRpb25zJHBhdGgsXG4gICAgICBfb3B0aW9ucyRleGFjdCA9IF9vcHRpb25zLmV4YWN0LFxuICAgICAgZXhhY3QgPSBfb3B0aW9ucyRleGFjdCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRleGFjdCxcbiAgICAgIF9vcHRpb25zJHN0cmljdCA9IF9vcHRpb25zLnN0cmljdCxcbiAgICAgIHN0cmljdCA9IF9vcHRpb25zJHN0cmljdCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzdHJpY3QsXG4gICAgICBfb3B0aW9ucyRzZW5zaXRpdmUgPSBfb3B0aW9ucy5zZW5zaXRpdmUsXG4gICAgICBzZW5zaXRpdmUgPSBfb3B0aW9ucyRzZW5zaXRpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc2Vuc2l0aXZlO1xuXG4gIHZhciBfY29tcGlsZVBhdGggPSBjb21waWxlUGF0aChwYXRoLCB7IGVuZDogZXhhY3QsIHN0cmljdDogc3RyaWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSxcbiAgICAgIHJlID0gX2NvbXBpbGVQYXRoLnJlLFxuICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gIHZhciBtYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgIHZhbHVlcyA9IG1hdGNoLnNsaWNlKDEpO1xuXG4gIHZhciBpc0V4YWN0ID0gcGF0aG5hbWUgPT09IHVybDtcblxuICBpZiAoZXhhY3QgJiYgIWlzRXhhY3QpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCwgLy8gdGhlIHBhdGggcGF0dGVybiB1c2VkIHRvIG1hdGNoXG4gICAgdXJsOiBwYXRoID09PSAnLycgJiYgdXJsID09PSAnJyA/ICcvJyA6IHVybCwgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgaXNFeGFjdDogaXNFeGFjdCwgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgcGFyYW1zOiBrZXlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5LCBpbmRleCkge1xuICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanMiLCJpbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJpbXBvcnQgUHJvdmlkZXIsIHsgY3JlYXRlUHJvdmlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBjb25uZWN0IGZyb20gJy4vY29ubmVjdC9jb25uZWN0JztcblxuZXhwb3J0IHsgUHJvdmlkZXIsIGNyZWF0ZVByb3ZpZGVyLCBjb25uZWN0QWR2YW5jZWQsIGNvbm5lY3QgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbnZhciBzZXRJdGVtO1xudmFyIGdldEl0ZW07XG52YXIgcmVtb3ZlSXRlbTtcbnZhciBnZXRJdGVtSURzO1xudmFyIGFkZFJvb3Q7XG52YXIgcmVtb3ZlUm9vdDtcbnZhciBnZXRSb290SURzO1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgdmFyIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHZhciByb290SURTZXQgPSBuZXcgU2V0KCk7XG5cbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfTtcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXQuYWRkKGlkKTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGl0ZW1CeUtleSA9IHt9O1xuICB2YXIgcm9vdEJ5S2V5ID0ge307XG5cbiAgLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgdmFyIGdldEtleUZyb21JRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiAnLicgKyBpZDtcbiAgfTtcbiAgdmFyIGdldElERnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xuICB9O1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1CeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG5cbiAgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICB2YXIgY2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuXG4gICAgcmVtb3ZlSXRlbShpZCk7XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcjZW1wdHknO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyN0ZXh0JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xuICB2YXIgbmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uY2hpbGRJRHMgPSBuZXh0Q2hpbGRJRHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHRDaGlsZElEID0gbmV4dENoaWxkSURzW2ldO1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldEl0ZW0obmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IGlkIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgICAgdGV4dDogbnVsbCxcbiAgICAgIGNoaWxkSURzOiBbXSxcbiAgICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgICB1cGRhdGVDb3VudDogMFxuICAgIH07XG4gICAgc2V0SXRlbShpZCwgaXRlbSk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKHRvcEVsZW1lbnQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0b3BFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKHRvcEVsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB3aGlsZSAoaWQpIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XG4gICAgICBpZCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNoaWxkSURzIDogW107XG4gIH0sXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xuICB9LFxuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XG4gIH0sXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG4gIGdldFRleHQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEcyxcbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0SXRlbUlEc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhVHlwZSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIGJUeXBlID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFWYWx1ZSA9IGEudmFsdWVPZigpO1xuICAgIHZhciBiVmFsdWUgPSBiLnZhbHVlT2YoKTtcblxuICAgIGlmIChhVmFsdWUgIT09IGEgfHwgYlZhbHVlICE9PSBiKSByZXR1cm4gdmFsdWVFcXVhbChhVmFsdWUsIGJWYWx1ZSk7XG5cbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciBnZXRDb25maXJtYXRpb24gPSBleHBvcnRzLmdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xudmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBleHBvcnRzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG52YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBleHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG52YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGV4cG9ydHMuaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvRE9NVXRpbHMuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbnZhciBpc01vZGlmaWVkRXZlbnQgPSBmdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cblxudmFyIExpbmsgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGluaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTGluaygpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmspO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykgX3RoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAvLyBvbkNsaWNrIHByZXZlbnRlZCBkZWZhdWx0XG4gICAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gaWdub3JlIHJpZ2h0IGNsaWNrc1xuICAgICAgIV90aGlzLnByb3BzLnRhcmdldCAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBfdGhpcyRwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICB0byA9IF90aGlzJHByb3BzLnRvO1xuXG5cbiAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIExpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVwbGFjZSA9IF9wcm9wcy5yZXBsYWNlLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydyZXBsYWNlJywgJ3RvJywgJ2lubmVyUmVmJ10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICB2YXIgaHJlZiA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5jcmVhdGVIcmVmKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB7IHBhdGhuYW1lOiB0byB9IDogdG8pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiwgcmVmOiBpbm5lclJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKVxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Sb3V0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3Igd2l0aFJvdXRlcigpIG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgdmFyIHJvdXRlID0gcm91dGVyLnJvdXRlO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gKGxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uKS5wYXRobmFtZTtcblxuICAgIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKHBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIHN0cmljdDogc3RyaWN0LCBleGFjdDogZXhhY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLnJlbmRlciAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJyBDaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyAnaXRcXCdzIGRlZmluZWQgaW4uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgdmFyIHN1YnNjcmlwdGlvblNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgdHJ5U3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgbm90aWZ5TmVzdGVkU3ViczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNTdWJzY3JpYmVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuZXhwb3J0IHZhciBzdG9yZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvUHJvcFR5cGVzLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5cbnZhciBob3RSZWxvYWRpbmdWZXJzaW9uID0gMDtcbnZhciBkdW1teVN0YXRlID0ge307XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIG1ha2VTZWxlY3RvclN0YXRlZnVsKHNvdXJjZVNlbGVjdG9yLCBzdG9yZSkge1xuICAvLyB3cmFwIHRoZSBzZWxlY3RvciBpbiBhbiBvYmplY3QgdGhhdCB0cmFja3MgaXRzIHJlc3VsdHMgYmV0d2VlbiBydW5zLlxuICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW5Db21wb25lbnRTZWxlY3Rvcihwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHNvdXJjZVNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgaWYgKG5leHRQcm9wcyAhPT0gc2VsZWN0b3IucHJvcHMgfHwgc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdG9yLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICAgIHNlbGVjdG9yLmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0QWR2YW5jZWQoXG4vKlxuICBzZWxlY3RvckZhY3RvcnkgaXMgYSBmdW5jIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0b1xuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcbiAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgIHRoaW5nOiBzdGF0ZS50aGluZ3NbcHJvcHMudGhpbmdJZF0sXG4gICAgICBzYXZlVGhpbmc6IGZpZWxkcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy5zYXZlVGhpbmcocHJvcHMudGhpbmdJZCwgZmllbGRzKSksXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXG4gICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcbiAgb3V0c2lkZSBvZiB0aGVpciBzZWxlY3RvciBhcyBhbiBvcHRpbWl6YXRpb24uIE9wdGlvbnMgcGFzc2VkIHRvIGNvbm5lY3RBZHZhbmNlZCBhcmUgcGFzc2VkIHRvXG4gIHRoZSBzZWxlY3RvckZhY3RvcnksIGFsb25nIHdpdGggZGlzcGxheU5hbWUgYW5kIFdyYXBwZWRDb21wb25lbnQsIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICBOb3RlIHRoYXQgc2VsZWN0b3JGYWN0b3J5IGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgY2FjaGluZy9tZW1vaXphdGlvbiBvZiBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcbiAgc2VsZWN0b3IsIG90aGVyd2lzZSB0aGUgQ29ubmVjdCBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgb24gZXZlcnkgc3RhdGUgb3IgcHJvcHMgY2hhbmdlLlxuKi9cbnNlbGVjdG9yRmFjdG9yeSkge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZ2V0RGlzcGxheU5hbWUgPSBfcmVmLmdldERpc3BsYXlOYW1lLFxuICAgICAgZ2V0RGlzcGxheU5hbWUgPSBfcmVmJGdldERpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnQ29ubmVjdEFkdmFuY2VkKCcgKyBuYW1lICsgJyknO1xuICB9IDogX3JlZiRnZXREaXNwbGF5TmFtZSxcbiAgICAgIF9yZWYkbWV0aG9kTmFtZSA9IF9yZWYubWV0aG9kTmFtZSxcbiAgICAgIG1ldGhvZE5hbWUgPSBfcmVmJG1ldGhvZE5hbWUgPT09IHVuZGVmaW5lZCA/ICdjb25uZWN0QWR2YW5jZWQnIDogX3JlZiRtZXRob2ROYW1lLFxuICAgICAgX3JlZiRyZW5kZXJDb3VudFByb3AgPSBfcmVmLnJlbmRlckNvdW50UHJvcCxcbiAgICAgIHJlbmRlckNvdW50UHJvcCA9IF9yZWYkcmVuZGVyQ291bnRQcm9wID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmVmJHJlbmRlckNvdW50UHJvcCxcbiAgICAgIF9yZWYkc2hvdWxkSGFuZGxlU3RhdCA9IF9yZWYuc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gX3JlZiRzaG91bGRIYW5kbGVTdGF0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRzaG91bGRIYW5kbGVTdGF0LFxuICAgICAgX3JlZiRzdG9yZUtleSA9IF9yZWYuc3RvcmVLZXksXG4gICAgICBzdG9yZUtleSA9IF9yZWYkc3RvcmVLZXkgPT09IHVuZGVmaW5lZCA/ICdzdG9yZScgOiBfcmVmJHN0b3JlS2V5LFxuICAgICAgX3JlZiR3aXRoUmVmID0gX3JlZi53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9yZWYkd2l0aFJlZiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHdpdGhSZWYsXG4gICAgICBjb25uZWN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2dldERpc3BsYXlOYW1lJywgJ21ldGhvZE5hbWUnLCAncmVuZGVyQ291bnRQcm9wJywgJ3Nob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcycsICdzdG9yZUtleScsICd3aXRoUmVmJ10pO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuICB2YXIgdmVyc2lvbiA9IGhvdFJlbG9hZGluZ1ZlcnNpb24rKztcblxuICB2YXIgY29udGV4dFR5cGVzID0gKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tzdG9yZUtleV0gPSBzdG9yZVNoYXBlLCBfY29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NvbnRleHRUeXBlcyk7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IChfY2hpbGRDb250ZXh0VHlwZXMgPSB7fSwgX2NoaWxkQ29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NoaWxkQ29udGV4dFR5cGVzKTtcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIFdyYXBwZWRDb21wb25lbnQgPT0gJ2Z1bmN0aW9uJywgJ1lvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5ICcgKyAoJ2Nvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KFdyYXBwZWRDb21wb25lbnQpKSk7XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHdyYXBwZWRDb21wb25lbnROYW1lKTtcblxuICAgIHZhciBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RPcHRpb25zLCB7XG4gICAgICBnZXREaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWUsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgcmVuZGVyQ291bnRQcm9wOiByZW5kZXJDb3VudFByb3AsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHN0b3JlS2V5OiBzdG9yZUtleSxcbiAgICAgIHdpdGhSZWY6IHdpdGhSZWYsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgQ29ubmVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoQ29ubmVjdCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHNbc3RvcmVLZXldIHx8IGNvbnRleHRbc3RvcmVLZXldO1xuICAgICAgICBfdGhpcy5wcm9wc01vZGUgPSBCb29sZWFuKHByb3BzW3N0b3JlS2V5XSk7XG4gICAgICAgIF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZSA9IF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZS5iaW5kKF90aGlzKTtcblxuICAgICAgICBpbnZhcmlhbnQoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcIicgKyBzdG9yZUtleSArICdcIiBpbiBlaXRoZXIgdGhlIGNvbnRleHQgb3IgcHJvcHMgb2YgJyArICgnXCInICsgZGlzcGxheU5hbWUgKyAnXCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcpICsgKCdvciBleHBsaWNpdGx5IHBhc3MgXCInICsgc3RvcmVLZXkgKyAnXCIgYXMgYSBwcm9wIHRvIFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICBfdGhpcy5pbml0U2VsZWN0b3IoKTtcbiAgICAgICAgX3RoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVkIHN0b3JlIGZyb20gcHJvcHMsIGl0cyBzdWJzY3JpcHRpb24gc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4gICAgICAgIC8vIHRvIGFueSBkZXNjZW5kYW50cyByZWNlaXZpbmcgc3RvcmUrc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dDsgaXQgcGFzc2VzIGFsb25nXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBwYXNzZWQgdG8gaXQuIE90aGVyd2lzZSwgaXQgc2hhZG93cyB0aGUgcGFyZW50IHN1YnNjcmlwdGlvbiwgd2hpY2ggYWxsb3dzXG4gICAgICAgIC8vIENvbm5lY3QgdG8gY29udHJvbCBvcmRlcmluZyBvZiBub3RpZmljYXRpb25zIHRvIGZsb3cgdG9wLWRvd24uXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnByb3BzTW9kZSA/IG51bGwgOiB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb24gfHwgdGhpcy5jb250ZXh0W3N1YnNjcmlwdGlvbktleV0sIF9yZWYyO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjtcblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZmlyZXMgZHVyaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgYnV0IGNvbXBvbmVudERpZE1vdW50IGFuZFxuICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBkbyBub3QuIEJlY2F1c2Ugb2YgdGhpcywgdHJ5U3Vic2NyaWJlIGhhcHBlbnMgZHVyaW5nIC4uLmRpZE1vdW50LlxuICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3Vic2NyaXB0aW9uIHdvdWxkIG5ldmVyIHRha2UgcGxhY2UgZHVyaW5nIFNTUiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBUbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjb21wb25lbnQgbWF5IGhhdmUgdHJpZ2dlcmVkIGEgc3RhdGUgY2hhbmdlIGJ5XG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIGFuIGFjdGlvbiBpbiBpdHMgY29tcG9uZW50V2lsbE1vdW50LCB3ZSBoYXZlIHRvIHJlLXJ1biB0aGUgc2VsZWN0IGFuZCBtYXliZVxuICAgICAgICAvLyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4obmV4dFByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1biA9IG5vb3A7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgIGludmFyaWFudCh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAoJ3sgd2l0aFJlZjogdHJ1ZSB9IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IG9mIHRoZSAnICsgbWV0aG9kTmFtZSArICcoKSBjYWxsLicpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gc2V0V3JhcHBlZEluc3RhbmNlKHJlZikge1xuICAgICAgICB0aGlzLndyYXBwZWRJbnN0YW5jZSA9IHJlZjtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTZWxlY3RvciA9IGZ1bmN0aW9uIGluaXRTZWxlY3RvcigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdG9yID0gc2VsZWN0b3JGYWN0b3J5KHRoaXMuc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBpbml0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHBhcmVudFN1YidzIHNvdXJjZSBzaG91bGQgbWF0Y2ggd2hlcmUgc3RvcmUgY2FtZSBmcm9tOiBwcm9wcyB2cy4gY29udGV4dC4gQSBjb21wb25lbnRcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIHRoZSBzdG9yZSB2aWEgcHJvcHMgc2hvdWxkbid0IHVzZSBzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0LCBvciB2aWNlIHZlcnNhLlxuICAgICAgICB2YXIgcGFyZW50U3ViID0gKHRoaXMucHJvcHNNb2RlID8gdGhpcy5wcm9wcyA6IHRoaXMuY29udGV4dClbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc3RvcmUsIHBhcmVudFN1YiwgdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGBub3RpZnlOZXN0ZWRTdWJzYCBpcyBkdXBsaWNhdGVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29tcG9uZW50IGlzICB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGB0aGlzLnN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIEFuXG4gICAgICAgIC8vIGV4dHJhIG51bGwgY2hlY2sgZXZlcnkgY2hhbmdlIGNhbiBiZSBhdm9pZGVkIGJ5IGNvcHlpbmcgdGhlIG1ldGhvZCBvbnRvIGB0aGlzYCBhbmQgdGhlblxuICAgICAgICAvLyByZXBsYWNpbmcgaXQgd2l0aCBhIG5vLW9wIG9uIHVubW91bnQuIFRoaXMgY2FuIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3NcbiAgICAgICAgLy8gbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGVcbiAgICAgICAgLy8gbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gdGhpcy5zdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHRoaXMuc3Vic2NyaXB0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB0aGlzLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKGR1bW15U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGBjb21wb25lbnREaWRVcGRhdGVgIGlzIGNvbmRpdGlvbmFsbHkgaW1wbGVtZW50ZWQgd2hlbiBgb25TdGF0ZUNoYW5nZWAgZGV0ZXJtaW5lcyBpdFxuICAgICAgICAvLyBuZWVkcyB0byBub3RpZnkgbmVzdGVkIHN1YnMuIE9uY2UgY2FsbGVkLCBpdCB1bmltcGxlbWVudHMgaXRzZWxmIHVudGlsIGZ1cnRoZXIgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlcyBvY2N1ci4gRG9pbmcgaXQgdGhpcyB3YXkgdnMgaGF2aW5nIGEgcGVybWFuZW50IGBjb21wb25lbnREaWRVcGRhdGVgIHRoYXQgZG9lc1xuICAgICAgICAvLyBhIGJvb2xlYW4gY2hlY2sgZXZlcnkgdGltZSBhdm9pZHMgYW4gZXh0cmEgbWV0aG9kIGNhbGwgbW9zdCBvZiB0aGUgdGltZSwgcmVzdWx0aW5nXG4gICAgICAgIC8vIGluIHNvbWUgcGVyZiBib29zdC5cbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN1YnNjcmlwdGlvbikgJiYgdGhpcy5zdWJzY3JpcHRpb24uaXNTdWJzY3JpYmVkKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5hZGRFeHRyYVByb3BzID0gZnVuY3Rpb24gYWRkRXh0cmFQcm9wcyhwcm9wcykge1xuICAgICAgICBpZiAoIXdpdGhSZWYgJiYgIXJlbmRlckNvdW50UHJvcCAmJiAhKHRoaXMucHJvcHNNb2RlICYmIHRoaXMuc3Vic2NyaXB0aW9uKSkgcmV0dXJuIHByb3BzO1xuICAgICAgICAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5IHNvIHRoYXQgZmllbGRzIGFkZGVkIGRvbid0IGxlYWsgdG8gdGhlIG9yaWdpbmFsIHNlbGVjdG9yLlxuICAgICAgICAvLyB0aGlzIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IGZvciAncmVmJyBzaW5jZSB0aGF0J3MgYSByZWZlcmVuY2UgYmFjayB0byB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGluc3RhbmNlLiBhIHNpbmdsZXRvbiBtZW1vaXplZCBzZWxlY3RvciB3b3VsZCB0aGVuIGJlIGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAgICAgIC8vIGluc3RhbmNlLCBwcmV2ZW50aW5nIHRoZSBpbnN0YW5jZSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWRcbiAgICAgICAgdmFyIHdpdGhFeHRyYXMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMpO1xuICAgICAgICBpZiAod2l0aFJlZikgd2l0aEV4dHJhcy5yZWYgPSB0aGlzLnNldFdyYXBwZWRJbnN0YW5jZTtcbiAgICAgICAgaWYgKHJlbmRlckNvdW50UHJvcCkgd2l0aEV4dHJhc1tyZW5kZXJDb3VudFByb3BdID0gdGhpcy5yZW5kZXJDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pIHdpdGhFeHRyYXNbc3Vic2NyaXB0aW9uS2V5XSA9IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gd2l0aEV4dHJhcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc2VsZWN0b3IuZXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5hZGRFeHRyYVByb3BzKHNlbGVjdG9yLnByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb25uZWN0O1xuICAgIH0oQ29tcG9uZW50KTtcblxuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIENvbm5lY3QuY2hpbGRDb250ZXh0VHlwZXMgPSBjaGlsZENvbnRleHRUeXBlcztcbiAgICBDb25uZWN0LmNvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlcztcbiAgICBDb25uZWN0LnByb3BUeXBlcyA9IGNvbnRleHRUeXBlcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2UgYXJlIGhvdCByZWxvYWRpbmchXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIHRoaXMuaW5pdFNlbGVjdG9yKCk7XG5cbiAgICAgICAgICAvLyBJZiBhbnkgY29ubmVjdGVkIGRlc2NlbmRhbnRzIGRvbid0IGhvdCByZWxvYWQgKGFuZCByZXN1YnNjcmliZSBpbiB0aGUgcHJvY2VzcyksIHRoZWlyXG4gICAgICAgICAgLy8gbGlzdGVuZXJzIHdpbGwgYmUgbG9zdCB3aGVuIHdlIHVuc3Vic2NyaWJlLiBVbmZvcnR1bmF0ZWx5LCBieSBjb3B5aW5nIG92ZXIgYWxsXG4gICAgICAgICAgLy8gbGlzdGVuZXJzLCB0aGlzIGRvZXMgbWVhbiB0aGF0IHRoZSBvbGQgdmVyc2lvbnMgb2YgY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmVcbiAgICAgICAgICAvLyBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzOyBob3dldmVyLCB0aGVpciBvblN0YXRlQ2hhbmdlIGZ1bmN0aW9uIGlzIGEgbm8tb3Agc28gdGhpc1xuICAgICAgICAgIC8vIGlzbid0IGEgaHVnZSBkZWFsLlxuICAgICAgICAgIHZhciBvbGRMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgb2xkTGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLmdldCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zdWJzY3JpcHRpb24ubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0ICQkb2JzZXJ2YWJsZSBmcm9tICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG5leHBvcnQgdmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZlskJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwiLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbXBvc2UuanMiLCJpbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCwgb3B0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5cbi8vIGRlcGVuZHNPbk93blByb3BzIGlzIHVzZWQgYnkgY3JlYXRlTWFwVG9Qcm9wc1Byb3h5IHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHBhc3MgcHJvcHMgYXMgYXJnc1xuLy8gdG8gdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgd3JhcHBlZC4gSXQgaXMgYWxzbyB1c2VkIGJ5IG1ha2VQdXJlUHJvcHNTZWxlY3RvciB0byBkZXRlcm1pbmVcbi8vIHdoZXRoZXIgbWFwVG9Qcm9wcyBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gcHJvcHMgaGF2ZSBjaGFuZ2VkLlxuLy8gXG4vLyBBIGxlbmd0aCBvZiBvbmUgc2lnbmFscyB0aGF0IG1hcFRvUHJvcHMgZG9lcyBub3QgZGVwZW5kIG9uIHByb3BzIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQuXG4vLyBBIGxlbmd0aCBvZiB6ZXJvIGlzIGFzc3VtZWQgdG8gbWVhbiBtYXBUb1Byb3BzIGlzIGdldHRpbmcgYXJncyB2aWEgYXJndW1lbnRzIG9yIC4uLmFyZ3MgYW5kXG4vLyB0aGVyZWZvcmUgbm90IHJlcG9ydGluZyBpdHMgbGVuZ3RoIGFjY3VyYXRlbHkuLlxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IG51bGwgJiYgbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gdW5kZWZpbmVkID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuXG4vLyBVc2VkIGJ5IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uIGFuZCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbixcbi8vIHRoaXMgZnVuY3Rpb24gd3JhcHMgbWFwVG9Qcm9wcyBpbiBhIHByb3h5IGZ1bmN0aW9uIHdoaWNoIGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4vLyBcbi8vICAqIERldGVjdHMgd2hldGhlciB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyBjYWxsZWQgZGVwZW5kcyBvbiBwcm9wcywgd2hpY2hcbi8vICAgIGlzIHVzZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHRvIGRlY2lkZSBpZiBpdCBzaG91bGQgcmVpbnZva2Ugb24gcHJvcHMgY2hhbmdlcy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgaGFuZGxlcyBtYXBUb1Byb3BzIGlmIHJldHVybnMgYW5vdGhlciBmdW5jdGlvbiwgYW5kIHRyZWF0cyB0aGF0XG4vLyAgICBuZXcgZnVuY3Rpb24gYXMgdGhlIHRydWUgbWFwVG9Qcm9wcyBmb3Igc3Vic2VxdWVudCBjYWxscy5cbi8vICAgIFxuLy8gICogT24gZmlyc3QgY2FsbCwgdmVyaWZpZXMgdGhlIGZpcnN0IHJlc3VsdCBpcyBhIHBsYWluIG9iamVjdCwgaW4gb3JkZXIgdG8gd2FyblxuLy8gICAgdGhlIGRldmVsb3BlciB0aGF0IHRoZWlyIG1hcFRvUHJvcHMgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBhIHZhbGlkIHJlc3VsdC5cbi8vICAgIFxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWU7XG5cbiAgICB2YXIgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICB2YXIgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcblxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGRpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAnICsgdmFsdWUgKyAnLicpO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC5qcyIsImltcG9ydCAgUmVhY3QgIGZyb20gJ3JlYWN0JztcbmltcG9ydCAgUmVhY3RET00gIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCAgQXBwICBmcm9tICcuL2NvbXBvbmVudHMvQXBwLmpzJztcblxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3Njc3MvYXBwbGljYXRpb24uc2Nzcyc7XG52YXIgYWFhID0gMTIzO1xuXG5cblJlYWN0RE9NLnJlbmRlcihcbiAgPEFwcCBuPXthYWF9Lz4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jylcbik7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbGllbnQvaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7dmFyIG09cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksbj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxyPXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyx0PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCx1PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LHY9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsdz1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LHg9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24geShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsYz0wO2M8YjtjKyspZSs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtiPUVycm9yKGUrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fVxudmFyIHo9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319O2Z1bmN0aW9uIEEoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1BLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0EucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT95KFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07QS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07XG5mdW5jdGlvbiBCKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9ZnVuY3Rpb24gQygpe31DLnByb3RvdHlwZT1BLnByb3RvdHlwZTt2YXIgRD1CLnByb3RvdHlwZT1uZXcgQztELmNvbnN0cnVjdG9yPUI7bShELEEucHJvdG90eXBlKTtELmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en12YXIgRj1FLnByb3RvdHlwZT1uZXcgQztGLmNvbnN0cnVjdG9yPUU7bShGLEEucHJvdG90eXBlKTtGLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD0hMDtGLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNoaWxkcmVufTt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsZSl7dmFyIGMsZD17fSxnPW51bGwsaz1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihrPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilILmNhbGwoYixjKSYmIUkuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgaD1BcnJheShmKSxsPTA7bDxmO2wrKyloW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49aH1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZFtjXSYmKGRbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLGtleTpnLHJlZjprLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19ZnVuY3Rpb24gSyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cn1cbmZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIEw9L1xcLysvZyxNPVtdO2Z1bmN0aW9uIE4oYSxiLGUsYyl7aWYoTS5sZW5ndGgpe3ZhciBkPU0ucG9wKCk7ZC5yZXN1bHQ9YTtkLmtleVByZWZpeD1iO2QuZnVuYz1lO2QuY29udGV4dD1jO2QuY291bnQ9MDtyZXR1cm4gZH1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzplLGNvbnRleHQ6Yyxjb3VudDowfX1mdW5jdGlvbiBPKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+TS5sZW5ndGgmJk0ucHVzaChhKX1cbmZ1bmN0aW9uIFAoYSxiLGUsYyl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHI6Y2FzZSB0OmNhc2UgdTpjYXNlIHY6Zz0hMH19aWYoZylyZXR1cm4gZShjLGEsXCJcIj09PWI/XCIuXCIrUShhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaz0wO2s8YS5sZW5ndGg7aysrKXtkPWFba107dmFyIGY9YitRKGQsayk7Zys9UChkLGYsZSxjKX1lbHNlIGlmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/Zj1udWxsOihmPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1cbmYuY2FsbChhKSxrPTA7IShkPWEubmV4dCgpKS5kb25lOylkPWQudmFsdWUsZj1iK1EoZCxrKyspLGcrPVAoZCxmLGUsYyk7ZWxzZVwib2JqZWN0XCI9PT1kJiYoZT1cIlwiK2EseShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWU/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZSxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gUShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gUihhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBTKGEsYixlKXt2YXIgYz1hLnJlc3VsdCxkPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1QoYSxjLGUscC50aGF0UmV0dXJuc0FyZ3VtZW50KTpudWxsIT1hJiYoSyhhKSYmKGI9ZCsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpK2UsYT17JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6YixyZWY6YS5yZWYscHJvcHM6YS5wcm9wcyxfb3duZXI6YS5fb3duZXJ9KSxjLnB1c2goYSkpfWZ1bmN0aW9uIFQoYSxiLGUsYyxkKXt2YXIgZz1cIlwiO251bGwhPWUmJihnPShcIlwiK2UpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpO2I9TihiLGcsYyxkKTtudWxsPT1hfHxQKGEsXCJcIixTLGIpO08oYil9XG52YXIgVT17Q2hpbGRyZW46e21hcDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgYz1bXTtUKGEsYyxudWxsLGIsZSk7cmV0dXJuIGN9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1OKG51bGwsbnVsbCxiLGUpO251bGw9PWF8fFAoYSxcIlwiLFIsYik7TyhiKX0sY291bnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/MDpQKGEsXCJcIixwLnRoYXRSZXR1cm5zTnVsbCxudWxsKX0sdG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj1bXTtUKGEsYixudWxsLHAudGhhdFJldHVybnNBcmd1bWVudCk7cmV0dXJuIGJ9LG9ubHk6ZnVuY3Rpb24oYSl7SyhhKT92b2lkIDA6eShcIjE0M1wiKTtyZXR1cm4gYX19LENvbXBvbmVudDpBLFB1cmVDb21wb25lbnQ6Qix1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDpFLEZyYWdtZW50OncsY3JlYXRlRWxlbWVudDpKLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZSl7dmFyIGM9bSh7fSxhLnByb3BzKSxcbmQ9YS5rZXksZz1hLnJlZixrPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoZz1iLnJlZixrPUcuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihkPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZj1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihoIGluIGIpSC5jYWxsKGIsaCkmJiFJLmhhc093blByb3BlcnR5KGgpJiYoY1toXT12b2lkIDA9PT1iW2hdJiZ2b2lkIDAhPT1mP2ZbaF06YltoXSl9dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1oKWMuY2hpbGRyZW49ZTtlbHNlIGlmKDE8aCl7Zj1BcnJheShoKTtmb3IodmFyIGw9MDtsPGg7bCsrKWZbbF09YXJndW1lbnRzW2wrMl07Yy5jaGlsZHJlbj1mfXJldHVybnskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpkLHJlZjpnLHByb3BzOmMsX293bmVyOmt9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPUouYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxcbmlzVmFsaWRFbGVtZW50OkssdmVyc2lvbjpcIjE2LjIuMFwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpHLGFzc2lnbjptfX0sVj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlV9KSxXPVYmJlV8fFY7bW9kdWxlLmV4cG9ydHM9V1tcImRlZmF1bHRcIl0/V1tcImRlZmF1bHRcIl06VztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxsPXJlcXVpcmUoXCJmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKSxCPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLEM9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIiksYmE9cmVxdWlyZShcImZianMvbGliL0V2ZW50TGlzdGVuZXJcIiksZGE9cmVxdWlyZShcImZianMvbGliL2dldEFjdGl2ZUVsZW1lbnRcIiksZWE9cmVxdWlyZShcImZianMvbGliL3NoYWxsb3dFcXVhbFwiKSxmYT1yZXF1aXJlKFwiZmJqcy9saWIvY29udGFpbnNOb2RlXCIpLGlhPXJlcXVpcmUoXCJmYmpzL2xpYi9mb2N1c05vZGVcIiksRD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIik7XG5mdW5jdGlvbiBFKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsYz1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxkPTA7ZDxiO2QrKyljKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2QrMV0pO2I9RXJyb3IoYytcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9YWE/dm9pZCAwOkUoXCIyMjdcIik7XG52YXIgb2E9e2NoaWxkcmVuOiEwLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiEwLGRlZmF1bHRWYWx1ZTohMCxkZWZhdWx0Q2hlY2tlZDohMCxpbm5lckhUTUw6ITAsc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiEwLHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzohMCxzdHlsZTohMH07ZnVuY3Rpb24gcGEoYSxiKXtyZXR1cm4oYSZiKT09PWJ9XG52YXIgdGE9e01VU1RfVVNFX1BST1BFUlRZOjEsSEFTX0JPT0xFQU5fVkFMVUU6NCxIQVNfTlVNRVJJQ19WQUxVRTo4LEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOjI0LEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6MzIsSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOjY0LGluamVjdERPTVByb3BlcnR5Q29uZmlnOmZ1bmN0aW9uKGEpe3ZhciBiPXRhLGM9YS5Qcm9wZXJ0aWVzfHx7fSxkPWEuRE9NQXR0cmlidXRlTmFtZXNwYWNlc3x8e30sZT1hLkRPTUF0dHJpYnV0ZU5hbWVzfHx7fTthPWEuRE9NTXV0YXRpb25NZXRob2RzfHx7fTtmb3IodmFyIGYgaW4gYyl7dWEuaGFzT3duUHJvcGVydHkoZik/RShcIjQ4XCIsZik6dm9pZCAwO3ZhciBnPWYudG9Mb3dlckNhc2UoKSxoPWNbZl07Zz17YXR0cmlidXRlTmFtZTpnLGF0dHJpYnV0ZU5hbWVzcGFjZTpudWxsLHByb3BlcnR5TmFtZTpmLG11dGF0aW9uTWV0aG9kOm51bGwsbXVzdFVzZVByb3BlcnR5OnBhKGgsYi5NVVNUX1VTRV9QUk9QRVJUWSksXG5oYXNCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19CT09MRUFOX1ZBTFVFKSxoYXNOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19OVU1FUklDX1ZBTFVFKSxoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpwYShoLGIuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKX07MT49Zy5oYXNCb29sZWFuVmFsdWUrZy5oYXNOdW1lcmljVmFsdWUrZy5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlP3ZvaWQgMDpFKFwiNTBcIixmKTtlLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lPWVbZl0pO2QuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWVzcGFjZT1kW2ZdKTthLmhhc093blByb3BlcnR5KGYpJiYoZy5tdXRhdGlvbk1ldGhvZD1hW2ZdKTt1YVtmXT1nfX19LHVhPXt9O1xuZnVuY3Rpb24gdmEoYSxiKXtpZihvYS5oYXNPd25Qcm9wZXJ0eShhKXx8MjxhLmxlbmd0aCYmKFwib1wiPT09YVswXXx8XCJPXCI9PT1hWzBdKSYmKFwiblwiPT09YVsxXXx8XCJOXCI9PT1hWzFdKSlyZXR1cm4hMTtpZihudWxsPT09YilyZXR1cm4hMDtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJib29sZWFuXCI6cmV0dXJuIG9hLmhhc093blByb3BlcnR5KGEpP2E9ITA6KGI9d2EoYSkpP2E9Yi5oYXNCb29sZWFuVmFsdWV8fGIuaGFzU3RyaW5nQm9vbGVhblZhbHVlfHxiLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6KGE9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSksYT1cImRhdGEtXCI9PT1hfHxcImFyaWEtXCI9PT1hKSxhO2Nhc2UgXCJ1bmRlZmluZWRcIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJvYmplY3RcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB3YShhKXtyZXR1cm4gdWEuaGFzT3duUHJvcGVydHkoYSk/dWFbYV06bnVsbH1cbnZhciB4YT10YSx5YT14YS5NVVNUX1VTRV9QUk9QRVJUWSxLPXhhLkhBU19CT09MRUFOX1ZBTFVFLHphPXhhLkhBU19OVU1FUklDX1ZBTFVFLEFhPXhhLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLEJhPXhhLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsQ2E9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLERhPXtQcm9wZXJ0aWVzOnthbGxvd0Z1bGxTY3JlZW46Syxhc3luYzpLLGF1dG9Gb2N1czpLLGF1dG9QbGF5OkssY2FwdHVyZTpCYSxjaGVja2VkOnlhfEssY29sczpBYSxjb250ZW50RWRpdGFibGU6Q2EsY29udHJvbHM6SyxcImRlZmF1bHRcIjpLLGRlZmVyOkssZGlzYWJsZWQ6Syxkb3dubG9hZDpCYSxkcmFnZ2FibGU6Q2EsZm9ybU5vVmFsaWRhdGU6SyxoaWRkZW46Syxsb29wOkssbXVsdGlwbGU6eWF8SyxtdXRlZDp5YXxLLG5vVmFsaWRhdGU6SyxvcGVuOksscGxheXNJbmxpbmU6SyxyZWFkT25seTpLLHJlcXVpcmVkOksscmV2ZXJzZWQ6Syxyb3dzOkFhLHJvd1NwYW46emEsXG5zY29wZWQ6SyxzZWFtbGVzczpLLHNlbGVjdGVkOnlhfEssc2l6ZTpBYSxzdGFydDp6YSxzcGFuOkFhLHNwZWxsQ2hlY2s6Q2Esc3R5bGU6MCx0YWJJbmRleDowLGl0ZW1TY29wZTpLLGFjY2VwdENoYXJzZXQ6MCxjbGFzc05hbWU6MCxodG1sRm9yOjAsaHR0cEVxdWl2OjAsdmFsdWU6Q2F9LERPTUF0dHJpYnV0ZU5hbWVzOnthY2NlcHRDaGFyc2V0OlwiYWNjZXB0LWNoYXJzZXRcIixjbGFzc05hbWU6XCJjbGFzc1wiLGh0bWxGb3I6XCJmb3JcIixodHRwRXF1aXY6XCJodHRwLWVxdWl2XCJ9LERPTU11dGF0aW9uTWV0aG9kczp7dmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXJldHVybiBhLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1wibnVtYmVyXCIhPT1hLnR5cGV8fCExPT09YS5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKTphLnZhbGlkaXR5JiYhYS52YWxpZGl0eS5iYWRJbnB1dCYmYS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT1hJiZcbmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpfX19LEVhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxNPXt4bGluazpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIix4bWw6XCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIn0sR2E9e1Byb3BlcnRpZXM6e2F1dG9SZXZlcnNlOkVhLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6RWEscHJlc2VydmVBbHBoYTpFYX0sRE9NQXR0cmlidXRlTmFtZXM6e2F1dG9SZXZlcnNlOlwiYXV0b1JldmVyc2VcIixleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOlwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLHByZXNlcnZlQWxwaGE6XCJwcmVzZXJ2ZUFscGhhXCJ9LERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6e3hsaW5rQWN0dWF0ZTpNLnhsaW5rLHhsaW5rQXJjcm9sZTpNLnhsaW5rLHhsaW5rSHJlZjpNLnhsaW5rLHhsaW5rUm9sZTpNLnhsaW5rLHhsaW5rU2hvdzpNLnhsaW5rLHhsaW5rVGl0bGU6TS54bGluayx4bGlua1R5cGU6TS54bGluayxcbnhtbEJhc2U6TS54bWwseG1sTGFuZzpNLnhtbCx4bWxTcGFjZTpNLnhtbH19LEhhPS9bXFwtXFw6XShbYS16XSkvZztmdW5jdGlvbiBJYShhKXtyZXR1cm4gYVsxXS50b1VwcGVyQ2FzZSgpfVxuXCJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4LWhlaWdodCB4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6aHJlZiB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZSB4bWw6YmFzZSB4bWxuczp4bGluayB4bWw6bGFuZyB4bWw6c3BhY2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoSGEsXG5JYSk7R2EuUHJvcGVydGllc1tiXT0wO0dhLkRPTUF0dHJpYnV0ZU5hbWVzW2JdPWF9KTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhEYSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoR2EpO1xudmFyIFA9e19jYXVnaHRFcnJvcjpudWxsLF9oYXNDYXVnaHRFcnJvcjohMSxfcmV0aHJvd0Vycm9yOm51bGwsX2hhc1JldGhyb3dFcnJvcjohMSxpbmplY3Rpb246e2luamVjdEVycm9yVXRpbHM6ZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGEuaW52b2tlR3VhcmRlZENhbGxiYWNrP0UoXCIxOTdcIik6dm9pZCAwO0phPWEuaW52b2tlR3VhcmRlZENhbGxiYWNrfX0saW52b2tlR3VhcmRlZENhbGxiYWNrOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtKYS5hcHBseShQLGFyZ3VtZW50cyl9LGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKFAuaGFzQ2F1Z2h0RXJyb3IoKSl7dmFyIHE9UC5jbGVhckNhdWdodEVycm9yKCk7UC5faGFzUmV0aHJvd0Vycm9yfHwoUC5faGFzUmV0aHJvd0Vycm9yPSEwLFAuX3JldGhyb3dFcnJvcj1cbnEpfX0scmV0aHJvd0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIEthLmFwcGx5KFAsYXJndW1lbnRzKX0saGFzQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gUC5faGFzQ2F1Z2h0RXJyb3J9LGNsZWFyQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtpZihQLl9oYXNDYXVnaHRFcnJvcil7dmFyIGE9UC5fY2F1Z2h0RXJyb3I7UC5fY2F1Z2h0RXJyb3I9bnVsbDtQLl9oYXNDYXVnaHRFcnJvcj0hMTtyZXR1cm4gYX1FKFwiMTk4XCIpfX07ZnVuY3Rpb24gSmEoYSxiLGMsZCxlLGYsZyxoLGspe1AuX2hhc0NhdWdodEVycm9yPSExO1AuX2NhdWdodEVycm9yPW51bGw7dmFyIHE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMscSl9Y2F0Y2godil7UC5fY2F1Z2h0RXJyb3I9dixQLl9oYXNDYXVnaHRFcnJvcj0hMH19XG5mdW5jdGlvbiBLYSgpe2lmKFAuX2hhc1JldGhyb3dFcnJvcil7dmFyIGE9UC5fcmV0aHJvd0Vycm9yO1AuX3JldGhyb3dFcnJvcj1udWxsO1AuX2hhc1JldGhyb3dFcnJvcj0hMTt0aHJvdyBhO319dmFyIExhPW51bGwsTWE9e307XG5mdW5jdGlvbiBOYSgpe2lmKExhKWZvcih2YXIgYSBpbiBNYSl7dmFyIGI9TWFbYV0sYz1MYS5pbmRleE9mKGEpOy0xPGM/dm9pZCAwOkUoXCI5NlwiLGEpO2lmKCFPYVtjXSl7Yi5leHRyYWN0RXZlbnRzP3ZvaWQgMDpFKFwiOTdcIixhKTtPYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO1BhLmhhc093blByb3BlcnR5KGgpP0UoXCI5OVwiLGgpOnZvaWQgMDtQYVtoXT1mO3ZhciBrPWYucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYoayl7Zm9yKGUgaW4gaylrLmhhc093blByb3BlcnR5KGUpJiZRYShrW2VdLGcsaCk7ZT0hMH1lbHNlIGYucmVnaXN0cmF0aW9uTmFtZT8oUWEoZi5yZWdpc3RyYXRpb25OYW1lLGcsaCksZT0hMCk6ZT0hMTtlP3ZvaWQgMDpFKFwiOThcIixkLGEpfX19fVxuZnVuY3Rpb24gUWEoYSxiLGMpe1JhW2FdP0UoXCIxMDBcIixhKTp2b2lkIDA7UmFbYV09YjtTYVthXT1iLmV2ZW50VHlwZXNbY10uZGVwZW5kZW5jaWVzfXZhciBPYT1bXSxQYT17fSxSYT17fSxTYT17fTtmdW5jdGlvbiBUYShhKXtMYT9FKFwiMTAxXCIpOnZvaWQgMDtMYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtOYSgpfWZ1bmN0aW9uIFVhKGEpe3ZhciBiPSExLGM7Zm9yKGMgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1hW2NdO01hLmhhc093blByb3BlcnR5KGMpJiZNYVtjXT09PWR8fChNYVtjXT9FKFwiMTAyXCIsYyk6dm9pZCAwLE1hW2NdPWQsYj0hMCl9YiYmTmEoKX1cbnZhciBWYT1PYmplY3QuZnJlZXplKHtwbHVnaW5zOk9hLGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczpQYSxyZWdpc3RyYXRpb25OYW1lTW9kdWxlczpSYSxyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOlNhLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6bnVsbCxpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX0pLFdhPW51bGwsWGE9bnVsbCxZYT1udWxsO2Z1bmN0aW9uIFphKGEsYixjLGQpe2I9YS50eXBlfHxcInVua25vd24tZXZlbnRcIjthLmN1cnJlbnRUYXJnZXQ9WWEoZCk7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IoYixjLHZvaWQgMCxhKTthLmN1cnJlbnRUYXJnZXQ9bnVsbH1cbmZ1bmN0aW9uICRhKGEsYil7bnVsbD09Yj9FKFwiMzBcIik6dm9pZCAwO2lmKG51bGw9PWEpcmV0dXJuIGI7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoQXJyYXkuaXNBcnJheShiKSlyZXR1cm4gYS5wdXNoLmFwcGx5KGEsYiksYTthLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/W2FdLmNvbmNhdChiKTpbYSxiXX1mdW5jdGlvbiBhYihhLGIsYyl7QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goYixjKTphJiZiLmNhbGwoYyxhKX12YXIgYmI9bnVsbDtcbmZ1bmN0aW9uIGNiKGEsYil7aWYoYSl7dmFyIGM9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsZD1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZSsrKVphKGEsYixjW2VdLGRbZV0pO2Vsc2UgYyYmWmEoYSxiLGMsZCk7YS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbDthLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsO2EuaXNQZXJzaXN0ZW50KCl8fGEuY29uc3RydWN0b3IucmVsZWFzZShhKX19ZnVuY3Rpb24gZGIoYSl7cmV0dXJuIGNiKGEsITApfWZ1bmN0aW9uIGdiKGEpe3JldHVybiBjYihhLCExKX12YXIgaGI9e2luamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfTtcbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoIWMpcmV0dXJuIG51bGw7dmFyIGQ9V2EoYyk7aWYoIWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGM/RShcIjIzMVwiLGIsdHlwZW9mIGMpOnZvaWQgMDtcbnJldHVybiBjfWZ1bmN0aW9uIGpiKGEsYixjLGQpe2Zvcih2YXIgZSxmPTA7ZjxPYS5sZW5ndGg7ZisrKXt2YXIgZz1PYVtmXTtnJiYoZz1nLmV4dHJhY3RFdmVudHMoYSxiLGMsZCkpJiYoZT0kYShlLGcpKX1yZXR1cm4gZX1mdW5jdGlvbiBrYihhKXthJiYoYmI9JGEoYmIsYSkpfWZ1bmN0aW9uIGxiKGEpe3ZhciBiPWJiO2JiPW51bGw7YiYmKGE/YWIoYixkYik6YWIoYixnYiksYmI/RShcIjk1XCIpOnZvaWQgMCxQLnJldGhyb3dDYXVnaHRFcnJvcigpKX12YXIgbWI9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOmhiLGdldExpc3RlbmVyOmliLGV4dHJhY3RFdmVudHM6amIsZW5xdWV1ZUV2ZW50czprYixwcm9jZXNzRXZlbnRRdWV1ZTpsYn0pLG5iPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFE9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIituYixvYj1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK25iO1xuZnVuY3Rpb24gcGIoYSl7aWYoYVtRXSlyZXR1cm4gYVtRXTtmb3IodmFyIGI9W107IWFbUV07KWlmKGIucHVzaChhKSxhLnBhcmVudE5vZGUpYT1hLnBhcmVudE5vZGU7ZWxzZSByZXR1cm4gbnVsbDt2YXIgYz12b2lkIDAsZD1hW1FdO2lmKDU9PT1kLnRhZ3x8Nj09PWQudGFnKXJldHVybiBkO2Zvcig7YSYmKGQ9YVtRXSk7YT1iLnBvcCgpKWM9ZDtyZXR1cm4gY31mdW5jdGlvbiBxYihhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7RShcIjMzXCIpfWZ1bmN0aW9uIHJiKGEpe3JldHVybiBhW29iXXx8bnVsbH1cbnZhciBzYj1PYmplY3QuZnJlZXplKHtwcmVjYWNoZUZpYmVyTm9kZTpmdW5jdGlvbihhLGIpe2JbUV09YX0sZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6cGIsZ2V0SW5zdGFuY2VGcm9tTm9kZTpmdW5jdGlvbihhKXthPWFbUV07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnP251bGw6YX0sZ2V0Tm9kZUZyb21JbnN0YW5jZTpxYixnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOnJiLHVwZGF0ZUZpYmVyUHJvcHM6ZnVuY3Rpb24oYSxiKXthW29iXT1ifX0pO2Z1bmN0aW9uIHRiKGEpe2RvIGE9YVtcInJldHVyblwiXTt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1mdW5jdGlvbiB1YihhLGIsYyl7Zm9yKHZhciBkPVtdO2E7KWQucHVzaChhKSxhPXRiKGEpO2ZvcihhPWQubGVuZ3RoOzA8YS0tOyliKGRbYV0sXCJjYXB0dXJlZFwiLGMpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspYihkW2FdLFwiYnViYmxlZFwiLGMpfVxuZnVuY3Rpb24gdmIoYSxiLGMpe2lmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiB3YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzJiZ1YihhLl90YXJnZXRJbnN0LHZiLGEpfWZ1bmN0aW9uIHhiKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe3ZhciBiPWEuX3RhcmdldEluc3Q7Yj1iP3RiKGIpOm51bGw7dWIoYix2YixhKX19XG5mdW5jdGlvbiB5YihhLGIsYyl7YSYmYyYmYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYoYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSkpfWZ1bmN0aW9uIHpiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmeWIoYS5fdGFyZ2V0SW5zdCxudWxsLGEpfWZ1bmN0aW9uIEFiKGEpe2FiKGEsd2IpfVxuZnVuY3Rpb24gQmIoYSxiLGMsZCl7aWYoYyYmZClhOnt2YXIgZT1jO2Zvcih2YXIgZj1kLGc9MCxoPWU7aDtoPXRiKGgpKWcrKztoPTA7Zm9yKHZhciBrPWY7aztrPXRiKGspKWgrKztmb3IoOzA8Zy1oOyllPXRiKGUpLGctLTtmb3IoOzA8aC1nOylmPXRiKGYpLGgtLTtmb3IoO2ctLTspe2lmKGU9PT1mfHxlPT09Zi5hbHRlcm5hdGUpYnJlYWsgYTtlPXRiKGUpO2Y9dGIoZil9ZT1udWxsfWVsc2UgZT1udWxsO2Y9ZTtmb3IoZT1bXTtjJiZjIT09Zjspe2c9Yy5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2UucHVzaChjKTtjPXRiKGMpfWZvcihjPVtdO2QmJmQhPT1mOyl7Zz1kLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7Yy5wdXNoKGQpO2Q9dGIoZCl9Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl5YihlW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihhPWMubGVuZ3RoOzA8YS0tOyl5YihjW2FdLFwiY2FwdHVyZWRcIixiKX1cbnZhciBDYj1PYmplY3QuZnJlZXplKHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOkFiLGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OmZ1bmN0aW9uKGEpe2FiKGEseGIpfSxhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6QmIsYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6ZnVuY3Rpb24oYSl7YWIoYSx6Yil9fSksRGI9bnVsbDtmdW5jdGlvbiBFYigpeyFEYiYmbC5jYW5Vc2VET00mJihEYj1cInRleHRDb250ZW50XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/XCJ0ZXh0Q29udGVudFwiOlwiaW5uZXJUZXh0XCIpO3JldHVybiBEYn12YXIgUz17X3Jvb3Q6bnVsbCxfc3RhcnRUZXh0Om51bGwsX2ZhbGxiYWNrVGV4dDpudWxsfTtcbmZ1bmN0aW9uIEZiKCl7aWYoUy5fZmFsbGJhY2tUZXh0KXJldHVybiBTLl9mYWxsYmFja1RleHQ7dmFyIGEsYj1TLl9zdGFydFRleHQsYz1iLmxlbmd0aCxkLGU9R2IoKSxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO1MuX2ZhbGxiYWNrVGV4dD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApO3JldHVybiBTLl9mYWxsYmFja1RleHR9ZnVuY3Rpb24gR2IoKXtyZXR1cm5cInZhbHVlXCJpbiBTLl9yb290P1MuX3Jvb3QudmFsdWU6Uy5fcm9vdFtFYigpXX1cbnZhciBIYj1cImRpc3BhdGNoQ29uZmlnIF90YXJnZXRJbnN0IG5hdGl2ZUV2ZW50IGlzRGVmYXVsdFByZXZlbnRlZCBpc1Byb3BhZ2F0aW9uU3RvcHBlZCBfZGlzcGF0Y2hMaXN0ZW5lcnMgX2Rpc3BhdGNoSW5zdGFuY2VzXCIuc3BsaXQoXCIgXCIpLEliPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpDLnRoYXRSZXR1cm5zTnVsbCxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuZnVuY3Rpb24gVChhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/Qy50aGF0UmV0dXJuc1RydWU6Qy50aGF0UmV0dXJuc0ZhbHNlO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc0ZhbHNlO3JldHVybiB0aGlzfVxuQihULnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPUMudGhhdFJldHVybnNUcnVlKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNUcnVlKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PUMudGhhdFJldHVybnNUcnVlfSxpc1BlcnNpc3RlbnQ6Qy50aGF0UmV0dXJuc0ZhbHNlLFxuZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLGI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7Zm9yKGE9MDthPEhiLmxlbmd0aDthKyspdGhpc1tIYlthXV09bnVsbH19KTtULkludGVyZmFjZT1JYjtULmF1Z21lbnRDbGFzcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7dmFyIGQ9bmV3IGM7QihkLGEucHJvdG90eXBlKTthLnByb3RvdHlwZT1kO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5JbnRlcmZhY2U9Qih7fSx0aGlzLkludGVyZmFjZSxiKTthLmF1Z21lbnRDbGFzcz10aGlzLmF1Z21lbnRDbGFzcztKYihhKX07SmIoVCk7ZnVuY3Rpb24gS2IoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9XG5mdW5jdGlvbiBMYihhKXthIGluc3RhbmNlb2YgdGhpcz92b2lkIDA6RShcIjIyM1wiKTthLmRlc3RydWN0b3IoKTsxMD50aGlzLmV2ZW50UG9vbC5sZW5ndGgmJnRoaXMuZXZlbnRQb29sLnB1c2goYSl9ZnVuY3Rpb24gSmIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9S2I7YS5yZWxlYXNlPUxifWZ1bmN0aW9uIE1iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhNYix7ZGF0YTpudWxsfSk7ZnVuY3Rpb24gTmIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE5iLHtkYXRhOm51bGx9KTt2YXIgUGI9WzksMTMsMjcsMzJdLFZiPWwuY2FuVXNlRE9NJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxXYj1udWxsO2wuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihXYj1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBYYjtcbmlmKFhiPWwuY2FuVXNlRE9NJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhV2Ipe3ZhciBZYj13aW5kb3cub3BlcmE7WGI9IShcIm9iamVjdFwiPT09dHlwZW9mIFliJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgWWIudmVyc2lvbiYmMTI+PXBhcnNlSW50KFliLnZlcnNpb24oKSwxMCkpfVxudmFyIFpiPVhiLCRiPWwuY2FuVXNlRE9NJiYoIVZifHxXYiYmODxXYiYmMTE+PVdiKSxhYz1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxiYz17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcInRvcENvbXBvc2l0aW9uRW5kXCIsXCJ0b3BLZXlQcmVzc1wiLFwidG9wVGV4dElucHV0XCIsXCJ0b3BQYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvbkVuZCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uU3RhcnQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25VcGRhdGUgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9fSxjYz0hMTtcbmZ1bmN0aW9uIGRjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlVcFwiOnJldHVybi0xIT09UGIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJ0b3BLZXlEb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwidG9wS2V5UHJlc3NcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcEJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBlYyhhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBmYz0hMTtmdW5jdGlvbiBnYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gZWMoYik7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2NjPSEwO3JldHVybiBhYztjYXNlIFwidG9wVGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT1hYyYmY2M/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gaGMoYSxiKXtpZihmYylyZXR1cm5cInRvcENvbXBvc2l0aW9uRW5kXCI9PT1hfHwhVmImJmRjKGEsYik/KGE9RmIoKSxTLl9yb290PW51bGwsUy5fc3RhcnRUZXh0PW51bGwsUy5fZmFsbGJhY2tUZXh0PW51bGwsZmM9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcFBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuICRiP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGljPXtldmVudFR5cGVzOmJjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoVmIpYjp7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvblN0YXJ0XCI6dmFyIGY9YmMuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOmY9YmMuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25VcGRhdGVcIjpmPWJjLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBmYz9kYyhhLGMpJiYoZj1iYy5jb21wb3NpdGlvbkVuZCk6XCJ0b3BLZXlEb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPWJjLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KCRiJiYoZmN8fGYhPT1iYy5jb21wb3NpdGlvblN0YXJ0P2Y9PT1iYy5jb21wb3NpdGlvbkVuZCYmZmMmJihlPUZiKCkpOihTLl9yb290PWQsUy5fc3RhcnRUZXh0PUdiKCksZmM9ITApKSxmPU1iLmdldFBvb2xlZChmLGIsYyxkKSxlP2YuZGF0YT1cbmU6KGU9ZWMoYyksbnVsbCE9PWUmJihmLmRhdGE9ZSkpLEFiKGYpLGU9Zik6ZT1udWxsOyhhPVpiP2djKGEsYyk6aGMoYSxjKSk/KGI9TmIuZ2V0UG9vbGVkKGJjLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSxBYihiKSk6Yj1udWxsO3JldHVybltlLGJdfX0samM9bnVsbCxrYz1udWxsLGxjPW51bGw7ZnVuY3Rpb24gbWMoYSl7aWYoYT1YYShhKSl7amMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlP3ZvaWQgMDpFKFwiMTk0XCIpO3ZhciBiPVdhKGEuc3RhdGVOb2RlKTtqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19dmFyIG5jPXtpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe2pjPWF9fTtmdW5jdGlvbiBvYyhhKXtrYz9sYz9sYy5wdXNoKGEpOmxjPVthXTprYz1hfVxuZnVuY3Rpb24gcGMoKXtpZihrYyl7dmFyIGE9a2MsYj1sYztsYz1rYz1udWxsO21jKGEpO2lmKGIpZm9yKGE9MDthPGIubGVuZ3RoO2ErKyltYyhiW2FdKX19dmFyIHFjPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpuYyxlbnF1ZXVlU3RhdGVSZXN0b3JlOm9jLHJlc3RvcmVTdGF0ZUlmTmVlZGVkOnBjfSk7ZnVuY3Rpb24gcmMoYSxiKXtyZXR1cm4gYShiKX12YXIgc2M9ITE7ZnVuY3Rpb24gdGMoYSxiKXtpZihzYylyZXR1cm4gcmMoYSxiKTtzYz0hMDt0cnl7cmV0dXJuIHJjKGEsYil9ZmluYWxseXtzYz0hMSxwYygpfX12YXIgdWM9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07XG5mdW5jdGlvbiB2YyhhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIXVjW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiB3YyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHhjO2wuY2FuVXNlRE9NJiYoeGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUmJiEwIT09ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLFwiXCIpKTtcbmZ1bmN0aW9uIHljKGEsYil7aWYoIWwuY2FuVXNlRE9NfHxiJiYhKFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZG9jdW1lbnQpKXJldHVybiExO2I9XCJvblwiK2E7dmFyIGM9YiBpbiBkb2N1bWVudDtjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuc2V0QXR0cmlidXRlKGIsXCJyZXR1cm47XCIpLGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNbYl0pOyFjJiZ4YyYmXCJ3aGVlbFwiPT09YSYmKGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLFwiMy4wXCIpKTtyZXR1cm4gY31mdW5jdGlvbiB6YyhhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gQWMoYSl7dmFyIGI9emMoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXQuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2Muc2V0LmNhbGwodGhpcyxhKX19KSx7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1udWxsO2RlbGV0ZSBhW2JdfX19XG5mdW5jdGlvbiBCYyhhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9QWMoYSkpfWZ1bmN0aW9uIENjKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD16YyhhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfXZhciBEYz17Y2hhbmdlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ2hhbmdlXCIsY2FwdHVyZWQ6XCJvbkNoYW5nZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDaGFuZ2UgdG9wQ2xpY2sgdG9wRm9jdXMgdG9wSW5wdXQgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fTtcbmZ1bmN0aW9uIEVjKGEsYixjKXthPVQuZ2V0UG9vbGVkKERjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7b2MoYyk7QWIoYSk7cmV0dXJuIGF9dmFyIEZjPW51bGwsR2M9bnVsbDtmdW5jdGlvbiBIYyhhKXtrYihhKTtsYighMSl9ZnVuY3Rpb24gSWMoYSl7dmFyIGI9cWIoYSk7aWYoQ2MoYikpcmV0dXJuIGF9ZnVuY3Rpb24gSmMoYSxiKXtpZihcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgS2M9ITE7bC5jYW5Vc2VET00mJihLYz15YyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBMYygpe0ZjJiYoRmMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpLEdjPUZjPW51bGwpfWZ1bmN0aW9uIE1jKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZJYyhHYykmJihhPUVjKEdjLGEsd2MoYSkpLHRjKEhjLGEpKX1cbmZ1bmN0aW9uIE5jKGEsYixjKXtcInRvcEZvY3VzXCI9PT1hPyhMYygpLEZjPWIsR2M9YyxGYy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYykpOlwidG9wQmx1clwiPT09YSYmTGMoKX1mdW5jdGlvbiBPYyhhKXtpZihcInRvcFNlbGVjdGlvbkNoYW5nZVwiPT09YXx8XCJ0b3BLZXlVcFwiPT09YXx8XCJ0b3BLZXlEb3duXCI9PT1hKXJldHVybiBJYyhHYyl9ZnVuY3Rpb24gUGMoYSxiKXtpZihcInRvcENsaWNrXCI9PT1hKXJldHVybiBJYyhiKX1mdW5jdGlvbiAkYyhhLGIpe2lmKFwidG9wSW5wdXRcIj09PWF8fFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBJYyhiKX1cbnZhciBhZD17ZXZlbnRUeXBlczpEYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOktjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9xYihiKTp3aW5kb3csZj1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWZ8fFwiaW5wdXRcIj09PWYmJlwiZmlsZVwiPT09ZS50eXBlKXZhciBnPUpjO2Vsc2UgaWYodmMoZSkpaWYoS2MpZz0kYztlbHNle2c9T2M7dmFyIGg9TmN9ZWxzZSBmPWUubm9kZU5hbWUsIWZ8fFwiaW5wdXRcIiE9PWYudG9Mb3dlckNhc2UoKXx8XCJjaGVja2JveFwiIT09ZS50eXBlJiZcInJhZGlvXCIhPT1lLnR5cGV8fChnPVBjKTtpZihnJiYoZz1nKGEsYikpKXJldHVybiBFYyhnLGMsZCk7aCYmaChhLGUsYik7XCJ0b3BCbHVyXCI9PT1hJiZudWxsIT1iJiYoYT1iLl93cmFwcGVyU3RhdGV8fGUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmKGE9XCJcIitlLnZhbHVlLGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikhPT1cbmEmJmUuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSl9fTtmdW5jdGlvbiBiZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmQse3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pO3ZhciBjZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gZGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1jZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIGVkKCl7cmV0dXJuIGRkfWZ1bmN0aW9uIGZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhmZCx7c2NyZWVuWDpudWxsLHNjcmVlblk6bnVsbCxjbGllbnRYOm51bGwsY2xpZW50WTpudWxsLHBhZ2VYOm51bGwscGFnZVk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxidXR0b246bnVsbCxidXR0b25zOm51bGwscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWxhdGVkVGFyZ2V0fHwoYS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KX19KTtcbnZhciBnZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19fSxoZD17ZXZlbnRUeXBlczpnZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKFwidG9wTW91c2VPdmVyXCI9PT1hJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8XCJ0b3BNb3VzZU91dFwiIT09YSYmXCJ0b3BNb3VzZU92ZXJcIiE9PWEpcmV0dXJuIG51bGw7dmFyIGU9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7XCJ0b3BNb3VzZU91dFwiPT09YT8oYT1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/cGIoYik6bnVsbCk6YT1udWxsO2lmKGE9PT1cbmIpcmV0dXJuIG51bGw7dmFyIGY9bnVsbD09YT9lOnFiKGEpO2U9bnVsbD09Yj9lOnFiKGIpO3ZhciBnPWZkLmdldFBvb2xlZChnZC5tb3VzZUxlYXZlLGEsYyxkKTtnLnR5cGU9XCJtb3VzZWxlYXZlXCI7Zy50YXJnZXQ9ZjtnLnJlbGF0ZWRUYXJnZXQ9ZTtjPWZkLmdldFBvb2xlZChnZC5tb3VzZUVudGVyLGIsYyxkKTtjLnR5cGU9XCJtb3VzZWVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9ZjtCYihnLGMsYSxiKTtyZXR1cm5bZyxjXX19LGlkPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIGpkKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfVxuZnVuY3Rpb24ga2QoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2JbXCJyZXR1cm5cIl07KWI9YltcInJldHVyblwiXTtlbHNle2lmKDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDE7Zm9yKDtiW1wicmV0dXJuXCJdOylpZihiPWJbXCJyZXR1cm5cIl0sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBsZChhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1rZChhKTohMX1mdW5jdGlvbiBtZChhKXsyIT09a2QoYSk/RShcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBuZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1rZChhKSwzPT09Yj9FKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWNbXCJyZXR1cm5cIl0sZj1lP2UuYWx0ZXJuYXRlOm51bGw7aWYoIWV8fCFmKWJyZWFrO2lmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IodmFyIGc9ZS5jaGlsZDtnOyl7aWYoZz09PWMpcmV0dXJuIG1kKGUpLGE7aWYoZz09PWQpcmV0dXJuIG1kKGUpLGI7Zz1nLnNpYmxpbmd9RShcIjE4OFwiKX1pZihjW1wicmV0dXJuXCJdIT09ZFtcInJldHVyblwiXSljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9Zz9cbnZvaWQgMDpFKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/RShcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP0UoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gb2QoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHBkKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCYmNCE9PWIudGFnKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH12YXIgcWQ9W107XG5mdW5jdGlvbiByZChhKXt2YXIgYj1hLnRhcmdldEluc3Q7ZG97aWYoIWIpe2EuYW5jZXN0b3JzLnB1c2goYik7YnJlYWt9dmFyIGM7Zm9yKGM9YjtjW1wicmV0dXJuXCJdOyljPWNbXCJyZXR1cm5cIl07Yz0zIT09Yy50YWc/bnVsbDpjLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKCFjKWJyZWFrO2EuYW5jZXN0b3JzLnB1c2goYik7Yj1wYihjKX13aGlsZShiKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyliPWEuYW5jZXN0b3JzW2NdLHNkKGEudG9wTGV2ZWxUeXBlLGIsYS5uYXRpdmVFdmVudCx3YyhhLm5hdGl2ZUV2ZW50KSl9dmFyIHRkPSEwLHNkPXZvaWQgMDtmdW5jdGlvbiB1ZChhKXt0ZD0hIWF9ZnVuY3Rpb24gVShhLGIsYyl7cmV0dXJuIGM/YmEubGlzdGVuKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9ZnVuY3Rpb24gd2QoYSxiLGMpe3JldHVybiBjP2JhLmNhcHR1cmUoYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1cbmZ1bmN0aW9uIHZkKGEsYil7aWYodGQpe3ZhciBjPXdjKGIpO2M9cGIoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1rZChjKXx8KGM9bnVsbCk7aWYocWQubGVuZ3RoKXt2YXIgZD1xZC5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXt0YyhyZCxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPnFkLmxlbmd0aCYmcWQucHVzaChhKX19fVxudmFyIHhkPU9iamVjdC5mcmVlemUoe2dldCBfZW5hYmxlZCgpe3JldHVybiB0ZH0sZ2V0IF9oYW5kbGVUb3BMZXZlbCgpe3JldHVybiBzZH0sc2V0SGFuZGxlVG9wTGV2ZWw6ZnVuY3Rpb24oYSl7c2Q9YX0sc2V0RW5hYmxlZDp1ZCxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGR9LHRyYXBCdWJibGVkRXZlbnQ6VSx0cmFwQ2FwdHVyZWRFdmVudDp3ZCxkaXNwYXRjaEV2ZW50OnZkfSk7ZnVuY3Rpb24geWQoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtjW1wibXNcIithXT1cIk1TXCIrYjtjW1wiT1wiK2FdPVwib1wiK2IudG9Mb3dlckNhc2UoKTtyZXR1cm4gY31cbnZhciB6ZD17YW5pbWF0aW9uZW5kOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6eWQoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSxBZD17fSxCZD17fTtsLmNhblVzZURPTSYmKEJkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIHpkLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIHpkLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG5mdW5jdGlvbiBDZChhKXtpZihBZFthXSlyZXR1cm4gQWRbYV07aWYoIXpkW2FdKXJldHVybiBhO3ZhciBiPXpkW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIEJkKXJldHVybiBBZFthXT1iW2NdO3JldHVyblwiXCJ9XG52YXIgRGQ9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BBbmltYXRpb25FbmQ6Q2QoXCJhbmltYXRpb25lbmRcIil8fFwiYW5pbWF0aW9uZW5kXCIsdG9wQW5pbWF0aW9uSXRlcmF0aW9uOkNkKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpfHxcImFuaW1hdGlvbml0ZXJhdGlvblwiLHRvcEFuaW1hdGlvblN0YXJ0OkNkKFwiYW5pbWF0aW9uc3RhcnRcIil8fFwiYW5pbWF0aW9uc3RhcnRcIix0b3BCbHVyOlwiYmx1clwiLHRvcENhbmNlbDpcImNhbmNlbFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcENoYW5nZTpcImNoYW5nZVwiLHRvcENsaWNrOlwiY2xpY2tcIix0b3BDbG9zZTpcImNsb3NlXCIsdG9wQ29tcG9zaXRpb25FbmQ6XCJjb21wb3NpdGlvbmVuZFwiLHRvcENvbXBvc2l0aW9uU3RhcnQ6XCJjb21wb3NpdGlvbnN0YXJ0XCIsdG9wQ29tcG9zaXRpb25VcGRhdGU6XCJjb21wb3NpdGlvbnVwZGF0ZVwiLHRvcENvbnRleHRNZW51OlwiY29udGV4dG1lbnVcIix0b3BDb3B5OlwiY29weVwiLFxudG9wQ3V0OlwiY3V0XCIsdG9wRG91YmxlQ2xpY2s6XCJkYmxjbGlja1wiLHRvcERyYWc6XCJkcmFnXCIsdG9wRHJhZ0VuZDpcImRyYWdlbmRcIix0b3BEcmFnRW50ZXI6XCJkcmFnZW50ZXJcIix0b3BEcmFnRXhpdDpcImRyYWdleGl0XCIsdG9wRHJhZ0xlYXZlOlwiZHJhZ2xlYXZlXCIsdG9wRHJhZ092ZXI6XCJkcmFnb3ZlclwiLHRvcERyYWdTdGFydDpcImRyYWdzdGFydFwiLHRvcERyb3A6XCJkcm9wXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BGb2N1czpcImZvY3VzXCIsdG9wSW5wdXQ6XCJpbnB1dFwiLHRvcEtleURvd246XCJrZXlkb3duXCIsdG9wS2V5UHJlc3M6XCJrZXlwcmVzc1wiLHRvcEtleVVwOlwia2V5dXBcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWQ6XCJsb2FkXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLFxudG9wTW91c2VEb3duOlwibW91c2Vkb3duXCIsdG9wTW91c2VNb3ZlOlwibW91c2Vtb3ZlXCIsdG9wTW91c2VPdXQ6XCJtb3VzZW91dFwiLHRvcE1vdXNlT3ZlcjpcIm1vdXNlb3ZlclwiLHRvcE1vdXNlVXA6XCJtb3VzZXVwXCIsdG9wUGFzdGU6XCJwYXN0ZVwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Nyb2xsOlwic2Nyb2xsXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTZWxlY3Rpb25DaGFuZ2U6XCJzZWxlY3Rpb25jaGFuZ2VcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGV4dElucHV0OlwidGV4dElucHV0XCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BUb2dnbGU6XCJ0b2dnbGVcIix0b3BUb3VjaENhbmNlbDpcInRvdWNoY2FuY2VsXCIsdG9wVG91Y2hFbmQ6XCJ0b3VjaGVuZFwiLHRvcFRvdWNoTW92ZTpcInRvdWNobW92ZVwiLFxudG9wVG91Y2hTdGFydDpcInRvdWNoc3RhcnRcIix0b3BUcmFuc2l0aW9uRW5kOkNkKFwidHJhbnNpdGlvbmVuZFwiKXx8XCJ0cmFuc2l0aW9uZW5kXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsdG9wV2FpdGluZzpcIndhaXRpbmdcIix0b3BXaGVlbDpcIndoZWVsXCJ9LEVkPXt9LEZkPTAsR2Q9XCJfcmVhY3RMaXN0ZW5lcnNJRFwiKyhcIlwiK01hdGgucmFuZG9tKCkpLnNsaWNlKDIpO2Z1bmN0aW9uIEhkKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLEdkKXx8KGFbR2RdPUZkKyssRWRbYVtHZF1dPXt9KTtyZXR1cm4gRWRbYVtHZF1dfWZ1bmN0aW9uIElkKGEpe2Zvcig7YSYmYS5maXJzdENoaWxkOylhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX1cbmZ1bmN0aW9uIEpkKGEsYil7dmFyIGM9SWQoYSk7YT0wO2Zvcih2YXIgZDtjOyl7aWYoMz09PWMubm9kZVR5cGUpe2Q9YStjLnRleHRDb250ZW50Lmxlbmd0aDtpZihhPD1iJiZkPj1iKXJldHVybntub2RlOmMsb2Zmc2V0OmItYX07YT1kfWE6e2Zvcig7Yzspe2lmKGMubmV4dFNpYmxpbmcpe2M9Yy5uZXh0U2libGluZzticmVhayBhfWM9Yy5wYXJlbnROb2RlfWM9dm9pZCAwfWM9SWQoYyl9fWZ1bmN0aW9uIEtkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJlwidGV4dFwiPT09YS50eXBlfHxcInRleHRhcmVhXCI9PT1ifHxcInRydWVcIj09PWEuY29udGVudEVkaXRhYmxlKX1cbnZhciBMZD1sLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLE1kPXtzZWxlY3Q6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25TZWxlY3RcIixjYXB0dXJlZDpcIm9uU2VsZWN0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbnRleHRNZW51IHRvcEZvY3VzIHRvcEtleURvd24gdG9wS2V5VXAgdG9wTW91c2VEb3duIHRvcE1vdXNlVXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sTmQ9bnVsbCxPZD1udWxsLFBkPW51bGwsUWQ9ITE7XG5mdW5jdGlvbiBSZChhLGIpe2lmKFFkfHxudWxsPT1OZHx8TmQhPT1kYSgpKXJldHVybiBudWxsO3ZhciBjPU5kO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJktkKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTp3aW5kb3cuZ2V0U2VsZWN0aW9uPyhjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjPXthbmNob3JOb2RlOmMuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6Yy5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmMuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmMuZm9jdXNPZmZzZXR9KTpjPXZvaWQgMDtyZXR1cm4gUGQmJmVhKFBkLGMpP251bGw6KFBkPWMsYT1ULmdldFBvb2xlZChNZC5zZWxlY3QsT2QsYSxiKSxhLnR5cGU9XCJzZWxlY3RcIixhLnRhcmdldD1OZCxBYihhKSxhKX1cbnZhciBTZD17ZXZlbnRUeXBlczpNZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50LGY7aWYoIShmPSFlKSl7YTp7ZT1IZChlKTtmPVNhLm9uU2VsZWN0O2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddO2lmKCFlLmhhc093blByb3BlcnR5KGgpfHwhZVtoXSl7ZT0hMTticmVhayBhfX1lPSEwfWY9IWV9aWYoZilyZXR1cm4gbnVsbDtlPWI/cWIoYik6d2luZG93O3N3aXRjaChhKXtjYXNlIFwidG9wRm9jdXNcIjppZih2YyhlKXx8XCJ0cnVlXCI9PT1lLmNvbnRlbnRFZGl0YWJsZSlOZD1lLE9kPWIsUGQ9bnVsbDticmVhaztjYXNlIFwidG9wQmx1clwiOlBkPU9kPU5kPW51bGw7YnJlYWs7Y2FzZSBcInRvcE1vdXNlRG93blwiOlFkPSEwO2JyZWFrO2Nhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6cmV0dXJuIFFkPSExLFJkKGMsZCk7Y2FzZSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiOmlmKExkKWJyZWFrO1xuY2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4gUmQoYyxkKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIFRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhUZCx7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7ZnVuY3Rpb24gVWQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFVkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSk7ZnVuY3Rpb24gVmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhWZCx7cmVsYXRlZFRhcmdldDpudWxsfSk7XG5mdW5jdGlvbiBXZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciBYZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sWWQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9O2Z1bmN0aW9uIFpkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhaZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1YZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1XZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/WWRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9XZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP1dkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSk7ZnVuY3Rpb24gJGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcygkZCx7ZGF0YVRyYW5zZmVyOm51bGx9KTtmdW5jdGlvbiBhZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKGFlLHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWR9KTtmdW5jdGlvbiBiZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmUse3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7XG5mdW5jdGlvbiBjZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKGNlLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pO3ZhciBkZT17fSxlZT17fTtcblwiYWJvcnQgYW5pbWF0aW9uRW5kIGFuaW1hdGlvbkl0ZXJhdGlvbiBhbmltYXRpb25TdGFydCBibHVyIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRvdWJsZUNsaWNrIGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGZvY3VzIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgc2Nyb2xsIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b2dnbGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hNb3ZlIHRvdWNoU3RhcnQgdHJhbnNpdGlvbkVuZCB2b2x1bWVDaGFuZ2Ugd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0udG9VcHBlckNhc2UoKStcbmEuc2xpY2UoMSksYz1cIm9uXCIrYjtiPVwidG9wXCIrYjtjPXtwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpjLGNhcHR1cmVkOmMrXCJDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbYl19O2RlW2FdPWM7ZWVbYl09Y30pO1xudmFyIGZlPXtldmVudFR5cGVzOmRlLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZWVbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDA9PT1XZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOmE9WmQ7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpjYXNlIFwidG9wRm9jdXNcIjphPVZkO2JyZWFrO2Nhc2UgXCJ0b3BDbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwidG9wRG91YmxlQ2xpY2tcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcE1vdXNlTW92ZVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6Y2FzZSBcInRvcE1vdXNlT3V0XCI6Y2FzZSBcInRvcE1vdXNlT3ZlclwiOmNhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmE9ZmQ7YnJlYWs7Y2FzZSBcInRvcERyYWdcIjpjYXNlIFwidG9wRHJhZ0VuZFwiOmNhc2UgXCJ0b3BEcmFnRW50ZXJcIjpjYXNlIFwidG9wRHJhZ0V4aXRcIjpjYXNlIFwidG9wRHJhZ0xlYXZlXCI6Y2FzZSBcInRvcERyYWdPdmVyXCI6Y2FzZSBcInRvcERyYWdTdGFydFwiOmNhc2UgXCJ0b3BEcm9wXCI6YT1cbiRkO2JyZWFrO2Nhc2UgXCJ0b3BUb3VjaENhbmNlbFwiOmNhc2UgXCJ0b3BUb3VjaEVuZFwiOmNhc2UgXCJ0b3BUb3VjaE1vdmVcIjpjYXNlIFwidG9wVG91Y2hTdGFydFwiOmE9YWU7YnJlYWs7Y2FzZSBcInRvcEFuaW1hdGlvbkVuZFwiOmNhc2UgXCJ0b3BBbmltYXRpb25JdGVyYXRpb25cIjpjYXNlIFwidG9wQW5pbWF0aW9uU3RhcnRcIjphPVRkO2JyZWFrO2Nhc2UgXCJ0b3BUcmFuc2l0aW9uRW5kXCI6YT1iZTticmVhaztjYXNlIFwidG9wU2Nyb2xsXCI6YT1iZDticmVhaztjYXNlIFwidG9wV2hlZWxcIjphPWNlO2JyZWFrO2Nhc2UgXCJ0b3BDb3B5XCI6Y2FzZSBcInRvcEN1dFwiOmNhc2UgXCJ0b3BQYXN0ZVwiOmE9VWQ7YnJlYWs7ZGVmYXVsdDphPVR9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTtBYihiKTtyZXR1cm4gYn19O3NkPWZ1bmN0aW9uKGEsYixjLGQpe2E9amIoYSxiLGMsZCk7a2IoYSk7bGIoITEpfTtoYi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gVGFwRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO1xuV2E9c2IuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtYYT1zYi5nZXRJbnN0YW5jZUZyb21Ob2RlO1lhPXNiLmdldE5vZGVGcm9tSW5zdGFuY2U7aGIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjpmZSxFbnRlckxlYXZlRXZlbnRQbHVnaW46aGQsQ2hhbmdlRXZlbnRQbHVnaW46YWQsU2VsZWN0RXZlbnRQbHVnaW46U2QsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjppY30pO3ZhciBnZT1bXSxoZT0tMTtmdW5jdGlvbiBWKGEpezA+aGV8fChhLmN1cnJlbnQ9Z2VbaGVdLGdlW2hlXT1udWxsLGhlLS0pfWZ1bmN0aW9uIFcoYSxiKXtoZSsrO2dlW2hlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9bmV3IFNldDt2YXIgaWU9e2N1cnJlbnQ6RH0sWD17Y3VycmVudDohMX0samU9RDtmdW5jdGlvbiBrZShhKXtyZXR1cm4gbGUoYSk/amU6aWUuY3VycmVudH1cbmZ1bmN0aW9uIG1lKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gRDt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBsZShhKXtyZXR1cm4gMj09PWEudGFnJiZudWxsIT1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXN9ZnVuY3Rpb24gbmUoYSl7bGUoYSkmJihWKFgsYSksVihpZSxhKSl9XG5mdW5jdGlvbiBvZShhLGIsYyl7bnVsbCE9aWUuY3Vyc29yP0UoXCIxNjhcIik6dm9pZCAwO1coaWUsYixhKTtXKFgsYyxhKX1mdW5jdGlvbiBwZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlLGQ9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldENoaWxkQ29udGV4dClyZXR1cm4gYjtjPWMuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGMpZSBpbiBkP3ZvaWQgMDpFKFwiMTA4XCIsamQoYSl8fFwiVW5rbm93blwiLGUpO3JldHVybiBCKHt9LGIsYyl9ZnVuY3Rpb24gcWUoYSl7aWYoIWxlKGEpKXJldHVybiExO3ZhciBiPWEuc3RhdGVOb2RlO2I9YiYmYi5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8RDtqZT1pZS5jdXJyZW50O1coaWUsYixhKTtXKFgsWC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gcmUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtjP3ZvaWQgMDpFKFwiMTY5XCIpO2lmKGIpe3ZhciBkPXBlKGEsamUpO2MuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZDtWKFgsYSk7VihpZSxhKTtXKGllLGQsYSl9ZWxzZSBWKFgsYSk7VyhYLGIsYSl9XG5mdW5jdGlvbiBZKGEsYixjKXt0aGlzLnRhZz1hO3RoaXMua2V5PWI7dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpc1tcInJldHVyblwiXT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9dGhpcy5wZW5kaW5nUHJvcHM9dGhpcy5yZWY9bnVsbDt0aGlzLmludGVybmFsQ29udGV4dFRhZz1jO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9XG5mdW5jdGlvbiBzZShhLGIsYyl7dmFyIGQ9YS5hbHRlcm5hdGU7bnVsbD09PWQ/KGQ9bmV3IFkoYS50YWcsYS5rZXksYS5pbnRlcm5hbENvbnRleHRUYWcpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5lZmZlY3RUYWc9MCxkLm5leHRFZmZlY3Q9bnVsbCxkLmZpcnN0RWZmZWN0PW51bGwsZC5sYXN0RWZmZWN0PW51bGwpO2QuZXhwaXJhdGlvblRpbWU9YztkLnBlbmRpbmdQcm9wcz1iO2QuY2hpbGQ9YS5jaGlsZDtkLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2QubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZC51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2Quc2libGluZz1hLnNpYmxpbmc7ZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gdGUoYSxiLGMpe3ZhciBkPXZvaWQgMCxlPWEudHlwZSxmPWEua2V5O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlPyhkPWUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50P25ldyBZKDIsZixiKTpuZXcgWSgwLGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJzdHJpbmdcIj09PXR5cGVvZiBlPyhkPW5ldyBZKDUsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm51bWJlclwiPT09dHlwZW9mIGUudGFnPyhkPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6RShcIjEzMFwiLG51bGw9PWU/ZTp0eXBlb2YgZSxcIlwiKTtkLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGR9ZnVuY3Rpb24gdWUoYSxiLGMsZCl7Yj1uZXcgWSgxMCxkLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifVxuZnVuY3Rpb24gdmUoYSxiLGMpe2I9bmV3IFkoNixudWxsLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHdlKGEsYixjKXtiPW5ldyBZKDcsYS5rZXksYik7Yi50eXBlPWEuaGFuZGxlcjtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB4ZShhLGIsYyl7YT1uZXcgWSg5LG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIHllKGEsYixjKXtiPW5ldyBZKDQsYS5rZXksYik7Yi5wZW5kaW5nUHJvcHM9YS5jaGlsZHJlbnx8W107Yi5leHBpcmF0aW9uVGltZT1jO2Iuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmEuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjphLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gYn12YXIgemU9bnVsbCxBZT1udWxsO1xuZnVuY3Rpb24gQmUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXt9fX1mdW5jdGlvbiBDZShhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgYj1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoYi5pc0Rpc2FibGVkfHwhYi5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgYz1iLmluamVjdChhKTt6ZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyUm9vdChjLGEpfSk7QWU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclVubW91bnQoYyxhKX0pfWNhdGNoKGQpe31yZXR1cm4hMH1mdW5jdGlvbiBEZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgemUmJnplKGEpfWZ1bmN0aW9uIEVlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBBZSYmQWUoYSl9XG5mdW5jdGlvbiBGZShhKXtyZXR1cm57YmFzZVN0YXRlOmEsZXhwaXJhdGlvblRpbWU6MCxmaXJzdDpudWxsLGxhc3Q6bnVsbCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMSxpc0luaXRpYWxpemVkOiExfX1mdW5jdGlvbiBHZShhLGIpe251bGw9PT1hLmxhc3Q/YS5maXJzdD1hLmxhc3Q9YjooYS5sYXN0Lm5leHQ9YixhLmxhc3Q9Yik7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+Yi5leHBpcmF0aW9uVGltZSlhLmV4cGlyYXRpb25UaW1lPWIuZXhwaXJhdGlvblRpbWV9XG5mdW5jdGlvbiBIZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS51cGRhdGVRdWV1ZTtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1GZShudWxsKSk7bnVsbCE9PWM/KGE9Yy51cGRhdGVRdWV1ZSxudWxsPT09YSYmKGE9Yy51cGRhdGVRdWV1ZT1GZShudWxsKSkpOmE9bnVsbDthPWEhPT1kP2E6bnVsbDtudWxsPT09YT9HZShkLGIpOm51bGw9PT1kLmxhc3R8fG51bGw9PT1hLmxhc3Q/KEdlKGQsYiksR2UoYSxiKSk6KEdlKGQsYiksYS5sYXN0PWIpfWZ1bmN0aW9uIEllKGEsYixjLGQpe2E9YS5wYXJ0aWFsU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGIsYyxkKTphfVxuZnVuY3Rpb24gSmUoYSxiLGMsZCxlLGYpe251bGwhPT1hJiZhLnVwZGF0ZVF1ZXVlPT09YyYmKGM9Yi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmMuYmFzZVN0YXRlLGV4cGlyYXRpb25UaW1lOmMuZXhwaXJhdGlvblRpbWUsZmlyc3Q6Yy5maXJzdCxsYXN0OmMubGFzdCxpc0luaXRpYWxpemVkOmMuaXNJbml0aWFsaXplZCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMX0pO2MuZXhwaXJhdGlvblRpbWU9MDtjLmlzSW5pdGlhbGl6ZWQ/YT1jLmJhc2VTdGF0ZTooYT1jLmJhc2VTdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5pc0luaXRpYWxpemVkPSEwKTtmb3IodmFyIGc9ITAsaD1jLmZpcnN0LGs9ITE7bnVsbCE9PWg7KXt2YXIgcT1oLmV4cGlyYXRpb25UaW1lO2lmKHE+Zil7dmFyIHY9Yy5leHBpcmF0aW9uVGltZTtpZigwPT09dnx8dj5xKWMuZXhwaXJhdGlvblRpbWU9cTtrfHwoaz0hMCxjLmJhc2VTdGF0ZT1hKX1lbHNle2t8fChjLmZpcnN0PWgubmV4dCxudWxsPT09XG5jLmZpcnN0JiYoYy5sYXN0PW51bGwpKTtpZihoLmlzUmVwbGFjZSlhPUllKGgsZCxhLGUpLGc9ITA7ZWxzZSBpZihxPUllKGgsZCxhLGUpKWE9Zz9CKHt9LGEscSk6QihhLHEpLGc9ITE7aC5pc0ZvcmNlZCYmKGMuaGFzRm9yY2VVcGRhdGU9ITApO251bGwhPT1oLmNhbGxiYWNrJiYocT1jLmNhbGxiYWNrTGlzdCxudWxsPT09cSYmKHE9Yy5jYWxsYmFja0xpc3Q9W10pLHEucHVzaChoKSl9aD1oLm5leHR9bnVsbCE9PWMuY2FsbGJhY2tMaXN0P2IuZWZmZWN0VGFnfD0zMjpudWxsIT09Yy5maXJzdHx8Yy5oYXNGb3JjZVVwZGF0ZXx8KGIudXBkYXRlUXVldWU9bnVsbCk7a3x8KGMuYmFzZVN0YXRlPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gS2UoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Yylmb3IoYS5jYWxsYmFja0xpc3Q9bnVsbCxhPTA7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV0sZT1kLmNhbGxiYWNrO2QuY2FsbGJhY2s9bnVsbDtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT9FKFwiMTkxXCIsZSk6dm9pZCAwO2UuY2FsbChiKX19XG5mdW5jdGlvbiBMZShhLGIsYyxkKXtmdW5jdGlvbiBlKGEsYil7Yi51cGRhdGVyPWY7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YX12YXIgZj17aXNNb3VudGVkOmxkLGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGcpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMCxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtcbmEoYyxnKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGMsZCl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZT1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmUscGFydGlhbFN0YXRlOm51bGwsY2FsbGJhY2s6ZCxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITAsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGUpfX07cmV0dXJue2Fkb3B0Q2xhc3NJbnN0YW5jZTplLGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnR5cGUsZD1rZShhKSxmPTI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNvbnRleHRUeXBlcyxnPWY/bWUoYSxkKTpEO2I9bmV3IGMoYixnKTtlKGEsYik7ZiYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWQsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1nKTtyZXR1cm4gYn0sbW91bnRDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEuc3RhdGVOb2RlLGU9ZC5zdGF0ZXx8bnVsbCxnPWEucGVuZGluZ1Byb3BzO2c/dm9pZCAwOkUoXCIxNThcIik7dmFyIGg9a2UoYSk7ZC5wcm9wcz1nO2Quc3RhdGU9YS5tZW1vaXplZFN0YXRlPWU7ZC5yZWZzPUQ7ZC5jb250ZXh0PW1lKGEsaCk7bnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50JiYoYS5pbnRlcm5hbENvbnRleHRUYWd8PTEpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxNb3VudCYmKGU9ZC5zdGF0ZSxkLmNvbXBvbmVudFdpbGxNb3VudCgpLGUhPT1kLnN0YXRlJiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZCxkLnN0YXRlLG51bGwpLGU9YS51cGRhdGVRdWV1ZSxudWxsIT09ZSYmKGQuc3RhdGU9SmUoYyxhLGUsZCxnLGIpKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9XG40KX0sdXBkYXRlQ2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIsZSl7dmFyIGc9Yi5zdGF0ZU5vZGU7Zy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Zy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7dmFyIGg9Yi5tZW1vaXplZFByb3BzLGs9Yi5wZW5kaW5nUHJvcHM7a3x8KGs9aCxudWxsPT1rP0UoXCIxNTlcIik6dm9pZCAwKTt2YXIgdT1nLmNvbnRleHQsej1rZShiKTt6PW1lKGIseik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8aD09PWsmJnU9PT16fHwodT1nLnN0YXRlLGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhrLHopLGcuc3RhdGUhPT11JiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZyxnLnN0YXRlLG51bGwpKTt1PWIubWVtb2l6ZWRTdGF0ZTtlPW51bGwhPT1iLnVwZGF0ZVF1ZXVlP0plKGEsYixiLnVwZGF0ZVF1ZXVlLGcsayxlKTp1O2lmKCEoaCE9PWt8fHUhPT1lfHxYLmN1cnJlbnR8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSlyZXR1cm5cImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSwhMTt2YXIgRz1rO2lmKG51bGw9PT1ofHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSlHPSEwO2Vsc2V7dmFyIEk9Yi5zdGF0ZU5vZGUsTD1iLnR5cGU7Rz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgSS5zaG91bGRDb21wb25lbnRVcGRhdGU/SS5zaG91bGRDb21wb25lbnRVcGRhdGUoRyxlLHopOkwucHJvdG90eXBlJiZMLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8hZWEoaCxHKXx8IWVhKHUsZSk6ITB9Rz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGssZSx6KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fFxuaD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxjKGIsayksZChiLGUpKTtnLnByb3BzPWs7Zy5zdGF0ZT1lO2cuY29udGV4dD16O3JldHVybiBHfX19dmFyIFFlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxSZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLFNlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsVGU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LFVlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixWZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxXZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBYZShhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9V2UmJmFbV2VdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIFllPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBaZShhLGIpe3ZhciBjPWIucmVmO2lmKG51bGwhPT1jJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGQ9dm9pZCAwO2ImJigyIT09Yi50YWc/RShcIjExMFwiKTp2b2lkIDAsZD1iLnN0YXRlTm9kZSk7ZD92b2lkIDA6RShcIjE0N1wiLGMpO3ZhciBlPVwiXCIrYztpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM9PT1EP2QucmVmcz17fTpkLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGM/RShcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOkUoXCIxNDlcIixjKX1yZXR1cm4gY31cbmZ1bmN0aW9uICRlKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZFKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiBhZihhKXtmdW5jdGlvbiBiKGIsYyl7aWYoYSl7dmFyIGQ9Yi5sYXN0RWZmZWN0O251bGwhPT1kPyhkLm5leHRFZmZlY3Q9YyxiLmxhc3RFZmZlY3Q9Yyk6Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YztjLm5leHRFZmZlY3Q9bnVsbDtjLmVmZmVjdFRhZz04fX1mdW5jdGlvbiBjKGMsZCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09ZDspYihjLGQpLGQ9ZC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGQoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixjKXthPXNlKGEsYixjKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZWZmZWN0VGFnPVxuMixjKTpkO2IuZWZmZWN0VGFnPTI7cmV0dXJuIGN9ZnVuY3Rpb24gZyhiKXthJiZudWxsPT09Yi5hbHRlcm5hdGUmJihiLmVmZmVjdFRhZz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9dmUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBrKGEsYixjLGQpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZShiLGMucHJvcHMsZCksZC5yZWY9WmUoYixjKSxkW1wicmV0dXJuXCJdPWEsZDtkPXRlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCk7ZC5yZWY9WmUoYixjKTtkW1wicmV0dXJuXCJdPWE7cmV0dXJuIGR9ZnVuY3Rpb24gcShhLGIsYyxkKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPXdlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtcbmJbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB2KGEsYixjLGQpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9eGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiLnR5cGU9Yy52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixudWxsLGQpO2IudHlwZT1jLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj15ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9dWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxcbmQsZiksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9dmUoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFJlOmlmKGIudHlwZT09PVZlKXJldHVybiBiPXVlKGIucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsYyxiLmtleSksYltcInJldHVyblwiXT1hLGI7Yz10ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpO2MucmVmPVplKG51bGwsYik7Y1tcInJldHVyblwiXT1hO3JldHVybiBjO2Nhc2UgU2U6cmV0dXJuIGI9d2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtjYXNlIFRlOnJldHVybiBjPXhlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5jKSxjLnR5cGU9Yi52YWx1ZSxjW1wicmV0dXJuXCJdPWEsYztjYXNlIFVlOnJldHVybiBiPXllKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGJ9aWYoWWUoYil8fFhlKGIpKXJldHVybiBiPXVlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyxudWxsKSxiW1wicmV0dXJuXCJdPWEsYjskZShhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEcoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1WZT91KGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgU2U6cmV0dXJuIGMua2V5PT09ZT9xKGEsYixjLGQpOm51bGw7Y2FzZSBUZTpyZXR1cm4gbnVsbD09PVxuZT92KGEsYixjLGQpOm51bGw7Y2FzZSBVZTpyZXR1cm4gYy5rZXk9PT1lP3koYSxiLGMsZCk6bnVsbH1pZihZZShjKXx8WGUoYykpcmV0dXJuIG51bGwhPT1lP251bGw6dShhLGIsYyxkLG51bGwpOyRlKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSShhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09VmU/dShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgU2U6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHEoYixhLGQsZSk7Y2FzZSBUZTpyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx2KGIsYSxkLGUpO2Nhc2UgVWU6cmV0dXJuIGE9XG5hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwseShiLGEsZCxlKX1pZihZZShkKXx8WGUoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdShiLGEsZCxlLG51bGwpOyRlKGIsZCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTChlLGcsbSxBKXtmb3IodmFyIGg9bnVsbCxyPW51bGwsbj1nLHc9Zz0wLGs9bnVsbDtudWxsIT09biYmdzxtLmxlbmd0aDt3Kyspe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIHg9RyhlLG4sbVt3XSxBKTtpZihudWxsPT09eCl7bnVsbD09PW4mJihuPWspO2JyZWFrfWEmJm4mJm51bGw9PT14LmFsdGVybmF0ZSYmYihlLG4pO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eDtuPWt9aWYodz09PW0ubGVuZ3RoKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDt3PG0ubGVuZ3RoO3crKylpZihuPXooZSxtW3ddLEEpKWc9ZihuLGcsdyksbnVsbD09PXI/aD1uOnIuc2libGluZz1uLHI9bjtyZXR1cm4gaH1mb3Iobj1cbmQoZSxuKTt3PG0ubGVuZ3RoO3crKylpZihrPUkobixlLHcsbVt3XSxBKSl7aWYoYSYmbnVsbCE9PWsuYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PWsua2V5P3c6ay5rZXkpO2c9ZihrLGcsdyk7bnVsbD09PXI/aD1rOnIuc2libGluZz1rO3I9a31hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofWZ1bmN0aW9uIE4oZSxnLG0sQSl7dmFyIGg9WGUobSk7XCJmdW5jdGlvblwiIT09dHlwZW9mIGg/RShcIjE1MFwiKTp2b2lkIDA7bT1oLmNhbGwobSk7bnVsbD09bT9FKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIHI9aD1udWxsLG49Zyx3PWc9MCxrPW51bGwseD1tLm5leHQoKTtudWxsIT09biYmIXguZG9uZTt3KysseD1tLm5leHQoKSl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgSj1HKGUsbix4LnZhbHVlLEEpO2lmKG51bGw9PT1KKXtufHwobj1rKTticmVha31hJiZuJiZudWxsPT09Si5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoSixcbmcsdyk7bnVsbD09PXI/aD1KOnIuc2libGluZz1KO3I9SjtuPWt9aWYoeC5kb25lKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDsheC5kb25lO3crKyx4PW0ubmV4dCgpKXg9eihlLHgudmFsdWUsQSksbnVsbCE9PXgmJihnPWYoeCxnLHcpLG51bGw9PT1yP2g9eDpyLnNpYmxpbmc9eCxyPXgpO3JldHVybiBofWZvcihuPWQoZSxuKTsheC5kb25lO3crKyx4PW0ubmV4dCgpKWlmKHg9SShuLGUsdyx4LnZhbHVlLEEpLG51bGwhPT14KXtpZihhJiZudWxsIT09eC5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09eC5rZXk/dzp4LmtleSk7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14fWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9cmV0dXJuIGZ1bmN0aW9uKGEsZCxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PVZlJiZudWxsPT09Zi5rZXkmJihmPWYucHJvcHMuY2hpbGRyZW4pO1xudmFyIG09XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZjtpZihtKXN3aXRjaChmLiQkdHlwZW9mKXtjYXNlIFJlOmE6e3ZhciByPWYua2V5O2ZvcihtPWQ7bnVsbCE9PW07KXtpZihtLmtleT09PXIpaWYoMTA9PT1tLnRhZz9mLnR5cGU9PT1WZTptLnR5cGU9PT1mLnR5cGUpe2MoYSxtLnNpYmxpbmcpO2Q9ZShtLGYudHlwZT09PVZlP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtkLnJlZj1aZShtLGYpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxtKTticmVha31lbHNlIGIoYSxtKTttPW0uc2libGluZ31mLnR5cGU9PT1WZT8oZD11ZShmLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgsZi5rZXkpLGRbXCJyZXR1cm5cIl09YSxhPWQpOihoPXRlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCksaC5yZWY9WmUoZCxmKSxoW1wicmV0dXJuXCJdPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIFNlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1cbm0paWYoNz09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXdlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFRlOmE6e2lmKG51bGwhPT1kKWlmKDk9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsbnVsbCxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZSBjKGEsZCk7ZD14ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBVZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09bSlpZig0PT09ZC50YWcmJmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1mLmNvbnRhaW5lckluZm8mJmQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09XG5mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSxoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD15ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmfHxcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIGY9XCJcIitmLG51bGwhPT1kJiY2PT09ZC50YWc/KGMoYSxkLnNpYmxpbmcpLGQ9ZShkLGYsaCkpOihjKGEsZCksZD12ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpKSxkW1wicmV0dXJuXCJdPWEsYT1kLGcoYSk7aWYoWWUoZikpcmV0dXJuIEwoYSxkLGYsaCk7aWYoWGUoZikpcmV0dXJuIE4oYSxkLGYsaCk7bSYmJGUoYSxmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYpc3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAxOmg9YS50eXBlLEUoXCIxNTJcIixoLmRpc3BsYXlOYW1lfHxcbmgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIGJmPWFmKCEwKSxjZj1hZighMSk7XG5mdW5jdGlvbiBkZihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsYyxkKTpiZihiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBnKGEsYil7dmFyIGM9Yi5yZWY7bnVsbD09PWN8fGEmJmEucmVmPT09Y3x8KGIuZWZmZWN0VGFnfD0xMjgpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ZyhhLGIpO2lmKCFjKXJldHVybiBkJiZyZShiLCExKSxxKGEsYik7Yz1iLnN0YXRlTm9kZTtpZC5jdXJyZW50PWI7dmFyIGU9Yy5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkU3RhdGU9Yy5zdGF0ZTtiLm1lbW9pemVkUHJvcHM9Yy5wcm9wcztkJiZyZShiLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBrKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/b2UoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmb2UoYSxcbmIuY29udGV4dCwhMSk7SShhLGIuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gcShhLGIpe251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9FKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO3ZhciBjPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSk7Yi5jaGlsZD1jO2ZvcihjW1wicmV0dXJuXCJdPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjW1wicmV0dXJuXCJdPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gdihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOmsoYik7YnJlYWs7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgNDpJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyl9cmV0dXJuIG51bGx9dmFyIHk9YS5zaG91bGRTZXRUZXh0Q29udGVudCx1PWEudXNlU3luY1NjaGVkdWxpbmcsej1hLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsXG5HPWIucHVzaEhvc3RDb250ZXh0LEk9Yi5wdXNoSG9zdENvbnRhaW5lcixMPWMuZW50ZXJIeWRyYXRpb25TdGF0ZSxOPWMucmVzZXRIeWRyYXRpb25TdGF0ZSxKPWMudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7YT1MZShkLGUsZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkUHJvcHM9Yn0sZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkU3RhdGU9Yn0pO3ZhciB3PWEuYWRvcHRDbGFzc0luc3RhbmNlLG09YS5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLEE9YS5tb3VudENsYXNzSW5zdGFuY2UsT2I9YS51cGRhdGVDbGFzc0luc3RhbmNlO3JldHVybntiZWdpbldvcms6ZnVuY3Rpb24oYSxiLGMpe2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpudWxsIT09YT9FKFwiMTU1XCIpOnZvaWQgMDt2YXIgZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxyPWtlKGIpO3I9bWUoYixyKTtkPWQoZSxyKTtiLmVmZmVjdFRhZ3w9XG4xO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLnJlbmRlcj8oYi50YWc9MixlPXFlKGIpLHcoYixkKSxBKGIsYyksYj1oKGEsYiwhMCxlKSk6KGIudGFnPTEsZihhLGIsZCksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDE6YTp7ZT1iLnR5cGU7Yz1iLnBlbmRpbmdQcm9wcztkPWIubWVtb2l6ZWRQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWQpO2Vsc2UgaWYobnVsbD09PWN8fGQ9PT1jKXtiPXEoYSxiKTticmVhayBhfWQ9a2UoYik7ZD1tZShiLGQpO2U9ZShjLGQpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDI6cmV0dXJuIGU9cWUoYiksZD12b2lkIDAsbnVsbD09PWE/Yi5zdGF0ZU5vZGU/RShcIjE1M1wiKToobShiLGIucGVuZGluZ1Byb3BzKSxBKGIsYyksZD0hMCk6ZD1PYihhLGIsYyksaChhLGIsZCxlKTtjYXNlIDM6cmV0dXJuIGsoYiksXG5lPWIudXBkYXRlUXVldWUsbnVsbCE9PWU/KGQ9Yi5tZW1vaXplZFN0YXRlLGU9SmUoYSxiLGUsbnVsbCxudWxsLGMpLGQ9PT1lPyhOKCksYj1xKGEsYikpOihkPWUuZWxlbWVudCxyPWIuc3RhdGVOb2RlLChudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZyLmh5ZHJhdGUmJkwoYik/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9Y2YoYixudWxsLGQsYykpOihOKCksZihhLGIsZCkpLGIubWVtb2l6ZWRTdGF0ZT1lLGI9Yi5jaGlsZCkpOihOKCksYj1xKGEsYikpLGI7Y2FzZSA1OkcoYik7bnVsbD09PWEmJkooYik7ZT1iLnR5cGU7dmFyIG49Yi5tZW1vaXplZFByb3BzO2Q9Yi5wZW5kaW5nUHJvcHM7bnVsbD09PWQmJihkPW4sbnVsbD09PWQ/RShcIjE1NFwiKTp2b2lkIDApO3I9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOm51bGw7WC5jdXJyZW50fHxudWxsIT09ZCYmbiE9PWQ/KG49ZC5jaGlsZHJlbix5KGUsZCk/bj1udWxsOnImJnkoZSxyKSYmKGIuZWZmZWN0VGFnfD0xNiksZyhhLGIpLFxuMjE0NzQ4MzY0NyE9PWMmJiF1JiZ6KGUsZCk/KGIuZXhwaXJhdGlvblRpbWU9MjE0NzQ4MzY0NyxiPW51bGwpOihmKGEsYixuKSxiLm1lbW9pemVkUHJvcHM9ZCxiPWIuY2hpbGQpKTpiPXEoYSxiKTtyZXR1cm4gYjtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZKKGIpLGE9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWEmJihhPWIubWVtb2l6ZWRQcm9wcyksYi5tZW1vaXplZFByb3BzPWEsbnVsbDtjYXNlIDg6Yi50YWc9NztjYXNlIDc6ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSllPWIubWVtb2l6ZWRQcm9wcztkPWUuY2hpbGRyZW47Yi5zdGF0ZU5vZGU9bnVsbD09PWE/Y2YoYixiLnN0YXRlTm9kZSxkLGMpOmJmKGIsYi5zdGF0ZU5vZGUsZCxjKTtiLm1lbW9pemVkUHJvcHM9ZTtyZXR1cm4gYi5zdGF0ZU5vZGU7XG5jYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSA0OmE6e0koYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtlPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpe2I9cShhLGIpO2JyZWFrIGF9bnVsbD09PWE/Yi5jaGlsZD1iZihiLG51bGwsZSxjKTpmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9ZTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAxMDphOntjPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9Yi5tZW1vaXplZFByb3BzKTtlbHNlIGlmKG51bGw9PT1jfHxiLm1lbW9pemVkUHJvcHM9PT1jKXtiPXEoYSxiKTticmVhayBhfWYoYSxiLGMpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtkZWZhdWx0OkUoXCIxNTZcIil9fSxiZWdpbkZhaWxlZFdvcms6ZnVuY3Rpb24oYSxiLFxuYyl7c3dpdGNoKGIudGFnKXtjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSAzOmsoYik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfWIuZWZmZWN0VGFnfD02NDtudWxsPT09YT9iLmNoaWxkPW51bGw6Yi5jaGlsZCE9PWEuY2hpbGQmJihiLmNoaWxkPWEuY2hpbGQpO2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtiLmZpcnN0RWZmZWN0PW51bGw7Yi5sYXN0RWZmZWN0PW51bGw7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsbnVsbCxjKTpiZihiLGEuY2hpbGQsbnVsbCxjKTsyPT09Yi50YWcmJihhPWIuc3RhdGVOb2RlLGIubWVtb2l6ZWRQcm9wcz1hLnByb3BzLGIubWVtb2l6ZWRTdGF0ZT1hLnN0YXRlKTtyZXR1cm4gYi5jaGlsZH19fVxuZnVuY3Rpb24gZWYoYSxiLGMpe2Z1bmN0aW9uIGQoYSl7YS5lZmZlY3RUYWd8PTR9dmFyIGU9YS5jcmVhdGVJbnN0YW5jZSxmPWEuY3JlYXRlVGV4dEluc3RhbmNlLGc9YS5hcHBlbmRJbml0aWFsQ2hpbGQsaD1hLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLGs9YS5wcmVwYXJlVXBkYXRlLHE9YS5wZXJzaXN0ZW5jZSx2PWIuZ2V0Um9vdEhvc3RDb250YWluZXIseT1iLnBvcEhvc3RDb250ZXh0LHU9Yi5nZXRIb3N0Q29udGV4dCx6PWIucG9wSG9zdENvbnRhaW5lcixHPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxJPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsTD1jLnBvcEh5ZHJhdGlvblN0YXRlLE49dm9pZCAwLEo9dm9pZCAwLHc9dm9pZCAwO2EubXV0YXRpb24/KE49ZnVuY3Rpb24oKXt9LEo9ZnVuY3Rpb24oYSxiLGMpeyhiLnVwZGF0ZVF1ZXVlPWMpJiZkKGIpfSx3PWZ1bmN0aW9uKGEsYixjLGUpe2MhPT1lJiZkKGIpfSk6cT9FKFwiMjM1XCIpOkUoXCIyMzZcIik7XG5yZXR1cm57Y29tcGxldGVXb3JrOmZ1bmN0aW9uKGEsYixjKXt2YXIgbT1iLnBlbmRpbmdQcm9wcztpZihudWxsPT09bSltPWIubWVtb2l6ZWRQcm9wcztlbHNlIGlmKDIxNDc0ODM2NDchPT1iLmV4cGlyYXRpb25UaW1lfHwyMTQ3NDgzNjQ3PT09YyliLnBlbmRpbmdQcm9wcz1udWxsO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnJldHVybiBudWxsO2Nhc2UgMjpyZXR1cm4gbmUoYiksbnVsbDtjYXNlIDM6eihiKTtWKFgsYik7VihpZSxiKTttPWIuc3RhdGVOb2RlO20ucGVuZGluZ0NvbnRleHQmJihtLmNvbnRleHQ9bS5wZW5kaW5nQ29udGV4dCxtLnBlbmRpbmdDb250ZXh0PW51bGwpO2lmKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZClMKGIpLGIuZWZmZWN0VGFnJj0tMztOKGIpO3JldHVybiBudWxsO2Nhc2UgNTp5KGIpO2M9digpO3ZhciBBPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpe3ZhciBwPWEubWVtb2l6ZWRQcm9wcyxxPWIuc3RhdGVOb2RlLHg9dSgpO3E9XG5rKHEsQSxwLG0sYyx4KTtKKGEsYixxLEEscCxtLGMpO2EucmVmIT09Yi5yZWYmJihiLmVmZmVjdFRhZ3w9MTI4KX1lbHNle2lmKCFtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXUoKTtpZihMKGIpKUcoYixjLGEpJiZkKGIpO2Vsc2V7YT1lKEEsbSxjLGEsYik7YTpmb3IocD1iLmNoaWxkO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWcpZyhhLHAuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1wLnRhZyYmbnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9aWYocD09PWIpYnJlYWs7Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PXBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfWgoYSxBLG0sYykmJmQoYik7Yi5zdGF0ZU5vZGU9YX1udWxsIT09Yi5yZWYmJlxuKGIuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSl3KGEsYixhLm1lbW9pemVkUHJvcHMsbSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIG0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9digpO2M9dSgpO0woYik/SShiKSYmZChiKTpiLnN0YXRlTm9kZT1mKG0sYSxjLGIpfXJldHVybiBudWxsO2Nhc2UgNzoobT1iLm1lbW9pemVkUHJvcHMpP3ZvaWQgMDpFKFwiMTY1XCIpO2IudGFnPTg7QT1bXTthOmZvcigocD1iLnN0YXRlTm9kZSkmJihwW1wicmV0dXJuXCJdPWIpO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWd8fDQ9PT1wLnRhZylFKFwiMjQ3XCIpO2Vsc2UgaWYoOT09PXAudGFnKUEucHVzaChwLnR5cGUpO2Vsc2UgaWYobnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PVxucFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9cD1tLmhhbmRsZXI7bT1wKG0ucHJvcHMsQSk7Yi5jaGlsZD1iZihiLG51bGwhPT1hP2EuY2hpbGQ6bnVsbCxtLGMpO3JldHVybiBiLmNoaWxkO2Nhc2UgODpyZXR1cm4gYi50YWc9NyxudWxsO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDEwOnJldHVybiBudWxsO2Nhc2UgNDpyZXR1cm4geihiKSxOKGIpLG51bGw7Y2FzZSAwOkUoXCIxNjdcIik7ZGVmYXVsdDpFKFwiMTU2XCIpfX19fVxuZnVuY3Rpb24gZmYoYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKXRyeXtjKG51bGwpfWNhdGNoKEEpe2IoYSxBKX19ZnVuY3Rpb24gZChhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRWUmJkVlKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAyOmMoYSk7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2QucHJvcHM9YS5tZW1vaXplZFByb3BzLGQuc3RhdGU9YS5tZW1vaXplZFN0YXRlLGQuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChBKXtiKGEsQSl9YnJlYWs7Y2FzZSA1OmMoYSk7YnJlYWs7Y2FzZSA3OmUoYS5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgNDprJiZnKGEpfX1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYj1hOzspaWYoZChiKSxudWxsPT09Yi5jaGlsZHx8ayYmND09PWIudGFnKXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8XG5iW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfWVsc2UgYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZH1mdW5jdGlvbiBmKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIGcoYSl7Zm9yKHZhciBiPWEsYz0hMSxmPXZvaWQgMCxnPXZvaWQgMDs7KXtpZighYyl7Yz1iW1wicmV0dXJuXCJdO2E6Zm9yKDs7KXtudWxsPT09Yz9FKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpmPWMuc3RhdGVOb2RlO2c9ITE7YnJlYWsgYTtjYXNlIDM6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYTtjYXNlIDQ6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yz0hMH1pZig1PT09Yi50YWd8fDY9PT1iLnRhZyllKGIpLGc/SihmLGIuc3RhdGVOb2RlKTpOKGYsYi5zdGF0ZU5vZGUpO1xuZWxzZSBpZig0PT09Yi50YWc/Zj1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOmQoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGRbXCJyZXR1cm5cIl09YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl07ND09PWIudGFnJiYoYz0hMSl9Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXZhciBoPWEuZ2V0UHVibGljSW5zdGFuY2Usaz1hLm11dGF0aW9uO2E9YS5wZXJzaXN0ZW5jZTtrfHwoYT9FKFwiMjM1XCIpOkUoXCIyMzZcIikpO3ZhciBxPWsuY29tbWl0TW91bnQsdj1rLmNvbW1pdFVwZGF0ZSx5PWsucmVzZXRUZXh0Q29udGVudCx1PWsuY29tbWl0VGV4dFVwZGF0ZSx6PWsuYXBwZW5kQ2hpbGQsRz1rLmFwcGVuZENoaWxkVG9Db250YWluZXIsST1rLmluc2VydEJlZm9yZSxMPWsuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG5OPWsucmVtb3ZlQ2hpbGQsSj1rLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtyZXR1cm57Y29tbWl0UmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXt5KGEuc3RhdGVOb2RlKX0sY29tbWl0UGxhY2VtZW50OmZ1bmN0aW9uKGEpe2E6e2Zvcih2YXIgYj1hW1wicmV0dXJuXCJdO251bGwhPT1iOyl7aWYoZihiKSl7dmFyIGM9YjticmVhayBhfWI9YltcInJldHVyblwiXX1FKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6RShcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKHkoYiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWNbXCJyZXR1cm5cIl18fGYoY1tcInJldHVyblwiXSkpe2M9XG5udWxsO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWMuc2libGluZ1tcInJldHVyblwiXT1jW1wicmV0dXJuXCJdO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZzspe2lmKGMuZWZmZWN0VGFnJjIpY29udGludWUgYjtpZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkW1wicmV0dXJuXCJdPWMsYz1jLmNoaWxkfWlmKCEoYy5lZmZlY3RUYWcmMikpe2M9Yy5zdGF0ZU5vZGU7YnJlYWsgYX19Zm9yKHZhciBlPWE7Oyl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpYz9kP0woYixlLnN0YXRlTm9kZSxjKTpJKGIsZS5zdGF0ZU5vZGUsYyk6ZD9HKGIsZS5zdGF0ZU5vZGUpOnooYixlLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09ZS50YWcmJm51bGwhPT1lLmNoaWxkKXtlLmNoaWxkW1wicmV0dXJuXCJdPWU7ZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lW1wicmV0dXJuXCJdfHxlW1wicmV0dXJuXCJdPT09XG5hKXJldHVybjtlPWVbXCJyZXR1cm5cIl19ZS5zaWJsaW5nW1wicmV0dXJuXCJdPWVbXCJyZXR1cm5cIl07ZT1lLnNpYmxpbmd9fSxjb21taXREZWxldGlvbjpmdW5jdGlvbihhKXtnKGEpO2FbXCJyZXR1cm5cIl09bnVsbDthLmNoaWxkPW51bGw7YS5hbHRlcm5hdGUmJihhLmFsdGVybmF0ZS5jaGlsZD1udWxsLGEuYWx0ZXJuYXRlW1wicmV0dXJuXCJdPW51bGwpfSxjb21taXRXb3JrOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSA1OnZhciBjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe3ZhciBkPWIubWVtb2l6ZWRQcm9wczthPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO3ZhciBlPWIudHlwZSxmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO251bGwhPT1mJiZ2KGMsZixlLGEsZCxiKX1icmVhaztjYXNlIDY6bnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjJcIik6dm9pZCAwO2M9Yi5tZW1vaXplZFByb3BzO3UoYi5zdGF0ZU5vZGUsbnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOlxuYyxjKTticmVhaztjYXNlIDM6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0TGlmZUN5Y2xlczpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnZhciBjPWIuc3RhdGVOb2RlO2lmKGIuZWZmZWN0VGFnJjQpaWYobnVsbD09PWEpYy5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYy5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9YS5tZW1vaXplZFByb3BzO2E9YS5tZW1vaXplZFN0YXRlO2MucHJvcHM9Yi5tZW1vaXplZFByb3BzO2Muc3RhdGU9Yi5tZW1vaXplZFN0YXRlO2MuY29tcG9uZW50RGlkVXBkYXRlKGQsYSl9Yj1iLnVwZGF0ZVF1ZXVlO251bGwhPT1iJiZLZShiLGMpO2JyZWFrO2Nhc2UgMzpjPWIudXBkYXRlUXVldWU7bnVsbCE9PWMmJktlKGMsbnVsbCE9PWIuY2hpbGQ/Yi5jaGlsZC5zdGF0ZU5vZGU6bnVsbCk7YnJlYWs7Y2FzZSA1OmM9Yi5zdGF0ZU5vZGU7bnVsbD09PWEmJmIuZWZmZWN0VGFnJjQmJnEoYyxcbmIudHlwZSxiLm1lbW9pemVkUHJvcHMsYik7YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRBdHRhY2hSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmIoaChjKSk7YnJlYWs7ZGVmYXVsdDpiKGMpfX19LGNvbW1pdERldGFjaFJlZjpmdW5jdGlvbihhKXthPWEucmVmO251bGwhPT1hJiZhKG51bGwpfX19dmFyIGdmPXt9O1xuZnVuY3Rpb24gaGYoYSl7ZnVuY3Rpb24gYihhKXthPT09Z2Y/RShcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9dmFyIGM9YS5nZXRDaGlsZEhvc3RDb250ZXh0LGQ9YS5nZXRSb290SG9zdENvbnRleHQsZT17Y3VycmVudDpnZn0sZj17Y3VycmVudDpnZn0sZz17Y3VycmVudDpnZn07cmV0dXJue2dldEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoZS5jdXJyZW50KX0sZ2V0Um9vdEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gYihnLmN1cnJlbnQpfSxwb3BIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEpe1YoZSxhKTtWKGYsYSk7VihnLGEpfSxwb3BIb3N0Q29udGV4dDpmdW5jdGlvbihhKXtmLmN1cnJlbnQ9PT1hJiYoVihlLGEpLFYoZixhKSl9LHB1c2hIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEsYil7VyhnLGIsYSk7Yj1kKGIpO1coZixhLGEpO1coZSxiLGEpfSxwdXNoSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGQ9YihnLmN1cnJlbnQpLGg9YihlLmN1cnJlbnQpO1xuZD1jKGgsYS50eXBlLGQpO2ghPT1kJiYoVyhmLGEsYSksVyhlLGQsYSkpfSxyZXNldEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtlLmN1cnJlbnQ9Z2Y7Zy5jdXJyZW50PWdmfX19XG5mdW5jdGlvbiBqZihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9bmV3IFkoNSxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2NbXCJyZXR1cm5cIl09YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gYyhhLGIpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBiPWYoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9ZyhiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZChhKXtmb3IoYT1hW1wicmV0dXJuXCJdO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZzspYT1hW1wicmV0dXJuXCJdO3k9YX12YXIgZT1hLnNob3VsZFNldFRleHRDb250ZW50O1xuYT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7fSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzVcIil9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NlwiKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19O3ZhciBmPWEuY2FuSHlkcmF0ZUluc3RhbmNlLGc9YS5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLGg9YS5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsaz1hLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLHE9YS5oeWRyYXRlSW5zdGFuY2Usdj1hLmh5ZHJhdGVUZXh0SW5zdGFuY2UseT1udWxsLHU9bnVsbCx6PSExO3JldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe3U9XG5rKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4gej0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3U9eT1udWxsO3o9ITF9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKGEpe2lmKHope3ZhciBkPXU7aWYoZCl7aWYoIWMoYSxkKSl7ZD1oKGQpO2lmKCFkfHwhYyhhLGQpKXthLmVmZmVjdFRhZ3w9Mjt6PSExO3k9YTtyZXR1cm59Yih5LHUpfXk9YTt1PWsoZCl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix6PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9cShhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gdihhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT1cbnkpcmV0dXJuITE7aWYoIXopcmV0dXJuIGQoYSksej0hMCwhMTt2YXIgYz1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWMmJlwiYm9keVwiIT09YyYmIWUoYyxhLm1lbW9pemVkUHJvcHMpKWZvcihjPXU7YzspYihhLGMpLGM9aChjKTtkKGEpO3U9eT9oKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBrZihhKXtmdW5jdGlvbiBiKGEpe1FiPWphPSEwO3ZhciBiPWEuc3RhdGVOb2RlO2IuY3VycmVudD09PWE/RShcIjE3N1wiKTp2b2lkIDA7Yi5pc1JlYWR5Rm9yQ29tbWl0PSExO2lkLmN1cnJlbnQ9bnVsbDtpZigxPGEuZWZmZWN0VGFnKWlmKG51bGwhPT1hLmxhc3RFZmZlY3Qpe2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE7dmFyIGM9YS5maXJzdEVmZmVjdH1lbHNlIGM9YTtlbHNlIGM9YS5maXJzdEVmZmVjdDt5ZygpO2Zvcih0PWM7bnVsbCE9PXQ7KXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBmPXQuZWZmZWN0VGFnO2YmMTYmJnpnKHQpO2lmKGYmMTI4KXt2YXIgZz10LmFsdGVybmF0ZTtudWxsIT09ZyYmQWcoZyl9c3dpdGNoKGYmLTI0Mil7Y2FzZSAyOk5lKHQpO3QuZWZmZWN0VGFnJj0tMzticmVhaztjYXNlIDY6TmUodCk7dC5lZmZlY3RUYWcmPS0zO09lKHQuYWx0ZXJuYXRlLHQpO2JyZWFrO2Nhc2UgNDpPZSh0LmFsdGVybmF0ZSxcbnQpO2JyZWFrO2Nhc2UgODpTYz0hMCxCZyh0KSxTYz0hMX10PXQubmV4dEVmZmVjdH19Y2F0Y2goVGMpe2Q9ITAsZT1UY31kJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGUpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1DZygpO2IuY3VycmVudD1hO2Zvcih0PWM7bnVsbCE9PXQ7KXtjPSExO2Q9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGs9dC5lZmZlY3RUYWc7ayYzNiYmRGcodC5hbHRlcm5hdGUsdCk7ayYxMjgmJkVnKHQpO2lmKGsmNjQpc3dpdGNoKGU9dCxmPXZvaWQgMCxudWxsIT09UiYmKGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSxudWxsPT1mJiZudWxsIT09ZS5hbHRlcm5hdGUmJihlPWUuYWx0ZXJuYXRlLGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSkpLG51bGw9PWY/RShcIjE4NFwiKTp2b2lkIDAsZS50YWcpe2Nhc2UgMjplLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaChmLmVycm9yLHtjb21wb25lbnRTdGFjazpmLmNvbXBvbmVudFN0YWNrfSk7XG5icmVhaztjYXNlIDM6bnVsbD09PWNhJiYoY2E9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfXZhciBRYz10Lm5leHRFZmZlY3Q7dC5uZXh0RWZmZWN0PW51bGw7dD1RY319Y2F0Y2goVGMpe2M9ITAsZD1UY31jJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGQpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1qYT1RYj0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRGUmJkRlKGEuc3RhdGVOb2RlKTtoYSYmKGhhLmZvckVhY2goRyksaGE9bnVsbCk7bnVsbCE9PWNhJiYoYT1jYSxjYT1udWxsLE9iKGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKHFhPVI9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gYyhhKXtmb3IoOzspe3ZhciBiPUZnKGEuYWx0ZXJuYXRlLGEsSCksYz1hW1wicmV0dXJuXCJdLGQ9YS5zaWJsaW5nO3ZhciBlPWE7aWYoMjE0NzQ4MzY0Nz09PUh8fDIxNDc0ODM2NDchPT1lLmV4cGlyYXRpb25UaW1lKXtpZigyIT09ZS50YWcmJjMhPT1cbmUudGFnKXZhciBmPTA7ZWxzZSBmPWUudXBkYXRlUXVldWUsZj1udWxsPT09Zj8wOmYuZXhwaXJhdGlvblRpbWU7Zm9yKHZhciBnPWUuY2hpbGQ7bnVsbCE9PWc7KTAhPT1nLmV4cGlyYXRpb25UaW1lJiYoMD09PWZ8fGY+Zy5leHBpcmF0aW9uVGltZSkmJihmPWcuZXhwaXJhdGlvblRpbWUpLGc9Zy5zaWJsaW5nO2UuZXhwaXJhdGlvblRpbWU9Zn1pZihudWxsIT09YilyZXR1cm4gYjtudWxsIT09YyYmKG51bGw9PT1jLmZpcnN0RWZmZWN0JiYoYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSk7aWYobnVsbCE9PWQpcmV0dXJuIGQ7XG5pZihudWxsIT09YylhPWM7ZWxzZXthLnN0YXRlTm9kZS5pc1JlYWR5Rm9yQ29tbWl0PSEwO2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEpe3ZhciBiPXJnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3ZhciBiPUdnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe2lmKG51bGwhPT1SKXtpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ayhGKT9lKEYpOmQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWsoRik/ZShGKTpkKEYpfWVsc2UgaWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWQoRil9ZnVuY3Rpb24gZyhhLGIpe2phP0UoXCIyNDNcIik6dm9pZCAwO2phPSEwO2EuaXNSZWFkeUZvckNvbW1pdD1cbiExO2lmKGEhPT1yYXx8YiE9PUh8fG51bGw9PT1GKXtmb3IoOy0xPGhlOylnZVtoZV09bnVsbCxoZS0tO2plPUQ7aWUuY3VycmVudD1EO1guY3VycmVudD0hMTt4KCk7cmE9YTtIPWI7Rj1zZShyYS5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtmKGIpfWNhdGNoKFJjKXtjPSEwLGQ9UmN9Zm9yKDtjOyl7aWYoZWIpe2NhPWQ7YnJlYWt9dmFyIGc9RjtpZihudWxsPT09ZyllYj0hMDtlbHNle3ZhciBrPWgoZyxkKTtudWxsPT09az9FKFwiMTgzXCIpOnZvaWQgMDtpZighZWIpe3RyeXtjPWs7ZD1iO2ZvcihrPWM7bnVsbCE9PWc7KXtzd2l0Y2goZy50YWcpe2Nhc2UgMjpuZShnKTticmVhaztjYXNlIDU6cWcoZyk7YnJlYWs7Y2FzZSAzOnAoZyk7YnJlYWs7Y2FzZSA0OnAoZyl9aWYoZz09PWt8fGcuYWx0ZXJuYXRlPT09aylicmVhaztnPWdbXCJyZXR1cm5cIl19Rj1lKGMpO2YoZCl9Y2F0Y2goUmMpe2M9ITA7ZD1SYztjb250aW51ZX1icmVha319fWI9Y2E7ZWI9amE9ITE7Y2E9XG5udWxsO251bGwhPT1iJiZPYihiKTtyZXR1cm4gYS5pc1JlYWR5Rm9yQ29tbWl0P2EuY3VycmVudC5hbHRlcm5hdGU6bnVsbH1mdW5jdGlvbiBoKGEsYil7dmFyIGM9aWQuY3VycmVudD1udWxsLGQ9ITEsZT0hMSxmPW51bGw7aWYoMz09PWEudGFnKWM9YSxxKGEpJiYoZWI9ITApO2Vsc2UgZm9yKHZhciBnPWFbXCJyZXR1cm5cIl07bnVsbCE9PWcmJm51bGw9PT1jOyl7Mj09PWcudGFnP1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaCYmKGQ9ITAsZj1qZChnKSxjPWcsZT0hMCk6Mz09PWcudGFnJiYoYz1nKTtpZihxKGcpKXtpZihTY3x8bnVsbCE9PWhhJiYoaGEuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJmhhLmhhcyhnLmFsdGVybmF0ZSkpKXJldHVybiBudWxsO2M9bnVsbDtlPSExfWc9Z1tcInJldHVyblwiXX1pZihudWxsIT09Yyl7bnVsbD09PXFhJiYocWE9bmV3IFNldCk7cWEuYWRkKGMpO3ZhciBoPVwiXCI7Zz1hO2Rve2E6c3dpdGNoKGcudGFnKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDU6dmFyIGs9XG5nLl9kZWJ1Z093bmVyLFFjPWcuX2RlYnVnU291cmNlO3ZhciBtPWpkKGcpO3ZhciBuPW51bGw7ayYmKG49amQoaykpO2s9UWM7bT1cIlxcbiAgICBpbiBcIisobXx8XCJVbmtub3duXCIpKyhrP1wiIChhdCBcIitrLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sXCJcIikrXCI6XCIray5saW5lTnVtYmVyK1wiKVwiOm4/XCIgKGNyZWF0ZWQgYnkgXCIrbitcIilcIjpcIlwiKTticmVhayBhO2RlZmF1bHQ6bT1cIlwifWgrPW07Zz1nW1wicmV0dXJuXCJdfXdoaWxlKGcpO2c9aDthPWpkKGEpO251bGw9PT1SJiYoUj1uZXcgTWFwKTtiPXtjb21wb25lbnROYW1lOmEsY29tcG9uZW50U3RhY2s6ZyxlcnJvcjpiLGVycm9yQm91bmRhcnk6ZD9jLnN0YXRlTm9kZTpudWxsLGVycm9yQm91bmRhcnlGb3VuZDpkLGVycm9yQm91bmRhcnlOYW1lOmYsd2lsbFJldHJ5OmV9O1Iuc2V0KGMsYik7dHJ5e3ZhciBwPWIuZXJyb3I7cCYmcC5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKHApfWNhdGNoKFZjKXtWYyYmXG5WYy5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKFZjKX1RYj8obnVsbD09PWhhJiYoaGE9bmV3IFNldCksaGEuYWRkKGMpKTpHKGMpO3JldHVybiBjfW51bGw9PT1jYSYmKGNhPWIpO3JldHVybiBudWxsfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIG51bGwhPT1SJiYoUi5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmUi5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiBxKGEpe3JldHVybiBudWxsIT09cWEmJihxYS5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmcWEuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gdigpe3JldHVybiAyMCooKChJKCkrMTAwKS8yMHwwKSsxKX1mdW5jdGlvbiB5KGEpe3JldHVybiAwIT09a2E/a2E6amE/UWI/MTpIOiFIZ3x8YS5pbnRlcm5hbENvbnRleHRUYWcmMT92KCk6MX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHooYSxiLCExKX1mdW5jdGlvbiB6KGEsYil7Zm9yKDtudWxsIT09YTspe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxcbmEuZXhwaXJhdGlvblRpbWU+YilhLmV4cGlyYXRpb25UaW1lPWI7bnVsbCE9PWEuYWx0ZXJuYXRlJiYoMD09PWEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lfHxhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT5iKSYmKGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1hW1wicmV0dXJuXCJdKWlmKDM9PT1hLnRhZyl7dmFyIGM9YS5zdGF0ZU5vZGU7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApO3ZhciBkPWMsZT1iO1JiPklnJiZFKFwiMTg1XCIpO2lmKG51bGw9PT1kLm5leHRTY2hlZHVsZWRSb290KWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZSxudWxsPT09Tz8oc2E9Tz1kLGQubmV4dFNjaGVkdWxlZFJvb3Q9ZCk6KE89Ty5uZXh0U2NoZWR1bGVkUm9vdD1kLE8ubmV4dFNjaGVkdWxlZFJvb3Q9c2EpO2Vsc2V7dmFyIGY9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09Znx8ZTxmKWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZX1GYXx8KGxhP1xuU2ImJihtYT1kLG5hPTEsbShtYSxuYSkpOjE9PT1lP3coMSxudWxsKTpMKGUpKTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCl9ZWxzZSBicmVhazthPWFbXCJyZXR1cm5cIl19fWZ1bmN0aW9uIEcoYSl7eihhLDEsITApfWZ1bmN0aW9uIEkoKXtyZXR1cm4gVWM9KChXYygpLVBlKS8xMHwwKSsyfWZ1bmN0aW9uIEwoYSl7aWYoMCE9PVRiKXtpZihhPlRiKXJldHVybjtKZyhYYyl9dmFyIGI9V2MoKS1QZTtUYj1hO1hjPUtnKEose3RpbWVvdXQ6MTAqKGEtMiktYn0pfWZ1bmN0aW9uIE4oKXt2YXIgYT0wLGI9bnVsbDtpZihudWxsIT09Tylmb3IodmFyIGM9TyxkPXNhO251bGwhPT1kOyl7dmFyIGU9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09ZSl7bnVsbD09PWN8fG51bGw9PT1PP0UoXCIyNDRcIik6dm9pZCAwO2lmKGQ9PT1kLm5leHRTY2hlZHVsZWRSb290KXtzYT1PPWQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGlmKGQ9PT1zYSlzYT1lPWQubmV4dFNjaGVkdWxlZFJvb3QsXG5PLm5leHRTY2hlZHVsZWRSb290PWUsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Vsc2UgaWYoZD09PU8pe089YztPLm5leHRTY2hlZHVsZWRSb290PXNhO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PWF8fGU8YSlhPWUsYj1kO2lmKGQ9PT1PKWJyZWFrO2M9ZDtkPWQubmV4dFNjaGVkdWxlZFJvb3R9fWM9bWE7bnVsbCE9PWMmJmM9PT1iP1JiKys6UmI9MDttYT1iO25hPWF9ZnVuY3Rpb24gSihhKXt3KDAsYSl9ZnVuY3Rpb24gdyhhLGIpe2ZiPWI7Zm9yKE4oKTtudWxsIT09bWEmJjAhPT1uYSYmKDA9PT1hfHxuYTw9YSkmJiFZYzspbShtYSxuYSksTigpO251bGwhPT1mYiYmKFRiPTAsWGM9LTEpOzAhPT1uYSYmTChuYSk7ZmI9bnVsbDtZYz0hMTtSYj0wO2lmKFViKXRocm93IGE9WmMsWmM9XG5udWxsLFViPSExLGE7fWZ1bmN0aW9uIG0oYSxjKXtGYT9FKFwiMjQ1XCIpOnZvaWQgMDtGYT0hMDtpZihjPD1JKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKEEoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO0ZhPSExfWZ1bmN0aW9uIEEoKXtyZXR1cm4gbnVsbD09PWZifHxmYi50aW1lUmVtYWluaW5nKCk+TGc/ITE6WWM9ITB9ZnVuY3Rpb24gT2IoYSl7bnVsbD09PW1hP0UoXCIyNDZcIik6XG52b2lkIDA7bWEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9MDtVYnx8KFViPSEwLFpjPWEpfXZhciByPWhmKGEpLG49amYoYSkscD1yLnBvcEhvc3RDb250YWluZXIscWc9ci5wb3BIb3N0Q29udGV4dCx4PXIucmVzZXRIb3N0Q29udGFpbmVyLE1lPWRmKGEscixuLHUseSkscmc9TWUuYmVnaW5Xb3JrLEdnPU1lLmJlZ2luRmFpbGVkV29yayxGZz1lZihhLHIsbikuY29tcGxldGVXb3JrO3I9ZmYoYSxoKTt2YXIgemc9ci5jb21taXRSZXNldFRleHRDb250ZW50LE5lPXIuY29tbWl0UGxhY2VtZW50LEJnPXIuY29tbWl0RGVsZXRpb24sT2U9ci5jb21taXRXb3JrLERnPXIuY29tbWl0TGlmZUN5Y2xlcyxFZz1yLmNvbW1pdEF0dGFjaFJlZixBZz1yLmNvbW1pdERldGFjaFJlZixXYz1hLm5vdyxLZz1hLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxKZz1hLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssSGc9YS51c2VTeW5jU2NoZWR1bGluZyx5Zz1hLnByZXBhcmVGb3JDb21taXQsQ2c9YS5yZXNldEFmdGVyQ29tbWl0LFxuUGU9V2MoKSxVYz0yLGthPTAsamE9ITEsRj1udWxsLHJhPW51bGwsSD0wLHQ9bnVsbCxSPW51bGwscWE9bnVsbCxoYT1udWxsLGNhPW51bGwsZWI9ITEsUWI9ITEsU2M9ITEsc2E9bnVsbCxPPW51bGwsVGI9MCxYYz0tMSxGYT0hMSxtYT1udWxsLG5hPTAsWWM9ITEsVWI9ITEsWmM9bnVsbCxmYj1udWxsLGxhPSExLFNiPSExLElnPTFFMyxSYj0wLExnPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246dixjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksc2NoZWR1bGVXb3JrOnUsYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1sYTtsYT0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXsobGE9Yyl8fEZhfHx3KDEsbnVsbCl9fSx1bmJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe2lmKGxhJiYhU2Ipe1NiPSEwO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7U2I9ITF9fXJldHVybiBhKCl9LGZsdXNoU3luYzpmdW5jdGlvbihhKXt2YXIgYj1sYTtsYT0hMDt0cnl7YTp7dmFyIGM9XG5rYTtrYT0xO3RyeXt2YXIgZD1hKCk7YnJlYWsgYX1maW5hbGx5e2thPWN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtsYT1iLEZhP0UoXCIxODdcIik6dm9pZCAwLHcoMSxudWxsKX19LGRlZmVycmVkVXBkYXRlczpmdW5jdGlvbihhKXt2YXIgYj1rYTtrYT12KCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtrYT1ifX19fVxuZnVuY3Rpb24gbGYoYSl7ZnVuY3Rpb24gYihhKXthPW9kKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfXZhciBjPWEuZ2V0UHVibGljSW5zdGFuY2U7YT1rZihhKTt2YXIgZD1hLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sZT1hLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsZj1hLnNjaGVkdWxlV29yaztyZXR1cm57Y3JlYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFkoMyxudWxsLDApO2E9e2N1cnJlbnQ6Yyxjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwscmVtYWluaW5nRXhwaXJhdGlvblRpbWU6MCxpc1JlYWR5Rm9yQ29tbWl0OiExLGZpbmlzaGVkV29yazpudWxsLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YixuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTtyZXR1cm4gYy5zdGF0ZU5vZGU9YX0sdXBkYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLHEpe3ZhciBnPWIuY3VycmVudDtpZihjKXtjPVxuYy5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBoO2I6ezI9PT1rZChjKSYmMj09PWMudGFnP3ZvaWQgMDpFKFwiMTcwXCIpO2ZvcihoPWM7MyE9PWgudGFnOyl7aWYobGUoaCkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn0oaD1oW1wicmV0dXJuXCJdKT92b2lkIDA6RShcIjE3MVwiKX1oPWguc3RhdGVOb2RlLmNvbnRleHR9Yz1sZShjKT9wZShjLGgpOmh9ZWxzZSBjPUQ7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj1xO2I9dm9pZCAwPT09Yj9udWxsOmI7cT1udWxsIT1hJiZudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ/ZCgpOmUoZyk7SGUoZyx7ZXhwaXJhdGlvblRpbWU6cSxwYXJ0aWFsU3RhdGU6e2VsZW1lbnQ6YX0sY2FsbGJhY2s6Yixpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsXG5uZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtmKGcscSl9LGJhdGNoZWRVcGRhdGVzOmEuYmF0Y2hlZFVwZGF0ZXMsdW5iYXRjaGVkVXBkYXRlczphLnVuYmF0Y2hlZFVwZGF0ZXMsZGVmZXJyZWRVcGRhdGVzOmEuZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzphLmZsdXNoU3luYyxnZXRQdWJsaWNSb290SW5zdGFuY2U6ZnVuY3Rpb24oYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGMoYS5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX0sZmluZEhvc3RJbnN0YW5jZTpiLGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOmZ1bmN0aW9uKGEpe2E9cGQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGluamVjdEludG9EZXZUb29sczpmdW5jdGlvbihhKXt2YXIgYz1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiBDZShCKHt9LFxuYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBjP2MoYSk6bnVsbH19KSl9fX12YXIgbWY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpsZn0pLG5mPW1mJiZsZnx8bWYsb2Y9bmZbXCJkZWZhdWx0XCJdP25mW1wiZGVmYXVsdFwiXTpuZjtmdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOlVlLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fXZhciBxZj1cIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93LHJmPXZvaWQgMDtyZj1xZj9mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX06ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07XG52YXIgc2Y9dm9pZCAwLHRmPXZvaWQgMDtcbmlmKGwuY2FuVXNlRE9NKWlmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrKXt2YXIgdWY9bnVsbCx2Zj0hMSx3Zj0tMSx4Zj0hMSx5Zj0wLHpmPTMzLEFmPTMzLEJmO0JmPXFmP3tkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19OntkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1EYXRlLm5vdygpO3JldHVybiAwPGE/YTowfX07dmFyIENmPVwiX19yZWFjdElkbGVDYWxsYmFjayRcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihhKXtpZihhLnNvdXJjZT09PXdpbmRvdyYmYS5kYXRhPT09Q2Ype3ZmPSExO2E9cmYoKTtpZigwPj15Zi1hKWlmKC0xIT09d2YmJndmPD1cbmEpQmYuZGlkVGltZW91dD0hMDtlbHNle3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJufWVsc2UgQmYuZGlkVGltZW91dD0hMTt3Zj0tMTthPXVmO3VmPW51bGw7bnVsbCE9PWEmJmEoQmYpfX0sITEpO3ZhciBEZj1mdW5jdGlvbihhKXt4Zj0hMTt2YXIgYj1hLXlmK0FmO2I8QWYmJnpmPEFmPyg4PmImJihiPTgpLEFmPWI8emY/emY6Yik6emY9Yjt5Zj1hK0FmO3ZmfHwodmY9ITAsd2luZG93LnBvc3RNZXNzYWdlKENmLFwiKlwiKSl9O3NmPWZ1bmN0aW9uKGEsYil7dWY9YTtudWxsIT1iJiZcIm51bWJlclwiPT09dHlwZW9mIGIudGltZW91dCYmKHdmPXJmKCkrYi50aW1lb3V0KTt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybiAwfTt0Zj1mdW5jdGlvbigpe3VmPW51bGw7dmY9ITE7d2Y9LTF9fWVsc2Ugc2Y9d2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2ssdGY9d2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztlbHNlIHNmPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSh7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiBJbmZpbml0eX19KX0pfSxcbnRmPWZ1bmN0aW9uKGEpe2NsZWFyVGltZW91dChhKX07dmFyIEVmPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxGZj17fSxHZj17fTtcbmZ1bmN0aW9uIEhmKGEpe2lmKEdmLmhhc093blByb3BlcnR5KGEpKXJldHVybiEwO2lmKEZmLmhhc093blByb3BlcnR5KGEpKXJldHVybiExO2lmKEVmLnRlc3QoYSkpcmV0dXJuIEdmW2FdPSEwO0ZmW2FdPSEwO3JldHVybiExfVxuZnVuY3Rpb24gSWYoYSxiLGMpe3ZhciBkPXdhKGIpO2lmKGQmJnZhKGIsYykpe3ZhciBlPWQubXV0YXRpb25NZXRob2Q7ZT9lKGEsYyk6bnVsbD09Y3x8ZC5oYXNCb29sZWFuVmFsdWUmJiFjfHxkLmhhc051bWVyaWNWYWx1ZSYmaXNOYU4oYyl8fGQuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUmJjE+Y3x8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMT09PWM/SmYoYSxiKTpkLm11c3RVc2VQcm9wZXJ0eT9hW2QucHJvcGVydHlOYW1lXT1jOihiPWQuYXR0cmlidXRlTmFtZSwoZT1kLmF0dHJpYnV0ZU5hbWVzcGFjZSk/YS5zZXRBdHRyaWJ1dGVOUyhlLGIsXCJcIitjKTpkLmhhc0Jvb2xlYW5WYWx1ZXx8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMD09PWM/YS5zZXRBdHRyaWJ1dGUoYixcIlwiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWVsc2UgS2YoYSxiLHZhKGIsYyk/YzpudWxsKX1cbmZ1bmN0aW9uIEtmKGEsYixjKXtIZihiKSYmKG51bGw9PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1mdW5jdGlvbiBKZihhLGIpe3ZhciBjPXdhKGIpO2M/KGI9Yy5tdXRhdGlvbk1ldGhvZCk/YihhLHZvaWQgMCk6Yy5tdXN0VXNlUHJvcGVydHk/YVtjLnByb3BlcnR5TmFtZV09Yy5oYXNCb29sZWFuVmFsdWU/ITE6XCJcIjphLnJlbW92ZUF0dHJpYnV0ZShjLmF0dHJpYnV0ZU5hbWUpOmEucmVtb3ZlQXR0cmlidXRlKGIpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9Yi5jaGVja2VkO3JldHVybiBCKHt0eXBlOnZvaWQgMCxzdGVwOnZvaWQgMCxtaW46dm9pZCAwLG1heDp2b2lkIDB9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLGNoZWNrZWQ6bnVsbCE9ZD9kOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIE1mKGEsYil7dmFyIGM9Yi5kZWZhdWx0VmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpudWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOm51bGwhPWIudmFsdWU/Yi52YWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fVxuZnVuY3Rpb24gTmYoYSxiKXtiPWIuY2hlY2tlZDtudWxsIT1iJiZJZihhLFwiY2hlY2tlZFwiLGIpfWZ1bmN0aW9uIE9mKGEsYil7TmYoYSxiKTt2YXIgYz1iLnZhbHVlO2lmKG51bGwhPWMpaWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlKWEudmFsdWU9XCIwXCI7ZWxzZSBpZihcIm51bWJlclwiPT09Yi50eXBlKXtpZihiPXBhcnNlRmxvYXQoYS52YWx1ZSl8fDAsYyE9Ynx8Yz09YiYmYS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBudWxsPT1iLnZhbHVlJiZudWxsIT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1cIlwiK2IuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitiLmRlZmF1bHRWYWx1ZSksbnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gUGYoYSxiKXtzd2l0Y2goYi50eXBlKXtjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7Y2FzZSBcImNvbG9yXCI6Y2FzZSBcImRhdGVcIjpjYXNlIFwiZGF0ZXRpbWVcIjpjYXNlIFwiZGF0ZXRpbWUtbG9jYWxcIjpjYXNlIFwibW9udGhcIjpjYXNlIFwidGltZVwiOmNhc2UgXCJ3ZWVrXCI6YS52YWx1ZT1cIlwiO2EudmFsdWU9YS5kZWZhdWx0VmFsdWU7YnJlYWs7ZGVmYXVsdDphLnZhbHVlPWEudmFsdWV9Yj1hLm5hbWU7XCJcIiE9PWImJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO1wiXCIhPT1iJiYoYS5uYW1lPWIpfWZ1bmN0aW9uIFFmKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGw9PWF8fFwic3RyaW5nXCIhPT10eXBlb2YgYSYmXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIFJmKGEsYil7YT1CKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9UWYoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIFNmKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitjO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBUZihhLGIpe3ZhciBjPWIudmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6bnVsbCE9Yz9jOmIuZGVmYXVsdFZhbHVlLHdhc011bHRpcGxlOiEhYi5tdWx0aXBsZX19ZnVuY3Rpb24gVWYoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIEIoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gVmYoYSxiKXt2YXIgYz1iLnZhbHVlO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz9FKFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6RShcIjkzXCIpLGI9YlswXSksYz1cIlwiK2IpLG51bGw9PWMmJihjPVwiXCIpKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpcIlwiK2N9fVxuZnVuY3Rpb24gV2YoYSxiKXt2YXIgYz1iLnZhbHVlO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1iLmRlZmF1bHRWYWx1ZSl9ZnVuY3Rpb24gWGYoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmKGEudmFsdWU9Yil9dmFyIFlmPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIFpmKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gJGYoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP1pmKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIGFnPXZvaWQgMCxiZz1mdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbihiLGMsZCxlKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBhKGIsYyxkLGUpfSl9OmF9KGZ1bmN0aW9uKGEsYil7aWYoYS5uYW1lc3BhY2VVUkkhPT1ZZi5zdmd8fFwiaW5uZXJIVE1MXCJpbiBhKWEuaW5uZXJIVE1MPWI7ZWxzZXthZz1hZ3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthZy5pbm5lckhUTUw9XCJcXHgzY3N2Z1xceDNlXCIrYitcIlxceDNjL3N2Z1xceDNlXCI7Zm9yKGI9YWcuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gY2coYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbnZhciBkZz17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLFxuc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxlZz1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoZGcpLmZvckVhY2goZnVuY3Rpb24oYSl7ZWcuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtkZ1tiXT1kZ1thXX0pfSk7XG5mdW5jdGlvbiBmZyhhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIik7dmFyIGU9Yzt2YXIgZj1iW2NdO2U9bnVsbD09Znx8XCJib29sZWFuXCI9PT10eXBlb2YgZnx8XCJcIj09PWY/XCJcIjpkfHxcIm51bWJlclwiIT09dHlwZW9mIGZ8fDA9PT1mfHxkZy5oYXNPd25Qcm9wZXJ0eShlKSYmZGdbZV0/KFwiXCIrZikudHJpbSgpOmYrXCJweFwiO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgZ2c9Qih7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIGhnKGEsYixjKXtiJiYoZ2dbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCIxMzdcIixhLGMoKSk6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9FKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOkUoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP0UoXCI2MlwiLGMoKSk6dm9pZCAwKX1cbmZ1bmN0aW9uIGlnKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgamc9WWYuaHRtbCxrZz1DLnRoYXRSZXR1cm5zKFwiXCIpO1xuZnVuY3Rpb24gbGcoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9SGQoYSk7Yj1TYVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtjLmhhc093blByb3BlcnR5KGUpJiZjW2VdfHwoXCJ0b3BTY3JvbGxcIj09PWU/d2QoXCJ0b3BTY3JvbGxcIixcInNjcm9sbFwiLGEpOlwidG9wRm9jdXNcIj09PWV8fFwidG9wQmx1clwiPT09ZT8od2QoXCJ0b3BGb2N1c1wiLFwiZm9jdXNcIixhKSx3ZChcInRvcEJsdXJcIixcImJsdXJcIixhKSxjLnRvcEJsdXI9ITAsYy50b3BGb2N1cz0hMCk6XCJ0b3BDYW5jZWxcIj09PWU/KHljKFwiY2FuY2VsXCIsITApJiZ3ZChcInRvcENhbmNlbFwiLFwiY2FuY2VsXCIsYSksYy50b3BDYW5jZWw9ITApOlwidG9wQ2xvc2VcIj09PWU/KHljKFwiY2xvc2VcIiwhMCkmJndkKFwidG9wQ2xvc2VcIixcImNsb3NlXCIsYSksYy50b3BDbG9zZT0hMCk6RGQuaGFzT3duUHJvcGVydHkoZSkmJlUoZSxEZFtlXSxhKSxjW2VdPSEwKX19XG52YXIgbWc9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIixcbnRvcFdhaXRpbmc6XCJ3YWl0aW5nXCJ9O2Z1bmN0aW9uIG5nKGEsYixjLGQpe2M9OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7ZD09PWpnJiYoZD1aZihhKSk7ZD09PWpnP1wic2NyaXB0XCI9PT1hPyhhPWMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIlxceDNjc2NyaXB0XFx4M2VcXHgzYy9zY3JpcHRcXHgzZVwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTphPVwic3RyaW5nXCI9PT10eXBlb2YgYi5pcz9jLmNyZWF0ZUVsZW1lbnQoYSx7aXM6Yi5pc30pOmMuY3JlYXRlRWxlbWVudChhKTphPWMuY3JlYXRlRWxlbWVudE5TKGQsYSk7cmV0dXJuIGF9ZnVuY3Rpb24gb2coYSxiKXtyZXR1cm4oOT09PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKGEpfVxuZnVuY3Rpb24gcGcoYSxiLGMsZCl7dmFyIGU9aWcoYixjKTtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO3ZhciBmPWM7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTtmPWM7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtmPUxmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtcbmxnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1SZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO2Y9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpO2Y9VWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0OmY9Y31oZyhiLGYsa2cpO3ZhciBnPWYsaDtmb3IoaCBpbiBnKWlmKGcuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWdbaF07XCJzdHlsZVwiPT09aD9mZyhhLGssa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWg/KGs9az9rLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYmcoYSxrKSk6XCJjaGlsZHJlblwiPT09aD9cInN0cmluZ1wiPT09dHlwZW9mIGs/KFwidGV4dGFyZWFcIiE9PWJ8fFwiXCIhPT1rKSYmY2coYSxrKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJmNnKGEsXG5cIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1oJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09aCYmXCJhdXRvRm9jdXNcIiE9PWgmJihSYS5oYXNPd25Qcm9wZXJ0eShoKT9udWxsIT1rJiZsZyhkLGgpOmU/S2YoYSxoLGspOm51bGwhPWsmJklmKGEsaCxrKSl9c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9Yy52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMudmFsdWUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhYy5tdWx0aXBsZTtiPWMudmFsdWU7bnVsbCE9Yj9TZihhLCEhYy5tdWx0aXBsZSxiLCExKTpudWxsIT1jLmRlZmF1bHRWYWx1ZSYmU2YoYSwhIWMubXVsdGlwbGUsYy5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGYub25DbGljayYmKGEub25jbGljaz1cbkMpfX1cbmZ1bmN0aW9uIHNnKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6Yz1MZihhLGMpO2Q9TGYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpjPVJmKGEsYyk7ZD1SZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmM9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtkPUIoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpjPVVmKGEsYyk7ZD1VZihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUMpfWhnKGIsZCxrZyk7dmFyIGcsaDthPW51bGw7Zm9yKGcgaW4gYylpZighZC5oYXNPd25Qcm9wZXJ0eShnKSYmYy5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9Y1tnXSlpZihcInN0eWxlXCI9PT1nKWZvcihoIGluIGI9Y1tnXSxiKWIuaGFzT3duUHJvcGVydHkoaCkmJihhfHwoYT17fSksYVtoXT1cblwiXCIpO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1nJiZcImNoaWxkcmVuXCIhPT1nJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJlwiYXV0b0ZvY3VzXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGcsbnVsbCkpO2ZvcihnIGluIGQpe3ZhciBrPWRbZ107Yj1udWxsIT1jP2NbZ106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoZykmJmshPT1iJiYobnVsbCE9a3x8bnVsbCE9YikpaWYoXCJzdHlsZVwiPT09ZylpZihiKXtmb3IoaCBpbiBiKSFiLmhhc093blByb3BlcnR5KGgpfHxrJiZrLmhhc093blByb3BlcnR5KGgpfHwoYXx8KGE9e30pLGFbaF09XCJcIik7Zm9yKGggaW4gaylrLmhhc093blByb3BlcnR5KGgpJiZiW2hdIT09a1toXSYmKGF8fChhPXt9KSxhW2hdPWtbaF0pfWVsc2UgYXx8KGZ8fChmPVtdKSxmLnB1c2goZyxhKSksYT1rO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1cbmc/KGs9az9rLl9faHRtbDp2b2lkIDAsYj1iP2IuX19odG1sOnZvaWQgMCxudWxsIT1rJiZiIT09ayYmKGY9Znx8W10pLnB1c2goZyxcIlwiK2spKTpcImNoaWxkcmVuXCI9PT1nP2I9PT1rfHxcInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2goZyxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpPyhudWxsIT1rJiZsZyhlLGcpLGZ8fGI9PT1rfHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGcsaykpfWEmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixhKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSl7XCJpbnB1dFwiPT09YyYmXCJyYWRpb1wiPT09ZS50eXBlJiZudWxsIT1lLm5hbWUmJk5mKGEsZSk7aWcoYyxkKTtkPWlnKGMsZSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKz0yKXt2YXIgZz1iW2ZdLGg9YltmKzFdO1wic3R5bGVcIj09PWc/ZmcoYSxoLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1nP2JnKGEsaCk6XCJjaGlsZHJlblwiPT09Zz9jZyhhLGgpOmQ/bnVsbCE9aD9LZihhLGcsaCk6YS5yZW1vdmVBdHRyaWJ1dGUoZyk6bnVsbCE9aD9JZihhLGcsaCk6SmYoYSxnKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6T2YoYSxlKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlPXZvaWQgMCxiPWEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxhLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFlLm11bHRpcGxlLGM9ZS52YWx1ZSxudWxsIT1jP1NmKGEsXG4hIWUubXVsdGlwbGUsYywhMSk6YiE9PSEhZS5tdWx0aXBsZSYmKG51bGwhPWUuZGVmYXVsdFZhbHVlP1NmKGEsISFlLm11bHRpcGxlLGUuZGVmYXVsdFZhbHVlLCEwKTpTZihhLCEhZS5tdWx0aXBsZSxlLm11bHRpcGxlP1tdOlwiXCIsITEpKX19XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKHZhciBmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO1xuVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKSxVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpLGxnKGUsXCJvbkNoYW5nZVwiKX1oZyhiLGMsa2cpO2Q9bnVsbDtmb3IodmFyIGcgaW4gYyljLmhhc093blByb3BlcnR5KGcpJiYoZj1jW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBmP2EudGV4dENvbnRlbnQhPT1mJiYoZD1bXCJjaGlsZHJlblwiLGZdKTpcIm51bWJlclwiPT09dHlwZW9mIGYmJmEudGV4dENvbnRlbnQhPT1cIlwiK2YmJihkPVtcImNoaWxkcmVuXCIsXCJcIitmXSk6UmEuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWYmJmxnKGUsZykpO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLm9uQ2xpY2smJlxuKGEub25jbGljaz1DKX1yZXR1cm4gZH1mdW5jdGlvbiB2ZyhhLGIpe3JldHVybiBhLm5vZGVWYWx1ZSE9PWJ9XG52YXIgd2c9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlRWxlbWVudDpuZyxjcmVhdGVUZXh0Tm9kZTpvZyxzZXRJbml0aWFsUHJvcGVydGllczpwZyxkaWZmUHJvcGVydGllczpzZyx1cGRhdGVQcm9wZXJ0aWVzOnRnLGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6dWcsZGlmZkh5ZHJhdGVkVGV4dDp2Zyx3YXJuRm9yVW5tYXRjaGVkVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6ZnVuY3Rpb24oKXt9LHJlc3RvcmVDb250cm9sbGVkU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpPZihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9XG5jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lXFx4M2RcIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGVcXHgzZFwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPXJiKGQpO2U/dm9pZCAwOkUoXCI5MFwiKTtDYyhkKTtPZihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJlNmKGEsISFjLm11bHRpcGxlLGIsITEpfX19KTtuYy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KHdnKTt2YXIgeGc9bnVsbCxNZz1udWxsO2Z1bmN0aW9uIE5nKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIE9nKGEpe2E9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbDtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZXx8IWEuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpfVxudmFyIFo9b2Yoe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO3N3aXRjaChiKXtjYXNlIDk6Y2FzZSAxMTphPShhPWEuZG9jdW1lbnRFbGVtZW50KT9hLm5hbWVzcGFjZVVSSTokZihudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yj04PT09Yj9hLnBhcmVudE5vZGU6YSxhPWIubmFtZXNwYWNlVVJJfHxudWxsLGI9Yi50YWdOYW1lLGE9JGYoYSxiKX1yZXR1cm4gYX0sZ2V0Q2hpbGRIb3N0Q29udGV4dDpmdW5jdGlvbihhLGIpe3JldHVybiAkZihhLGIpfSxnZXRQdWJsaWNJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYX0scHJlcGFyZUZvckNvbW1pdDpmdW5jdGlvbigpe3hnPXRkO3ZhciBhPWRhKCk7aWYoS2QoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGI9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e3ZhciBjPXdpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbmlmKGMmJjAhPT1jLnJhbmdlQ291bnQpe2I9Yy5hbmNob3JOb2RlO3ZhciBkPWMuYW5jaG9yT2Zmc2V0LGU9Yy5mb2N1c05vZGU7Yz1jLmZvY3VzT2Zmc2V0O3RyeXtiLm5vZGVUeXBlLGUubm9kZVR5cGV9Y2F0Y2goeil7Yj1udWxsO2JyZWFrIGF9dmFyIGY9MCxnPS0xLGg9LTEsaz0wLHE9MCx2PWEseT1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7diE9PWJ8fDAhPT1kJiYzIT09di5ub2RlVHlwZXx8KGc9ZitkKTt2IT09ZXx8MCE9PWMmJjMhPT12Lm5vZGVUeXBlfHwoaD1mK2MpOzM9PT12Lm5vZGVUeXBlJiYoZis9di5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9di5maXJzdENoaWxkKSlicmVhazt5PXY7dj11fWZvcig7Oyl7aWYodj09PWEpYnJlYWsgYjt5PT09YiYmKytrPT09ZCYmKGc9Zik7eT09PWUmJisrcT09PWMmJihoPWYpO2lmKG51bGwhPT0odT12Lm5leHRTaWJsaW5nKSlicmVhazt2PXk7eT12LnBhcmVudE5vZGV9dj11fWI9LTE9PT1nfHwtMT09PWg/bnVsbDpcbntzdGFydDpnLGVuZDpofX1lbHNlIGI9bnVsbH1iPWJ8fHtzdGFydDowLGVuZDowfX1lbHNlIGI9bnVsbDtNZz17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpifTt1ZCghMSl9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt2YXIgYT1NZyxiPWRhKCksYz1hLmZvY3VzZWRFbGVtLGQ9YS5zZWxlY3Rpb25SYW5nZTtpZihiIT09YyYmZmEoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGMpKXtpZihLZChjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2I9d2luZG93LmdldFNlbGVjdGlvbigpO3ZhciBlPWNbRWIoKV0ubGVuZ3RoO2E9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2E6TWF0aC5taW4oZC5lbmQsZSk7IWIuZXh0ZW5kJiZhPlxuZCYmKGU9ZCxkPWEsYT1lKTtlPUpkKGMsYSk7dmFyIGY9SmQoYyxkKTtpZihlJiZmJiYoMSE9PWIucmFuZ2VDb3VudHx8Yi5hbmNob3JOb2RlIT09ZS5ub2RlfHxiLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxiLmZvY3VzTm9kZSE9PWYubm9kZXx8Yi5mb2N1c09mZnNldCE9PWYub2Zmc2V0KSl7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtnLnNldFN0YXJ0KGUubm9kZSxlLm9mZnNldCk7Yi5yZW1vdmVBbGxSYW5nZXMoKTthPmQ/KGIuYWRkUmFuZ2UoZyksYi5leHRlbmQoZi5ub2RlLGYub2Zmc2V0KSk6KGcuc2V0RW5kKGYubm9kZSxmLm9mZnNldCksYi5hZGRSYW5nZShnKSl9fWI9W107Zm9yKGE9YzthPWEucGFyZW50Tm9kZTspMT09PWEubm9kZVR5cGUmJmIucHVzaCh7ZWxlbWVudDphLGxlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH0pO2lhKGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPVxuYS50b3B9TWc9bnVsbDt1ZCh4Zyk7eGc9bnVsbH0sY3JlYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPW5nKGEsYixjLGQpO2FbUV09ZTthW29iXT1iO3JldHVybiBhfSxhcHBlbmRJbml0aWFsQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbihhLGIsYyxkKXtwZyhhLGIsYyxkKTthOntzd2l0Y2goYil7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjphPSEhYy5hdXRvRm9jdXM7YnJlYWsgYX1hPSExfXJldHVybiBhfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHNnKGEsYixjLGQsZSl9LHNob3VsZFNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT1cbnR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJzdHJpbmdcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH0sc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYi5oaWRkZW59LGNyZWF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkKXthPW9nKGEsYik7YVtRXT1kO3JldHVybiBhfSxub3c6cmYsbXV0YXRpb246e2NvbW1pdE1vdW50OmZ1bmN0aW9uKGEpe2EuZm9jdXMoKX0sY29tbWl0VXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YVtvYl09ZTt0ZyhhLGIsYyxkLGUpfSxyZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe2EudGV4dENvbnRlbnQ9XCJcIn0sY29tbWl0VGV4dFVwZGF0ZTpmdW5jdGlvbihhLGIsYyl7YS5ub2RlVmFsdWU9Y30sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxhcHBlbmRDaGlsZFRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsXG5iKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYSk6YS5hcHBlbmRDaGlsZChiKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYixjKXthLmluc2VydEJlZm9yZShiLGMpfSxpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTpmdW5jdGlvbihhLGIsYyl7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGMpOmEuaW5zZXJ0QmVmb3JlKGIsYyl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEsYil7YS5yZW1vdmVDaGlsZChiKX0scmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpOmEucmVtb3ZlQ2hpbGQoYil9fSxoeWRyYXRpb246e2Nhbkh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3JldHVybiAxIT09YS5ub2RlVHlwZXx8Yi50b0xvd2VyQ2FzZSgpIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YX0sY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7cmV0dXJuXCJcIj09PWJ8fDMhPT1hLm5vZGVUeXBlP251bGw6YX0sZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOmZ1bmN0aW9uKGEpe2ZvcihhPWEubmV4dFNpYmxpbmc7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0saHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXthW1FdPWY7YVtvYl09YztyZXR1cm4gdWcoYSxiLGMsZSxkKX0saHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7YVtRXT1jO3JldHVybiB2ZyhhLGIpfSxkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxcbmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90SHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9fSxzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6c2YsY2FuY2VsRGVmZXJyZWRDYWxsYmFjazp0Zix1c2VTeW5jU2NoZWR1bGluZzohMH0pO3JjPVouYmF0Y2hlZFVwZGF0ZXM7XG5mdW5jdGlvbiBQZyhhLGIsYyxkLGUpe05nKGMpP3ZvaWQgMDpFKFwiMjAwXCIpO3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKVoudXBkYXRlQ29udGFpbmVyKGIsZixhLGUpO2Vsc2V7ZD1kfHxPZyhjKTtpZighZClmb3IoZj12b2lkIDA7Zj1jLmxhc3RDaGlsZDspYy5yZW1vdmVDaGlsZChmKTt2YXIgZz1aLmNyZWF0ZUNvbnRhaW5lcihjLGQpO2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPWc7Wi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7Wi51cGRhdGVDb250YWluZXIoYixnLGEsZSl9KX1yZXR1cm4gWi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZil9ZnVuY3Rpb24gUWcoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtOZyhiKT92b2lkIDA6RShcIjIwMFwiKTtyZXR1cm4gcGYoYSxiLG51bGwsYyl9XG5mdW5jdGlvbiBSZyhhLGIpe3RoaXMuX3JlYWN0Um9vdENvbnRhaW5lcj1aLmNyZWF0ZUNvbnRhaW5lcihhLGIpfVJnLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXtaLnVwZGF0ZUNvbnRhaW5lcihhLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGIpfTtSZy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXtaLnVwZGF0ZUNvbnRhaW5lcihudWxsLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGEpfTtcbnZhciBTZz17Y3JlYXRlUG9ydGFsOlFnLGZpbmRET01Ob2RlOmZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKGIpcmV0dXJuIFouZmluZEhvc3RJbnN0YW5jZShiKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5yZW5kZXI/RShcIjE4OFwiKTpFKFwiMjEzXCIsT2JqZWN0LmtleXMoYSkpfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/RShcIjM4XCIpOnZvaWQgMDtyZXR1cm4gUGcoYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7TmcoYSk/dm9pZCAwOlxuRShcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFoudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1BnKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGx9KX0pLCEwKTohMX0sdW5zdGFibGVfY3JlYXRlUG9ydGFsOlFnLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnRjLHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczpaLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6Wi5mbHVzaFN5bmMsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e0V2ZW50UGx1Z2luSHViOm1iLEV2ZW50UGx1Z2luUmVnaXN0cnk6VmEsRXZlbnRQcm9wYWdhdG9yczpDYixSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6cWMsUmVhY3RET01Db21wb25lbnRUcmVlOnNiLFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjp4ZH19O1xuWi5pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnBiLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMi4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7dmFyIFRnPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6U2d9KSxVZz1UZyYmU2d8fFRnO21vZHVsZS5leHBvcnRzPVVnW1wiZGVmYXVsdFwiXT9VZ1tcImRlZmF1bHRcIl06VWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG4vLyBUaGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhbGwgbG93ZXJjYXNlIHRvIGFsbG93IGZvclxuLy8gY2FzZSBpbnNlbnNpdGl2ZSBjaGVja3NcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IHRydWUsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICBpbm5lckhUTUw6IHRydWUsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICBzdHlsZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG4gIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91J3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICclcycgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy5cIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzU3RyaW5nQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcblxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25jYXNlIHJlZmVyZW5jZXMgdG8gd2hpdGVsaXN0IHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIG1lbWJlcnNoaXBcbiAgICAgIC8vIHdpdGhvdXQgY2FzZS1zZW5zaXRpdml0eS4gVGhpcyBhbGxvd3MgdGhlIHdoaXRlbGlzdCB0byBwaWNrIHVwXG4gICAgICAvLyBgYWxsb3dmdWxsc2NyZWVuYCwgd2hpY2ggc2hvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIGZvciBgYWxsb3dGdWxsc2NyZWVuYFxuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xuXG4vKipcbiAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICpcbiAqIGF0dHJpYnV0ZU5hbWU6XG4gKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAqIHByb3BlcnR5TmFtZTpcbiAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICogbXV0YXRpb25NZXRob2Q6XG4gKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAqICAgaW5pdGlhbCByZW5kZXIuXG4gKiBtdXN0VXNlUHJvcGVydHk6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICogaGFzQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc051bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gKi9cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgd3JpdGVhYmxlIGF0dHJpYnV0ZS5cbiAqIEBtZXRob2RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSk7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNTdHJpbmdCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU7XG4gIH1cbiAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgcmV0dXJuIHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHByb3BlcnR5IG5hbWUgaXMgd2l0aGluIHRoZSBsaXN0IG9mIHByb3BlcnRpZXNcbiAqIHJlc2VydmVkIGZvciBpbnRlcm5hbCBSZWFjdCBvcGVyYXRpb25zLiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZFxuICogbm90IGJlIHNldCBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbmFtZSBpcyB3aXRoaW4gcmVzZXJ2ZWQgcHJvcHNcbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZFByb3AobmFtZSkge1xuICByZXR1cm4gUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkobmFtZSk7XG59XG5cbnZhciBpbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gIC8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gIC8vIG5hbWUgd2FybmluZ3MuXG4gIFByb3BlcnRpZXM6IHtcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4gICAgLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuICAgIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb250ZW50RWRpdGFibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIC8vIHN1cHBvcnQgZm9yIHByb2plY3RpbmcgcmVndWxhciBET00gRWxlbWVudHMgdmlhIFYxIG5hbWVkIHNsb3RzICggc2hhZG93IGRvbSApXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFN0eWxlIG11c3QgYmUgZXhwbGljaXRseSBzZXQgaW4gdGhlIGF0dHJpYnV0ZSBsaXN0LiBSZWFjdCBjb21wb25lbnRzXG4gICAgLy8gZXhwZWN0IGEgc3R5bGUgb2JqZWN0XG4gICAgc3R5bGU6IDAsXG4gICAgLy8gS2VlcCBpdCBpbiB0aGUgd2hpdGVsaXN0IGJlY2F1c2UgaXQgaXMgY2FzZS1zZW5zaXRpdmUgZm9yIFNWRy5cbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBpdGVtU2NvcGUgaXMgZm9yIGZvciBNaWNyb2RhdGEgc3VwcG9ydC5cbiAgICAvLyBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIG11c3Qgc3RheSBpbiB0aGUgd2hpdGUtbGlzdCBiZWNhdXNlIHRoZXkgaGF2ZVxuICAgIC8vIGRpZmZlcmVudCBhdHRyaWJ1dGUgbmFtZXMgKHNlZSBET01BdHRyaWJ1dGVOYW1lcyBiZWxvdylcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICAvLyBBdHRyaWJ1dGVzIHdpdGggbXV0YXRpb24gbWV0aG9kcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgd2hpdGVsaXN0XG4gICAgLy8gU2V0IHRoZSBzdHJpbmcgYm9vbGVhbiBmbGFnIHRvIGFsbG93IHRoZSBiZWhhdmlvclxuICAgIHZhbHVlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01NdXRhdGlvbk1ldGhvZHM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE51bWJlciBpbnB1dHMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBzb21lIGVkZ2UgY2FzZXMgaW5cbiAgICAgIC8vIENocm9tZS4gTGV0IGV2ZXJ5dGhpbmcgZWxzZSBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSBhcyBub3JtYWwuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTMjaXNzdWVjb21tZW50LTIzNjA3NDMyNlxuICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ251bWJlcicgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbGlkaXR5ICYmICFub2RlLnZhbGlkaXR5LmJhZElucHV0ICYmIG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgICAgIC8vIERvbid0IGFzc2lnbiBhbiBhdHRyaWJ1dGUgaWYgdmFsaWRhdGlvbiByZXBvcnRzIGJhZFxuICAgICAgICAvLyBpbnB1dC4gQ2hyb21lIHdpbGwgY2xlYXIgdGhlIHZhbHVlLiBBZGRpdGlvbmFsbHksIGRvbid0XG4gICAgICAgIC8vIG9wZXJhdGUgb24gaW5wdXRzIHRoYXQgaGF2ZSBmb2N1cywgb3RoZXJ3aXNlIENocm9tZSBtaWdodFxuICAgICAgICAvLyBzdHJpcCBvZmYgdHJhaWxpbmcgZGVjaW1hbCBwbGFjZXMgYW5kIGNhdXNlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gY3Vyc29yIHBvc2l0aW9uIHRvIGp1bXAgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIFJlYWN0RE9NSW5wdXQsIHdlIGhhdmUgYW4gb25CbHVyIGV2ZW50IHRoYXQgd2lsbCB0cmlnZ2VyXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWdhaW4gd2hlbiBmb2N1cyBpcyBsb3N0LlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsXG4gKiBuYW1lc3BhY2luZywgb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LlxuICpcbiAqIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAqIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gKiBuYW1lIHdhcm5pbmdzLlxuICpcbiAqIFNWRyBBdHRyaWJ1dGVzIExpc3Q6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbiAqIFNNSUwgU3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zbWlsXG4gKi9cbnZhciBBVFRSUyA9IFsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneC1oZWlnaHQnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sbnM6eGxpbmsnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ107XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGF1dG9SZXZlcnNlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBwcmVzZXJ2ZUFscGhhOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYSdcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9XG59O1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbkFUVFJTLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciByZWFjdE5hbWUgPSBvcmlnaW5hbC5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcblxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW3JlYWN0TmFtZV0gPSAwO1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1tyZWFjdE5hbWVdID0gb3JpZ2luYWw7XG59KTtcblxuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RXJyb3JVdGlsczogZnVuY3Rpb24gKGluamVjdGVkRXJyb3JVdGlscykge1xuICAgICAgISh0eXBlb2YgaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbmplY3RlZCBpbnZva2VHdWFyZGVkQ2FsbGJhY2soKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICB3YXJuaW5nKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG5cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xue1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuXG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIGluamVjdGlvbiQxID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXI7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVFdmVudHMoZXZlbnRzKSB7XG4gIGlmIChldmVudHMpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXZlbnRRdWV1ZShzaW11bGF0ZWQpIHtcbiAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gIGV2ZW50UXVldWUgPSBudWxsO1xuXG4gIGlmICghcHJvY2Vzc2luZ0V2ZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICB9XG4gICEhZXZlbnRRdWV1ZSA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMSxcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRleHRyYWN0RXZlbnRzOiBleHRyYWN0RXZlbnRzLFxuXHRlbnF1ZXVlRXZlbnRzOiBlbnF1ZXVlRXZlbnRzLFxuXHRwcm9jZXNzRXZlbnRRdWV1ZTogcHJvY2Vzc0V2ZW50UXVldWVcbn0pO1xuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDA7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMjtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBDYWxsQ29tcG9uZW50ID0gNztcbnZhciBDYWxsSGFuZGxlclBoYXNlID0gODtcbnZhciBSZXR1cm5Db21wb25lbnQgPSA5O1xudmFyIEZyYWdtZW50ID0gMTA7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3QgPSB2b2lkIDA7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyLCB0aGlzIHdpbGwgYWx3YXlzIGJlIHRoZSBkZWVwZXN0IHJvb3QuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xudmFyIEVWRU5UX1BPT0xfU0laRSA9IDEwO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG59O1xuXG4vKiogUHJveHlpbmcgYWZ0ZXIgZXZlcnl0aGluZyBzZXQgb24gU3ludGhldGljRXZlbnRcbiAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAqIGluIHdoaWNoIHNvbWUgRXZlbnQgcHJvcGVydGllcyBhcmUgc2V0IHRvIHVuZGVmaW5lZCAoR0gjMTAwMTApXG4gKi9cbntcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cblxuYWRkRXZlbnRQb29saW5nVG8oU3ludGhldGljRXZlbnQpO1xuXG4vKipcbiAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlICBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxudmFyIFN5bnRoZXRpY0V2ZW50JDEgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGVzfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDMgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQzLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRyZXN0b3JlU3RhdGVJZk5lZWRlZDogcmVzdG9yZVN0YXRlSWZOZWVkZWRcbn0pO1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBmaWJlckJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNOZXN0aW5nQmF0Y2hlZCkge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLiBUaGVyZWZvcmUsIHdlIGFkZCB0aGUgdGFyZ2V0IHRvXG4gICAgLy8gYSBxdWV1ZSBvZiB3b3JrLlxuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH1cbiAgaXNOZXN0aW5nQmF0Y2hlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgZmliZXJCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfVxufTtcblxudmFyIGluamVjdGlvbiQ0ID0gUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb247XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlczpcbnZhciBOb0VmZmVjdCA9IDA7IC8vICAgICAgICAgICAwYjAwMDAwMDAwXG52YXIgUGVyZm9ybWVkV29yayA9IDE7IC8vICAgICAgMGIwMDAwMDAwMVxuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAyOyAvLyAgICAgICAgICAwYjAwMDAwMDEwXG52YXIgVXBkYXRlID0gNDsgLy8gICAgICAgICAgICAgMGIwMDAwMDEwMFxudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IDY7IC8vIDBiMDAwMDAxMTBcbnZhciBEZWxldGlvbiA9IDg7IC8vICAgICAgICAgICAwYjAwMDAxMDAwXG52YXIgQ29udGVudFJlc2V0ID0gMTY7IC8vICAgICAgMGIwMDAxMDAwMFxudmFyIENhbGxiYWNrID0gMzI7IC8vICAgICAgICAgIDBiMDAxMDAwMDBcbnZhciBFcnIgPSA2NDsgLy8gICAgICAgICAgICAgICAwYjAxMDAwMDAwXG52YXIgUmVmID0gMTI4OyAvLyAgICAgICAgICAgICAgMGIxMDAwMDAwMFxuXG52YXIgTU9VTlRJTkcgPSAxO1xudmFyIE1PVU5URUQgPSAyO1xudmFyIFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYVsncmV0dXJuJ107XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFbJ3JldHVybiddICE9PSBiWydyZXR1cm4nXSkge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIF9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG52YXIgX2hhbmRsZVRvcExldmVsID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCkge1xuICBfaGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbn1cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmICFpc0ZpYmVyTW91bnRlZCh0YXJnZXRJbnN0KSkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBib29rS2VlcGluZyA9IGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KTtcblxuICB0cnkge1xuICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgIGJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUV2ZW50TGlzdGVuZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Z2V0IF9lbmFibGVkICgpIHsgcmV0dXJuIF9lbmFibGVkOyB9LFxuXHRnZXQgX2hhbmRsZVRvcExldmVsICgpIHsgcmV0dXJuIF9oYW5kbGVUb3BMZXZlbDsgfSxcblx0c2V0SGFuZGxlVG9wTGV2ZWw6IHNldEhhbmRsZVRvcExldmVsLFxuXHRzZXRFbmFibGVkOiBzZXRFbmFibGVkLFxuXHRpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcblx0dHJhcEJ1YmJsZWRFdmVudDogdHJhcEJ1YmJsZWRFdmVudCxcblx0dHJhcENhcHR1cmVkRXZlbnQ6IHRyYXBDYXB0dXJlZEV2ZW50LFxuXHRkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICpcbiAqIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZVxuICogdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkXG4gKiBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyQxID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5jZWw6ICdjYW5jZWwnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ2xvc2U6ICdjbG9zZScsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb2dnbGU6ICd0b2dnbGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG59XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSQkMSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlJCQxLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUkJDEgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuY2VsJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFsndG9wQWJvcnQnLCAndG9wQ2FuY2VsJywgJ3RvcENhblBsYXknLCAndG9wQ2FuUGxheVRocm91Z2gnLCAndG9wQ2xvc2UnLCAndG9wRHVyYXRpb25DaGFuZ2UnLCAndG9wRW1wdGllZCcsICd0b3BFbmNyeXB0ZWQnLCAndG9wRW5kZWQnLCAndG9wRXJyb3InLCAndG9wSW5wdXQnLCAndG9wSW52YWxpZCcsICd0b3BMb2FkJywgJ3RvcExvYWRlZERhdGEnLCAndG9wTG9hZGVkTWV0YWRhdGEnLCAndG9wTG9hZFN0YXJ0JywgJ3RvcFBhdXNlJywgJ3RvcFBsYXknLCAndG9wUGxheWluZycsICd0b3BQcm9ncmVzcycsICd0b3BSYXRlQ2hhbmdlJywgJ3RvcFJlc2V0JywgJ3RvcFNlZWtlZCcsICd0b3BTZWVraW5nJywgJ3RvcFN0YWxsZWQnLCAndG9wU3VibWl0JywgJ3RvcFN1c3BlbmQnLCAndG9wVGltZVVwZGF0ZScsICd0b3BUb2dnbGUnLCAndG9wVm9sdW1lQ2hhbmdlJywgJ3RvcFdhaXRpbmcnXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQyLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBlbmFibGVBc3luY1N1YnRyZWVBUEkgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00gPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxudmFyIGVuYWJsZUNyZWF0ZVJvb3QgPSBmYWxzZTtcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChDUyk6XG52YXIgZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgPSBmYWxzZTtcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cblxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0JDEoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmckJDEgPSAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBoYXNlVGltZXIoZmliZXIsIHBoYXNlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCgpO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgIGN1cnJlbnRQaGFzZSA9IHBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPyAnU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZScgOiBudWxsO1xuICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBjdXJyZW50RmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgIC8vIEFueSBvdGhlciBtZWFzdXJlbWVudHMgYXJlIHBlcmZvcm1lZCB3aXRoaW4uXG4gICAgYmVnaW5NYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5KSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyQkMSA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcihmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIHZhciBjaGlsZENvbnRleHQgPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lLFxuICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgIC8vIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIHN0YWNrIHdpbGwgYmUgbWlzc2luZ1xuICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENvbnRleHQoKSB7XG4gIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IGVtcHR5T2JqZWN0O1xuICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxudmFyIE5vV29yayA9IDA7IC8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gMjE0NzQ4MzY0NzsgLy8gTWF4IGludDMyOiBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gY2VpbGluZyhjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY1VwZGF0ZXMgPSAxO1xuXG57XG4gIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxue1xuICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG4vLyBDYWxsYmFja3MgYXJlIG5vdCB2YWxpZGF0ZWQgdW50aWwgaW52b2NhdGlvblxuXG5cbi8vIFNpbmdseSBsaW5rZWQtbGlzdCBvZiB1cGRhdGVzLiBXaGVuIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgcXVldWUgb2YgdGhlIGN1cnJlbnQgZmliZXIgYW5kIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGUgdHdvIHF1ZXVlc1xuLy8gYXJlIHNlcGFyYXRlIGJ1dCB0aGV5IHNoYXJlIGEgcGVyc2lzdGVudCBzdHJ1Y3R1cmUuXG4vL1xuLy8gRHVyaW5nIHJlY29uY2lsaWF0aW9uLCB1cGRhdGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIsXG4vLyBidXQgdGhleSByZW1haW4gb24gdGhlIGN1cnJlbnQgZmliZXIuIFRoYXQgZW5zdXJlcyB0aGF0IGlmIGEgd29yay1pbi1wcm9ncmVzc1xuLy8gaXMgYWJvcnRlZCwgdGhlIGFib3J0ZWQgdXBkYXRlcyBhcmUgcmVjb3ZlcmVkIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LlxuLy9cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBXaGVuIHRoZSB0cmVlIGlzIGNvbW1pdHRlZCwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgYmVjb21lcyB0aGUgY3VycmVudC5cblxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogYmFzZVN0YXRlLFxuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIHtcbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0ID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdCA9IHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdC5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbiAgaWYgKHF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcXVldWUuZXhwaXJhdGlvblRpbWUgPiB1cGRhdGUuZXhwaXJhdGlvblRpbWUpIHtcbiAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAgIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gICAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAgIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICB9XG5cbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZUZpYmVyICE9PSBudWxsKSB7XG4gICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuICBxdWV1ZTIgPSBxdWV1ZTIgIT09IHF1ZXVlMSA/IHF1ZXVlMiA6IG51bGw7XG5cbiAgLy8gV2FybiBpZiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXG4gIHtcbiAgICBpZiAoKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBxdWV1ZSwgYWRkIHRoZSB1cGRhdGUgdG8gdGhhdCBxdWV1ZSBhbmQgZXhpdC5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHF1ZXVlIGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGFkZCB0byBib3RoIHF1ZXVlcy5cbiAgaWYgKHF1ZXVlMS5sYXN0ID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0ID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGJvdGggbGlzdHMgYXJlIG5vdCBlbXB0eSwgdGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGZvciBib3RoIGxpc3RzXG4gIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgd2Ugc2hvdWxkIG9ubHkgYXBwZW5kIHRvIG9uZSBvZlxuICAvLyB0aGUgbGlzdHMuXG4gIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RgIHBvaW50ZXIgb2YgcXVldWUyLlxuICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gdXBkYXRlLnBhcnRpYWxTdGF0ZTtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdXBkYXRlRm4gPSBwYXJ0aWFsU3RhdGU7XG5cbiAgICAvLyBJbnZva2Ugc2V0U3RhdGUgY2FsbGJhY2sgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgICBmaXJzdDogY3VycmVudFF1ZXVlLmZpcnN0LFxuICAgICAgbGFzdDogY3VycmVudFF1ZXVlLmxhc3QsXG4gICAgICBpc0luaXRpYWxpemVkOiBjdXJyZW50UXVldWUuaXNJbml0aWFsaXplZCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS4gSWYgd2Ugc2tpcCBvdmVyIGFueSB1cGRhdGVzLCB3ZSdsbFxuICAvLyBpbmNyZWFzZSB0aGlzIGFjY29yZGluZ2x5LlxuICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAocXVldWUuaXNJbml0aWFsaXplZCkge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBxdWV1ZS5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgdmFyIGRpZFNraXAgPSBmYWxzZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBDb250aW51ZSB0byB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgdXBkYXRlcyB3ZXJlIHNraXBwZWQsIGRyb3AgdGhpcyB1cGRhdGUgZnJvbSB0aGUgcXVldWUgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZS5uZXh0O1xuICAgICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmxhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbnZhciBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSkge1xuICAvLyBDbGFzcyBjb21wb25lbnQgc3RhdGUgdXBkYXRlclxuICB2YXIgdXBkYXRlciA9IHtcbiAgICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIHdhcm5pbmcobm9HZXRJbml0aWFsU3RhdGVPbkVTNiwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgICB3YXJuaW5nKG5vR2V0RGVmYXVsdFByb3BzT25FUzYsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZVByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlQ29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFVubW91bnQsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZyh0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gICAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByb3BzKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZWVkc0NvbnRleHQgPSBpc0NvbnRleHRDb25zdW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGluc3RhbmNlLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgd29ya0luUHJvZ3Jlc3MudHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbnRlcm5hbENvbnRleHRUYWcgfD0gQXN5bmNVcGRhdGVzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgdXBkYXRlUXVldWUsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFRPRE86IFNob3VsZCB3ZSBkZWFsIHdpdGggYSBzZXRTdGF0ZSB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0XG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGFuZCBiZWZvcmUgdGhpcyBjb21wb25lbnRXaWxsTW91bnQ/IFByb2JhYmx5XG4gIC8vICAgLy8gdW5zdXBwb3J0ZWQgYW55d2F5LlxuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgIWNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyAgICAgLy8gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LlxuICAvLyAgICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBVcGRhdGUgdGhlIGlucHV0IHBvaW50ZXJzIG5vdyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3Qgd2hlbiB3ZSBjYWxsXG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50XG4gIC8vICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgLy8gICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBtYXkgaGF2ZSBjYWxsZWQgc2V0U3RhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgLy8gICAgIGNvbnN0IG5ld1VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgICBpZiAobmV3VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgICAgbmV3VXBkYXRlUXVldWUsXG4gIC8vICAgICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICAgKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAvLyAgIH1cblxuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gICAgICBuZXdQcm9wcyA9IG9sZFByb3BzO1xuICAgICAgIShuZXdQcm9wcyAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAgIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZTogYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgbW91bnRDbGFzc0luc3RhbmNlOiBtb3VudENsYXNzSW5zdGFuY2UsXG4gICAgLy8gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYWxzbyBjb21wYXJlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV1c2U/XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDJbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21DYWxsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkM1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDQudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ2ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDZbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDY7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYVxuICAgICAgICAgICAgLy8geWllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgICAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSByZXR1cm5zLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI0ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZU1hcCA9IG5ld0NoaWxkcmVuSXRlcmFibGU7XG4gICAgICAgIGlmIChwb3NzaWJsZU1hcC5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDcgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ3LnJlZiA9IGNvZXJjZVJlZihjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ3O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBjYWxsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB5aWVsZHMgc2luY2UgdGhleSdyZSBzdGF0ZWxlc3MuXG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJCZWdpbldvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSB7XG4gIHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9IGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIGVudGVySHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LmVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5yZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlckNsYXNzQ29tcG8gPSBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSksXG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgICAgbW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLm1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCAmJiAoIWN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZikpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIC8vIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpIHtcbiAgICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgLy8gUmVyZW5kZXJcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgICAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50O1xuICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgcm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAgICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgICAvLyBrbm93IHRoYXQgd2UncmUgY3VycmVudGx5IGluIGEgbW91bnRpbmcgc3RhdGUuIFRoYXQgd2F5IGlzTW91bnRlZFxuICAgICAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgICAvLyBub2RlcyB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgZWxlbWVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgICAvLyByb290LlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgc3RhdGUpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdXBkYXRlIHF1ZXVlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2UgdGhlIHJvb3QgaGFzIG5vIHByb3BzLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICAhKG5leHRQcm9wcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICAgIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJiAhdXNlU3luY1NjaGVkdWxpbmcgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgICAvLyBEb3duLXByaW9yaXRpemUgdGhlIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhbHVlID0gZm4ocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWUoKTtcbiAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcyVzJywgaW5mbywgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENhbGwgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENhbGwgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2FsbCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENhbGwgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENhbGwpIHtcbiAgICAgIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENhbGwuY2hpbGRyZW47XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgYnV0IHVzaW5nXG4gICAgLy8gc3RhdGVOb2RlIHRvIHN0b3JlIHRoZSBjaGlsZC5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FsbCk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHRha2UgYXJiaXRyYXJ5IHRpbWUgc28gd2UgY291bGQgc3luY2hyb25vdXNseSBqdXN0IGJlZ2luXG4gICAgLy8gZWFnZXJseSBkbyB0aGUgd29yayBvZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVhcmx5IGlmIHRoZSBjaGlsZHJlbiBoYXZlIG5vXG4gICAgLy8gbW9yZSB3b3JrIHRvIGRvLiBIb3dldmVyLCBzaW5jZSB3ZSBkb24ndCBoYXZlIGEgc2VwYXJhdGlvbiBvZiB0aGlzXG4gICAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gICAgLy8gb2YgdGhlIHNhbWUgd29yayB3ZSBkbyBhbnl3YXkuIE9uY2Ugd2UgaGF2ZSB0aGF0IHNlcGFyYXRpb24gd2UgY2FuIGp1c3RcbiAgICAvLyBiYWlsIG91dCBoZXJlIGlmIHRoZSBjaGlsZHJlbiBoYXMgbm8gbW9yZSB3b3JrIGF0IHRoaXMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gICAvLyBJZiB0aGVyZSBhcmUgc2lkZS1lZmZlY3RzIGluIHRoZXNlIGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAvLyAgIC8vIGNvbW1pdHRlZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkgZ2V0IHByb3Blcmx5IHRyYW5zZmVycmVkIHVwLlxuICAgIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAvLyAgICAgcmV1c2VDaGlsZHJlbkVmZmVjdHMod29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cblxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAgIC8vIFNlZSBQUiA4NTkwIGRpc2N1c3Npb24gZm9yIGNvbnRleHRcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcz9cbiAgICAvLyBIb3cgY2FuIHRoYXQgaGFwcGVuPyBIb3cgaXMgdGhpcyBub3QgYmVpbmcgY2xvbmVkP1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIG1lbW9pemVQcm9wcy9TdGF0ZSBhbmQgbW92ZSB0byByZWNvbmNpbGUvYmFpbG91dCBpbnN0ZWFkXG4gIGZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgdXBkYXRlUXVldWUsIGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gUmVzZXR0aW5nXG4gICAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBUaGlzIGlzIGEgcmVzdGFydC4gUmVzZXQgdGhlIHRhZyB0byB0aGUgaW5pdGlhbCBwaGFzZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHNpbmNlIHRoaXMgaXMgbm93IHRoZSBzYW1lLlxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIEEgcmV0dXJuIGNvbXBvbmVudCBpcyBqdXN0IGEgcGxhY2Vob2xkZXIsIHdlIGNhbiBqdXN0IHJ1biB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBuZXh0IG9uZSBpbW1lZGlhdGVseS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyO1xuXG4gICAgLy8gVGhpcyBpcyBhIHdlaXJkIGNhc2Ugd2hlcmUgd2UgZG8gXCJyZXN1bWVcIiB3b3JrIOKAlCB3b3JrIHRoYXQgZmFpbGVkIG9uXG4gICAgLy8gb3VyIGZpcnN0IGF0dGVtcHQuIEJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYSBub3Rpb24gb2YgXCJwcm9ncmVzc2VkXG4gICAgLy8gZGVsZXRpb25zLFwiIHJlc2V0IHRoZSBjaGlsZCB0byB0aGUgY3VycmVudCBjaGlsZCB0byBtYWtlIHN1cmUgd2UgZGVsZXRlXG4gICAgLy8gaXQgYWdhaW4uIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLCBwZXJoYXBzIGR1cmluZyBhIG1vcmVcbiAgICAvLyBnZW5lcmFsIG92ZXJoYXVsIG9mIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgYmFpbCBvdXQsIHdlJ3JlIGdvaW5nIGJlIHJlY29tcHV0aW5nIG91ciBjaGlsZHJlbiBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZHJvcCBvdXIgZWZmZWN0IGxpc3QuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgLy8gVW5tb3VudCB0aGUgY3VycmVudCBjaGlsZHJlbiBhcyBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG51bGxcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrLFxuICAgIGJlZ2luRmFpbGVkV29yazogYmVnaW5GYWlsZWRXb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnBvcEh5ZHJhdGlvblN0YXRlO1xuXG5cbiAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgICAvLyBhbiBVcGRhdGVBbmRQbGFjZW1lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUudHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhY2FsbCA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSByZXNvbHZlZCBieSBub3cuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBGaXJzdCBzdGVwIG9mIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY2FsbCByZXByZXNlbnRlZCBieSBhXG4gICAgLy8gc2luZ2xlIGNvbXBvbmVudCwgb3IgYXQgbGVhc3QgdGFpbCBjYWxsIG9wdGltaXplIG5lc3RlZCBvbmVzLiBDdXJyZW50bHlcbiAgICAvLyB0aGF0IHJlcXVpcmVzIGFkZGl0aW9uYWwgZmllbGRzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIGZpYmVyLlxuICAgIC8vIFNvIHRoaXMgcmVxdWlyZXMgbmVzdGVkIGhhbmRsZXJzLlxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBtdXRhdGUgdGhlIGFsdGVybmF0ZSBub2RlLiBJIGRvbid0IHRoaW5rIGl0IG5lZWRzIHRvXG4gICAgLy8gc2luY2UgdGhpcyBzdGFnZSBpcyByZXNldCBmb3IgZXZlcnkgcGFzcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsSGFuZGxlclBoYXNlO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHJldHVybnMuXG4gICAgLy8gVE9ETzogQ29tcGFyZSB0aGlzIHRvIGEgZ2VuZXJhdG9yIG9yIG9wYXF1ZSBoZWxwZXJzIGxpa2UgQ2hpbGRyZW4uXG4gICAgdmFyIHJldHVybnMgPSBbXTtcbiAgICBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZm4gPSBjYWxsLmhhbmRsZXI7XG4gICAgdmFyIHByb3BzID0gY2FsbC5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHJldHVybnMpO1xuXG4gICAgdmFyIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuY2hpbGQgOiBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RUZXh0ID0gdm9pZCAwO1xuICBpZiAobXV0YXRpb24pIHtcbiAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBNdXRhdGlvbiBtb2RlXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGRyZW5VbmNoYW5nZWQsIHJlY3ljbGFibGVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBHZXQgdGhlIGxhdGVzdCBwcm9wcy5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBwcm9wcywgdW5sZXNzIHRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgdG8gbm93IGJlIGEgZmlyc3QgcGhhc2UgY2FsbC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0ZVdvcms6IGNvbXBsZXRlV29ya1xuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwgPyBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlIDogbnVsbDtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmVmKGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4gIC8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4gIC8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG4gIGZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFVubW91bnQoY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciAmJiBtdXRhdGlvbikge1xuICAgICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgJiYgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gICAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gICAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gICAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAhbXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gICAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gICAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAgIGN1cnJlbnRbJ3JldHVybiddID0gbnVsbDtcbiAgICBjdXJyZW50LmNoaWxkID0gbnVsbDtcbiAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUpIHtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlWydyZXR1cm4nXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIHZhciBlbXB0eVBvcnRhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG4gICAgICB9O1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciB8fCBlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdFBsYWNlbWVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdERlbGV0aW9uOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudCk7XG4gICAgICAgICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFdvcms6IGZ1bmN0aW9uIChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG4gIHZhciBjb21taXRNb3VudCA9IG11dGF0aW9uLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IG11dGF0aW9uLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGFwcGVuZENoaWxkID0gbXV0YXRpb24uYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gbXV0YXRpb24uYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGluc2VydEJlZm9yZSA9IG11dGF0aW9uLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IG11dGF0aW9uLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xuXG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZVsncmV0dXJuJ10pKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG4gICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAhKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcbiAgICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgfVxuXG4gIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICB9XG59O1xuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgUmVhY3RGaWJlckhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcblxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgIShjICE9PSBOT19DT05URVhUKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0RpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJ0NhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgJyArICdjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkIHNldFN0YXRlLCByZXBsYWNlU3RhdGUsICcgKyAnb3IgZm9yY2VVcGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSAnICsgJ2NoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RGaWJlclNjaGVkdWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGhvc3RDb250ZXh0ID0gUmVhY3RGaWJlckhvc3RDb250ZXh0KGNvbmZpZyk7XG4gIHZhciBoeWRyYXRpb25Db250ZXh0ID0gUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQoY29uZmlnKTtcbiAgdmFyIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIHJlc2V0SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnJlc2V0SG9zdENvbnRhaW5lcjtcblxuICB2YXIgX1JlYWN0RmliZXJCZWdpbldvcmsgPSBSZWFjdEZpYmVyQmVnaW5Xb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciksXG4gICAgICBiZWdpbldvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbldvcmssXG4gICAgICBiZWdpbkZhaWxlZFdvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbkZhaWxlZFdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tcGxldGVXbyA9IFJlYWN0RmliZXJDb21wbGV0ZVdvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCksXG4gICAgICBjb21wbGV0ZVdvcmsgPSBfUmVhY3RGaWJlckNvbXBsZXRlV28uY29tcGxldGVXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIGNhcHR1cmVFcnJvciksXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERldGFjaFJlZjtcblxuICB2YXIgbm93ID0gY29uZmlnLm5vdyxcbiAgICAgIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSBjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSBjb25maWcucmVzZXRBZnRlckNvbW1pdDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbiAgLy8gaXMgTm9Xb3JrLCB1c2UgdGhlIGRlZmF1bHQgc3RyYXRlZ3k6IGFzeW5jIHVwZGF0ZXMgaW4gYXN5bmMgbW9kZSwgc3luY1xuICAvLyB1cGRhdGVzIGluIHN5bmMgbW9kZS4pXG4gIHZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxuICB2YXIgaXNXb3JraW5nID0gZmFsc2U7XG5cbiAgLy8gVGhlIG5leHQgd29yayBpbiBwcm9ncmVzcyBmaWJlciB0aGF0IHdlJ3JlIGN1cnJlbnRseSB3b3JraW5nIG9uLlxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICB2YXIgbmV4dFJvb3QgPSBudWxsO1xuICAvLyBUaGUgdGltZSBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHdvcmsuXG4gIHZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbiAgdmFyIG5leHRFZmZlY3QgPSBudWxsO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgY2FwdHVyZWQgYW4gZXJyb3IgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQuXG4gIC8vIFdvcmsgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbiBhZnRlciBjb21wb25lbnREaWRDYXRjaCBpcyBjYWxsZWQuXG4gIHZhciBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgZmFpbGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCBvZiB3b3JrLlxuICAvLyBUaGlzIGlzIGEgZGlmZmVyZW50IHNldCB0aGFuIGNhcHR1cmVkRXJyb3JzLCBiZWNhdXNlIGl0IGlzIG5vdCByZXNldCB1bnRpbFxuICAvLyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhpcyBpcyBuZWVkZWQgdG8gcHJvcGFnYXRlIGVycm9ycyBjb3JyZWN0bHkgaWYgYVxuICAvLyBzdWJ0cmVlIGZhaWxzIG1vcmUgdGhhbiBvbmNlLlxuICB2YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gIC8vIEVycm9yIGJvdW5kYXJpZXMgdGhhdCBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhlIGN1cnJlbnQgY29tbWl0LlxuICB2YXIgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgdmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIHZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdmFyIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuXG4gIC8vIFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLlxuICB2YXIgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVzZXRDb250ZXh0U3RhY2soKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrXG4gICAgcmVzZXQkMSgpO1xuICAgIC8vIFJlc2V0IHRoZSBjdXJzb3JzXG4gICAgcmVzZXRDb250ZXh0KCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgRXJyKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRFcnJvckhhbmRsaW5nKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgICAgLy8gYW5kIGxhc3RFZmZlY3Qgc2luY2UgdGhleSdyZSBvbiBldmVyeSBub2RlLCBub3QganVzdCB0aGUgZWZmZWN0ZnVsXG4gICAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBlZmZlY3RUYWcgaGVyZSBzbyB0aGF0IHdlIGNhbiByZWx5IG9uIGVmZmVjdFxuICAgICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGlzIHNvIHRoYXQgY2FwdHVyZUVycm9yIGNhbiBjb2xsZWN0IGFueSBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBjYXB0dXJlIGFuIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGUgcmVhc29uIHRoZXNlIGFyZW4ndFxuICAgIC8vIGxvY2FsIHRvIHRoaXMgZnVuY3Rpb24gaXMgYmVjYXVzZSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgY1dVIGFyZVxuICAgIC8vIGNhcHR1cmVkIGVsc2V3aGVyZSwgdG8gcHJldmVudCB0aGUgdW5tb3VudCBmcm9tIGJlaW5nIGludGVycnVwdGVkLlxuICAgIGlzV29ya2luZyA9IHRydWU7XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH1cblxuICAgIHByZXBhcmVGb3JDb21taXQoKTtcblxuICAgIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gICAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgICAvLyByZWYgdW5tb3VudHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbEhvc3RFZmZlY3RzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yKTtcbiAgICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KCk7XG5cbiAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgICAvLyB0aGUgZmluaXNoZWQgd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gICAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAgIC8vIExpZmUtY3ljbGVzIGhhcHBlbiBhcyBhIHNlcGFyYXRlIHBhc3Mgc28gdGhhdCBhbGwgcGxhY2VtZW50cywgdXBkYXRlcyxcbiAgICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAgIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxMaWZlQ3ljbGVzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGNhdWdodCBhbnkgZXJyb3JzIGR1cmluZyB0aGlzIGNvbW1pdCwgc2NoZWR1bGUgdGhlaXIgYm91bmRhcmllc1xuICAgIC8vIHRvIHVwZGF0ZS5cbiAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzKSB7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuZm9yRWFjaChzY2hlZHVsZUVycm9yUmVjb3ZlcnkpO1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2Vycm9yMyA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IoX2Vycm9yMyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1RpbWUgPSByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgICAvLyBwcm9ncmVzcy5cbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAgIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSB1bmhhbmRsZWQgZXJyb3JzLCBzd2l0Y2ggdG8gdGhlIHNsb3cgd29yayBsb29wLlxuICAgICAgLy8gVE9ETzogSG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaW4gdGhlIGZhc3QgcGF0aD8gTWF5YmUgdGhlIHJlbmRlcmVyXG4gICAgICAvLyBjb3VsZCBrZWVwIHRyYWNrIG9mIHdoaWNoIHJvb3RzIGhhdmUgdW5oYW5kbGVkIGVycm9ycyBhbmQgY2FsbCBhXG4gICAgICAvLyBmb3JrZWQgdmVyc2lvbiBvZiByZW5kZXJSb290LlxuICAgICAgc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290Q2F0Y2hCbG9jayhyb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzV29ya2luZyA9IHRydWU7XG5cbiAgICAvLyBXZSdyZSBhYm91dCB0byBtdXRhdGUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZS4gSWYgdGhlIHJvb3Qgd2FzIHBlbmRpbmdcbiAgICAvLyBjb21taXQsIGl0IG5vIGxvbmdlciBpczogd2UnbGwgbmVlZCB0byBjb21wbGV0ZSBpdCBhZ2Fpbi5cbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0YXJ0aW5nIGZyb20gYSBmcmVzaCBzdGFjaywgb3IgaWYgd2UncmUgcmVzdW1pbmcgZnJvbVxuICAgIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICAgIGlmIChyb290ICE9PSBuZXh0Um9vdCB8fCBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHJlc2V0Q29udGV4dFN0YWNrKCk7XG4gICAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCByZW5kZXJSb290Q2F0Y2hCbG9jaywgbnVsbCwgcm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkIHdvcmtpbmcuIEV4aXQgdGhlIGVycm9yIGxvb3AuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdW5jYXVnaHRFcnJvciA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIGRpZEZhdGFsID0gZmFsc2U7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblxuICAgIGlmICh1bmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IodW5jYXVnaHRFcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA/IHJvb3QuY3VycmVudC5hbHRlcm5hdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IsIG9yIG51bGwgaWYgdGhlIGVycm9yIGlzIGlnbm9yZWRcbiAgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKSB7XG4gICAgLy8gSXQgaXMgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2Ugd2UgZXhpdGVkIHRoZSB1c2VyIGNvZGUuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGJvdW5kYXJ5ID0gZmFpbGVkV29yaztcblxuICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkoZmFpbGVkV29yaykpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb290IGFscmVhZHkgZmFpbGVkLCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBhbiBlcnJvciB3aGVuXG4gICAgICAgIC8vIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBpdC4gVGhpcyBpcyBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8gYW5kXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZmFpbGVkV29ya1sncmV0dXJuJ107XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICAvLyBUcmVhdCB0aGUgcm9vdCBsaWtlIGEgbm8tb3AgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShub2RlKSkge1xuICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBpbiBhIGZhaWxlZCBzdGF0ZS5cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nLCB0aGF0IG1lYW5zIHRoaXMgZXJyb3Igd2FzXG4gICAgICAgICAgLy8gdGhyb3duIHdoaWxlIHVubW91bnRpbmcgYSBmYWlsZWQgc3VidHJlZS4gV2Ugc2hvdWxkIGlnbm9yZVxuICAgICAgICAgIC8vIHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSBzaG91bGQgY2hlY2sgdG8gc2VlIGlmXG4gICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgICAgICAvLyBUaGlzIGNhc2UgZXhpc3RzIGJlY2F1c2UgbXVsdGlwbGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gZHVyaW5nXG4gICAgICAgICAgLy8gYSBzaW5nbGUgY29tbWl0IHdpdGhvdXQgaW50ZXJydXB0aW9uLlxuICAgICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZSkgfHwgbm9kZS5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlLmFsdGVybmF0ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgd2Ugc2hvdWxkIGlnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkgLeKAlCB3ZSBrZWVwIGxvb2tpbmcuXG4gICAgICAgICAgYm91bmRhcnkgPSBudWxsO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZhaWxlZCBib3VuZGFyaWVzLiBUaGlzIGxldHMgdXMga25vdyB0aGF0XG4gICAgICAvLyBzdWJzZXF1ZW50IGVycm9ycyBpbiB0aGlzIHN1YnRyZWUgc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVuc2FmZSBvdXRzaWRlIG9mIHRoZSBiZWdpbiBhbmQgY29tcGxldGUgcGhhc2VzLlxuICAgICAgLy8gV2UgbWlnaHQgYmUgaW4gdGhlIGNvbW1pdCBwaGFzZSB3aGVuIGFuIGVycm9yIGlzIGNhcHR1cmVkLlxuICAgICAgLy8gVGhlIHJpc2sgaXMgdGhhdCB0aGUgcmV0dXJuIHBhdGggZnJvbSB0aGlzIEZpYmVyIG1heSBub3QgYmUgYWNjdXJhdGUuXG4gICAgICAvLyBUaGF0IHJpc2sgaXMgYWNjZXB0YWJsZSBnaXZlbiB0aGUgYmVuZWZpdCBvZiBwcm92aWRpbmcgdXNlcnMgbW9yZSBjb250ZXh0LlxuICAgICAgdmFyIF9jb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmFpbGVkV29yayk7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlICYmIGUuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgICAgICAgaWYgKCFzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGVmZmVjdGZ1bEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFja1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBib3VuZGFyeSB0byBoYW5kbGUgdGhlIGVycm9yLCB1c3VhbGx5IGJ5IHNjaGVkdWxpbmdcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIGl0c2VsZlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChjYXB0dXJlZEVycm9yLmVycm9yLCBpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kQ29udGV4dHMoZnJvbSwgdG8pIHtcbiAgICB2YXIgbm9kZSA9IGZyb207XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcihub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSAxMDAwO1xuICAgIHZhciBidWNrZXRTaXplTXMgPSAyMDA7XG4gICAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uTXMsIGJ1Y2tldFNpemVNcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgICAgLy8gYnkgZGVmYXVsdC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBzaG91bGQgZXhwaXJlIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAgICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgICAgLy8gcGVyZm9ybWluZyB3b3JrLiBDYWxjdWxhdGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHVzZVN5bmNTY2hlZHVsaW5nICYmICEoZmliZXIuaW50ZXJuYWxDb250ZXh0VGFnICYgQXN5bmNVcGRhdGVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKCFpc1dvcmtpbmcgJiYgcm9vdCA9PT0gbmV4dFJvb3QgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFJlc3RhcnQgdGhlIHJvb3QgZnJvbSB0aGUgdG9wLlxuICAgICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgICB9XG4gICAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgZWFjaCBub2RlJ3NcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShmaWJlcikge1xuICAgIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIFN5bmMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpIHtcbiAgICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gICAgdmFyIG1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKG1zKTtcbiAgICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICB2YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgdmFyIGRlYWRsaW5lID0gbnVsbDtcblxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uTXMgLSBjdXJyZW50TXM7XG5cbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG4gIH1cblxuICAvLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuICAvLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICBmdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcblxuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIDwgaGlnaGVzdFByaW9yaXR5V29yaykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgdmFyIHByZXZpb3VzRmx1c2hlZFJvb3QgPSBuZXh0Rmx1c2hlZFJvb3Q7XG4gICAgaWYgKHByZXZpb3VzRmx1c2hlZFJvb3QgIT09IG51bGwgJiYgcHJldmlvdXNGbHVzaGVkUm9vdCA9PT0gaGlnaGVzdFByaW9yaXR5Um9vdCkge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cbiAgICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgZGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gICAgZGVhZGxpbmUgPSBkbDtcblxuICAgIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlIHdlIHJlYWNoXG4gICAgLy8gdGhlIGRlYWRsaW5lLlxuICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDw9IG1pbkV4cGlyYXRpb25UaW1lKSAmJiAhZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGhpZ2hlc3QgcHJpb3JpdHkgd29yay5cbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yNCA9IHVuaGFuZGxlZEVycm9yO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRocm93IF9lcnJvcjQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICAvLyBUT0RPOiBQYXNzIGN1cnJlbnQgdGltZSBhcyBhcmd1bWVudCB0byByZW5kZXJSb290LCBjb21taXRSb290XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSkge1xuICAgICAgLy8gRmx1c2ggc3luYyB3b3JrLlxuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICAgIHZhciBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgX2ZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ2hlY2sgdGhlIGRlYWRsaW5lIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHRpbWUgbGVmdC4gQ29tbWl0IHRoZSByb290LlxuICAgICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogTm90IGhhcHB5IGFib3V0IHRoaXMgaG9vay4gQ29uY2VwdHVhbGx5LCByZW5kZXJSb290IHNob3VsZCByZXR1cm4gYVxuICAvLyB0dXBsZSBvZiAoaXNSZWFkeUZvckNvbW1pdCwgZGlkRXJyb3IsIGVycm9yKVxuICBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3Qgc28gd2UgZG9uJ3Qgd29yayBvbiBpdCBhZ2FpbiB1bnRpbCB0aGVyZSdzXG4gICAgLy8gYW5vdGhlciB1cGRhdGUuXG4gICAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4oKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjogY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICBzY2hlZHVsZVdvcms6IHNjaGVkdWxlV29yayxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlc1xuICB9O1xufTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuICByZXR1cm4gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpID8gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkgOiBwYXJlbnRDb250ZXh0O1xufVxuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlclNjaGVkdWxlciA9IFJlYWN0RmliZXJTY2hlZHVsZXIoY29uZmlnKSxcbiAgICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb24gPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICBiYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmJhdGNoZWRVcGRhdGVzLFxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBmbHVzaFN5bmMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5mbHVzaFN5bmMsXG4gICAgICBkZWZlcnJlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5kZWZlcnJlZFVwZGF0ZXM7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHtcbiAgICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgIHtcbiAgICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIC8vIENoZWNrIGlmIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBpcyBhbiBhc3luYyB3cmFwcGVyIGNvbXBvbmVudC4gSWYgc28sXG4gICAgLy8gdHJlYXQgdXBkYXRlcyB0byB0aGUgcm9vdCBhcyBhc3luYy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgbGV0cyB1c1xuICAgIC8vIGF2b2lkIGEgc2VwYXJhdGUgYHJlbmRlckFzeW5jYCBBUEkuXG4gICAgaWYgKGVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC50eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihjdXJyZW50LCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcblxuICAgICAge1xuICAgICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbk1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShmaWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoIWZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdEZpYmVyUmVjb25jaWxlciQxXG59KTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDMgPSAoIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgJiYgUmVhY3RGaWJlclJlY29uY2lsZXIkMSApIHx8IFJlYWN0RmliZXJSZWNvbmNpbGVyJDI7XG5cbi8vIFRPRE86IGJ1bmRsZSBGbG93IHR5cGVzIHdpdGggdGhlIHBhY2thZ2UuXG5cblxuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdFJlY29uY2lsZXIgPSBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gPyBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gOiBSZWFjdEZpYmVyUmVjb25jaWxlciQzO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxue1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBQb2x5ZmlsbCByZXF1ZXN0SWRsZUNhbGxiYWNrIGFuZCBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0O1xuICBpZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGlmIHdlIGhhdmUgYSBwZXJmb3JtYW5jZSB0aW1lciB0aGF0IHRoZSByQUYgY2FsbGJhY2tcbiAgICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIGlmIChmcmFtZURlYWRsaW5lIC0gY3VycmVudFRpbWUgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC4gQ2hlY2sgaWYgdGhlIGNhbGxiYWNrIGhhc1xuICAgICAgLy8gYSB0aW1lb3V0IGFuZCB3aGV0aGVyIGl0J3MgYmVlbiBleGNlZWRlZC5cbiAgICAgIGlmICh0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgLy8gRXhjZWVkZWQgdGhlIHRpbWVvdXQuIEludm9rZSB0aGUgY2FsbGJhY2sgZXZlbiB0aG91Z2ggdGhlcmUncyBub1xuICAgICAgICAvLyB0aW1lIGxlZnQuXG4gICAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB0aW1lb3V0LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIGFuaW1hdGlvbiBjYWxsYmFjayBzbyB3ZSByZXRyeSBsYXRlci5cbiAgICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCB3aXRob3V0IGludm9raW5nIHRoZSBjYWxsYmFjay5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLlxuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY2hlZHVsZWRSSUNDYWxsYmFjaztcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIHJJQyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIG9ubHkgc2NoZWR1bGUgb25lIGNhbGxiYWNrIGF0IGEgdGltZSBiZWNhdXNlIHRoYXQnc1xuICAgIC8vIGhvdyBGaWJlciB1c2VzIGl0LlxuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZW91dFRpbWUgPSBub3coKSArIG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIGNJQyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgfTtcbn0gZWxzZSB7XG4gIHJJQyA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICBjSUMgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vLyBpc0F0dHJpYnV0ZU5hbWVTYWZlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc2hvdWxkSWdub3JlVmFsdWUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kIHx8IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAmJiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpID8gdmFsdWUgOiBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgc3RlcDogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZFxuICB9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKSB8fCAwO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbiAgICAgIC8vXG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAvLyBwcm92aWRlZC5cblxuICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICBjYXNlICdzdWJtaXQnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdkYXRldGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICd0aW1lJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbnNbX2kyXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWVcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUpO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSQxID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UkMSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbiAgLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGVcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG5cbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKTtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgJ2RlZmF1bHQnOiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgJ2luJzogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgJ3R5cGVvZic6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQyKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gaXNSZXNlcnZlZFByb3AobmFtZSk7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJXMnLCBuYW1lLCBsb3dlckNhc2VkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiAhc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIXNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIGdldFN0YWNrID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygnJyk7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDI7XG5cbiAgdmFyIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqL3RydWUpO1xuICB9O1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICB2YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgaXNEb2N1bWVudE9yRnJhZ21lbnQgPSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRPckZyYWdtZW50ID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50O1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgIHdhcm5pbmcoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpLCAnPCVzIC8+IGlzIHVzaW5nIHVwcGVyY2FzZSBIVE1MLiBBbHdheXMgdXNlIGxvd2VyY2FzZSBIVE1MIHRhZ3MgJyArICdpbiBSZWFjdC4nLCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvO1xuICAgICAgaWYgKHN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nLiBXZSdyZSBpZ25vcmluZyBhbGwgdGhlc2Ugd2FybmluZ3MuXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIHx8XG4gICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciByYXdIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSB8fCAnJyA6ICcnO1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkSFRNTCAhPT0gc2VydmVySFRNTCkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRTZXRBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSkpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGVcbn0pO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGEgbmFtZWQgZXhwb3J0XG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyQxO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG57XG4gIHZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbmluamVjdGlvbiQzLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQoUmVhY3RET01GaWJlckNvbXBvbmVudCk7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBET01SZW5kZXJlciA9IHJlYWN0UmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAge1xuICAgICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICB9XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgfSxcblxuXG4gIG5vdzogbm93LFxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAgIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xuICAgICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0sXG4gICAgcmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoeWRyYXRpb246IHtcbiAgICBjYW5IeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZzogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgICAgIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAgICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIH0sXG4gICAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBySUMsXG4gIGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6IGNJQyxcblxuICB1c2VTeW5jU2NoZWR1bGluZzogIWVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET01cbn0pO1xuXG5pbmplY3Rpb24kNC5pbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzKERPTVJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICB3YXJuaW5nKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gICAgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICB2YXIgcm9vdFNpYmxpbmcgPSB2b2lkIDA7XG4gICAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdSb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgc2hvdWxkSHlkcmF0ZSk7XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbmV3Um9vdDtcbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgbmV3Um9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGh5ZHJhdGUpO1xuICB0aGlzLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICB3YXJuaW5nKHdhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IGdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICByZXR1cm4gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZShpbnN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgd2FybmluZyghcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0LCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5pZiAoZW5hYmxlQ3JlYXRlUm9vdCkge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge3dpdGhSb3V0ZXJ9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG5pbXBvcnQge2Nvbm5lY3R9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBTaG93IGZyb20gJy4vU2hvdy5qcyc7XG5pbXBvcnQgSG9tZSBmcm9tICcuL0hvbWUuanMnO1xuaW1wb3J0IHtcbiAgUm91dGUsXG4gIE5hdkxpbmssXG4gIEJyb3dzZXJSb3V0ZXJcbn0gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcbmNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbnN0eWxlcygpIHtcbnJldHVybiB7XG5uYXZsaW5rOiB7XG5cdGNvbG9yOiAnd2hpdGUnXG59XG59O1xufVxuXG5cbmNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICBcbiAgICB0aGlzLmdvSG9tZSA9IHRoaXMuZ29Ib21lLmJpbmQodGhpcylcbiAgICBcbiAgXG4gIH1cblxuICBnb0hvbWUoKSB7XG4gICAgdGhpcy5jb250ZXh0LnJvdXRlci5wdXNoKCcvU2hvdycpXG4gIH1cbiAgXG4gIHJlbmRlcigpIHtcbiAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuc3R5bGVzKCk7XG4gICAgcmV0dXJuIChcblxuICAgICAgIDxCcm93c2VyUm91dGVyPlxuICAgICAgICA8ZGl2PlxuICBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCA8ZGl2PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgIDxzcGFuIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+PE5hdkxpbmsgc3R5bGU9e3N0eWxlcy5uYXZsaW5rfSB0bz1cIi9cIj5Ib21lPC9OYXZMaW5rPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICA8c3BhbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiPjxOYXZMaW5rIHN0eWxlPXtzdHlsZXMubmF2bGlua30gdG89XCIvU2hvd1wiPlNob3c8L05hdkxpbms+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxSb3V0ZSBleGFjdD17dHJ1ZX0gcGF0aD1cIi9cIiBjb21wb25lbnQ9e0hvbWV9Lz5cbiAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL1Nob3dcIiBjb21wb25lbnQ9e1Nob3d9Lz5cbiAgICAgICAgICAgIFxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvQnJvd3NlclJvdXRlcj5cbiAgICApO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBBcHA7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbGllbnQvY29tcG9uZW50cy9BcHAuanMiLCJpbXBvcnQgX0Jyb3dzZXJSb3V0ZXIgZnJvbSAnLi9Ccm93c2VyUm91dGVyJztcbmV4cG9ydCB7IF9Ccm93c2VyUm91dGVyIGFzIEJyb3dzZXJSb3V0ZXIgfTtcbmltcG9ydCBfSGFzaFJvdXRlciBmcm9tICcuL0hhc2hSb3V0ZXInO1xuZXhwb3J0IHsgX0hhc2hSb3V0ZXIgYXMgSGFzaFJvdXRlciB9O1xuaW1wb3J0IF9MaW5rIGZyb20gJy4vTGluayc7XG5leHBvcnQgeyBfTGluayBhcyBMaW5rIH07XG5pbXBvcnQgX01lbW9yeVJvdXRlciBmcm9tICcuL01lbW9yeVJvdXRlcic7XG5leHBvcnQgeyBfTWVtb3J5Um91dGVyIGFzIE1lbW9yeVJvdXRlciB9O1xuaW1wb3J0IF9OYXZMaW5rIGZyb20gJy4vTmF2TGluayc7XG5leHBvcnQgeyBfTmF2TGluayBhcyBOYXZMaW5rIH07XG5pbXBvcnQgX1Byb21wdCBmcm9tICcuL1Byb21wdCc7XG5leHBvcnQgeyBfUHJvbXB0IGFzIFByb21wdCB9O1xuaW1wb3J0IF9SZWRpcmVjdCBmcm9tICcuL1JlZGlyZWN0JztcbmV4cG9ydCB7IF9SZWRpcmVjdCBhcyBSZWRpcmVjdCB9O1xuaW1wb3J0IF9Sb3V0ZSBmcm9tICcuL1JvdXRlJztcbmV4cG9ydCB7IF9Sb3V0ZSBhcyBSb3V0ZSB9O1xuaW1wb3J0IF9Sb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuZXhwb3J0IHsgX1JvdXRlciBhcyBSb3V0ZXIgfTtcbmltcG9ydCBfU3RhdGljUm91dGVyIGZyb20gJy4vU3RhdGljUm91dGVyJztcbmV4cG9ydCB7IF9TdGF0aWNSb3V0ZXIgYXMgU3RhdGljUm91dGVyIH07XG5pbXBvcnQgX1N3aXRjaCBmcm9tICcuL1N3aXRjaCc7XG5leHBvcnQgeyBfU3dpdGNoIGFzIFN3aXRjaCB9O1xuaW1wb3J0IF9tYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuZXhwb3J0IHsgX21hdGNoUGF0aCBhcyBtYXRjaFBhdGggfTtcbmltcG9ydCBfd2l0aFJvdXRlciBmcm9tICcuL3dpdGhSb3V0ZXInO1xuZXhwb3J0IHsgX3dpdGhSb3V0ZXIgYXMgd2l0aFJvdXRlciB9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJvd3NlclJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX0RPTVV0aWxzLmNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkpKCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UpKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gX0RPTVV0aWxzLmdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/ICgwLCBfUGF0aFV0aWxzLnN0cmlwVHJhaWxpbmdTbGFzaCkoKDAsIF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoKShwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCFiYXNlbmFtZSB8fCAoMCwgX1BhdGhVdGlscy5oYXNCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoKDAsIF9ET01VdGlscy5pc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KShldmVudCkpIHJldHVybjtcblxuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyB3aW5kb3cubG9jYXRpb24uaGFzaC5cbiAqL1xuXG52YXIgSGFzaFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhIYXNoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYXNoUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8SGFzaFJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkhhc2hSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoWydoYXNoYmFuZycsICdub3NsYXNoJywgJ3NsYXNoJ10pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgSGFzaFJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyAoMCwgX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCkocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHN0b3JlcyBsb2NhdGlvbiBpbiBtZW1vcnkuXG4gKi9cblxudmFyIE1lbW9yeVJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNZW1vcnlSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbW9yeVJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxNZW1vcnlSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgTWVtb3J5Um91dGVyIGFzIFJvdXRlciB9YC4nKTtcbiAgfTtcblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gTWVtb3J5Um91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5NZW1vcnlSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBpbml0aWFsRW50cmllczogUHJvcFR5cGVzLmFycmF5LFxuICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBfUGF0aFV0aWxzLmNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5pbXBvcnQgTGluayBmcm9tICcuL0xpbmsnO1xuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG52YXIgTmF2TGluayA9IGZ1bmN0aW9uIE5hdkxpbmsoX3JlZikge1xuICB2YXIgdG8gPSBfcmVmLnRvLFxuICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgZ2V0SXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxuICAgICAgYXJpYUN1cnJlbnQgPSBfcmVmLmFyaWFDdXJyZW50LFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvJywgJ2V4YWN0JywgJ3N0cmljdCcsICdsb2NhdGlvbicsICdhY3RpdmVDbGFzc05hbWUnLCAnY2xhc3NOYW1lJywgJ2FjdGl2ZVN0eWxlJywgJ3N0eWxlJywgJ2lzQWN0aXZlJywgJ2FyaWFDdXJyZW50J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgcGF0aDogKHR5cGVvZiB0byA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodG8pKSA9PT0gJ29iamVjdCcgPyB0by5wYXRobmFtZSA6IHRvLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKF9yZWYyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfcmVmMi5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaCA9IF9yZWYyLm1hdGNoO1xuXG4gICAgICB2YXIgaXNBY3RpdmUgPSAhIShnZXRJc0FjdGl2ZSA/IGdldElzQWN0aXZlKG1hdGNoLCBsb2NhdGlvbikgOiBtYXRjaCk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHtcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBjbGFzc05hbWU6IGlzQWN0aXZlID8gW2NsYXNzTmFtZSwgYWN0aXZlQ2xhc3NOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkuam9pbignICcpIDogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogaXNBY3RpdmUgPyBfZXh0ZW5kcyh7fSwgc3R5bGUsIGFjdGl2ZVN0eWxlKSA6IHN0eWxlLFxuICAgICAgICAnYXJpYS1jdXJyZW50JzogaXNBY3RpdmUgJiYgYXJpYUN1cnJlbnRcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICBhcmlhQ3VycmVudDogUHJvcFR5cGVzLm9uZU9mKFsncGFnZScsICdzdGVwJywgJ2xvY2F0aW9uJywgJ3RydWUnXSlcbn07XG5cbk5hdkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICBhY3RpdmVDbGFzc05hbWU6ICdhY3RpdmUnLFxuICBhcmlhQ3VycmVudDogJ3RydWUnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOYXZMaW5rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanMiLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBQcm9tcHQgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1Byb21wdCc7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheVxuICogZnJvbSBhIHNjcmVlbiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBQcm9tcHQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvbXB0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQcm9tcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21wdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFByb21wdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB0aGlzLnVuYmxvY2soKTtcblxuICAgIHRoaXMudW5ibG9jayA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5ibG9jayhtZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHtcbiAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgdGhpcy51bmJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy53aGVuKSB0aGlzLmVuYWJsZSh0aGlzLnByb3BzLm1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy53aGVuKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMud2hlbiB8fCB0aGlzLnByb3BzLm1lc3NhZ2UgIT09IG5leHRQcm9wcy5tZXNzYWdlKSB0aGlzLmVuYWJsZShuZXh0UHJvcHMubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFByb21wdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgd2hlbjogUHJvcFR5cGVzLmJvb2wsXG4gIG1lc3NhZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZFxufTtcblByb21wdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHdoZW46IHRydWVcbn07XG5Qcm9tcHQuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGJsb2NrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUmVkaXJlY3QgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICdoaXN0b3J5JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgdXBkYXRpbmcgdGhlIGxvY2F0aW9uIHByb2dyYW1tYXRpY2FsbHlcbiAqIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlZGlyZWN0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWRpcmVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBSZWRpcmVjdC5wcm90b3R5cGUuaXNTdGF0aWMgPSBmdW5jdGlvbiBpc1N0YXRpYygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJvdXRlciAmJiB0aGlzLmNvbnRleHQucm91dGVyLnN0YXRpY0NvbnRleHQ7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuXG4gICAgaWYgKHRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHByZXZUbyA9IGNyZWF0ZUxvY2F0aW9uKHByZXZQcm9wcy50byk7XG4gICAgdmFyIG5leHRUbyA9IGNyZWF0ZUxvY2F0aW9uKHRoaXMucHJvcHMudG8pO1xuXG4gICAgaWYgKGxvY2F0aW9uc0FyZUVxdWFsKHByZXZUbywgbmV4dFRvKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1lvdSB0cmllZCB0byByZWRpcmVjdCB0byB0aGUgc2FtZSByb3V0ZSB5b3VcXCdyZSBjdXJyZW50bHkgb246ICcgKyAoJ1wiJyArIG5leHRUby5wYXRobmFtZSArIG5leHRUby5zZWFyY2ggKyAnXCInKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiBwZXJmb3JtKCkge1xuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBwdXNoID0gX3Byb3BzLnB1c2gsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvO1xuXG5cbiAgICBpZiAocHVzaCkge1xuICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICB9XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVkaXJlY3Q7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5L1BhdGhVdGlscyc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxudmFyIG5vcm1hbGl6ZUxvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24ob2JqZWN0KSB7XG4gIHZhciBfb2JqZWN0JHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lLFxuICAgICAgcGF0aG5hbWUgPSBfb2JqZWN0JHBhdGhuYW1lID09PSB1bmRlZmluZWQgPyAnLycgOiBfb2JqZWN0JHBhdGhuYW1lLFxuICAgICAgX29iamVjdCRzZWFyY2ggPSBvYmplY3Quc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX29iamVjdCRzZWFyY2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRzZWFyY2gsXG4gICAgICBfb2JqZWN0JGhhc2ggPSBvYmplY3QuaGFzaCxcbiAgICAgIGhhc2ggPSBfb2JqZWN0JGhhc2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRoYXNoO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlID0gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKTtcblxuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKGxvY2F0aW9uKSA6IG5vcm1hbGl6ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbn07XG5cbnZhciBjcmVhdGVVUkwgPSBmdW5jdGlvbiBjcmVhdGVVUkwobG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj4nLCBtZXRob2ROYW1lKTtcbiAgfTtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxudmFyIFN0YXRpY1JvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY1JvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKF90aGlzLnByb3BzLmJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdQVVNIJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMi5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8U3RhdGljUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGJhc2VuYW1lID0gX3Byb3BzLmJhc2VuYW1lLFxuICAgICAgICBjb250ZXh0ID0gX3Byb3BzLmNvbnRleHQsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnYmFzZW5hbWUnLCAnY29udGV4dCcsICdsb2NhdGlvbiddKTtcblxuICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgY3JlYXRlSHJlZjogdGhpcy5jcmVhdGVIcmVmLFxuICAgICAgYWN0aW9uOiAnUE9QJyxcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoJ2dvJyksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoJ2dvQmFjaycpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKCdnb0ZvcndhcmQnKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6ICcnLFxuICBsb2NhdGlvbjogJy8nXG59O1xuU3RhdGljUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCAnWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPicpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgZXhhY3QgPSBfZWxlbWVudCRwcm9wcy5leGFjdCxcbiAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgc2Vuc2l0aXZlID0gX2VsZW1lbnQkcHJvcHMuc2Vuc2l0aXZlLFxuICAgICAgICAgIGZyb20gPSBfZWxlbWVudCRwcm9wcy5mcm9tO1xuXG4gICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIGV4YWN0OiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pIDogcm91dGUubWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAncmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aCc7XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IHdpdGhSb3V0ZXIgZnJvbSAncmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgWyd3cmFwcGVkQ29tcG9uZW50UmVmJ10pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHsgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywgeyByZWY6IHdyYXBwZWRDb21wb25lbnRSZWYgfSkpO1xuICAgICAgfSB9KTtcbiAgfTtcblxuICBDLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgJyknO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gdHJ1ZTtcblxuICB3YXJuaW5nKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXg7XG5cbiAgdmFyIHN0b3JlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnc3RvcmUnO1xuICB2YXIgc3ViS2V5ID0gYXJndW1lbnRzWzFdO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdWJLZXkgfHwgc3RvcmVLZXkgKyAnU3Vic2NyaXB0aW9uJztcblxuICB2YXIgUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbc3RvcmVLZXldID0gdGhpc1tzdG9yZUtleV0sIF9yZWZbc3Vic2NyaXB0aW9uS2V5XSA9IG51bGwsIF9yZWY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvdmlkZXIpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgX3RoaXNbc3RvcmVLZXldID0gcHJvcHMuc3RvcmU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXNbc3RvcmVLZXldICE9PSBuZXh0UHJvcHMuc3RvcmUpIHtcbiAgICAgICAgd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbiAgfTtcbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdG9yZUtleV0gPSBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uU2hhcGUsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG5cbiAgcmV0dXJuIFByb3ZpZGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQcm92aWRlcigpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0UHVyZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RQdXJlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgdmFyIGRpZFdhcm5Qcm9wVHlwZXNEZXByZWNhdGVkID0gZmFsc2U7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgX19zcHJlYWQgPSBfYXNzaWduO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxuLy8gVE9ETzogRml4IHRlc3RzIHNvIHRoYXQgdGhpcyBkZXByZWNhdGlvbiB3YXJuaW5nIGRvZXNuJ3QgY2F1c2UgZmFpbHVyZXMuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3QsICdQcm9wVHlwZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQsICdBY2Nlc3NpbmcgUHJvcFR5cGVzIHZpYSB0aGUgbWFpbiBSZWFjdCBwYWNrYWdlIGlzIGRlcHJlY2F0ZWQuIFVzZSAnICsgJ3RoZSBwcm9wLXR5cGVzIHBhY2thZ2UgZnJvbSBucG0gaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICAvLyBDYXN0aW5nIGFzIGFueSBzbyB0aGF0IGZsb3cgaWdub3JlcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGFuZCB0cnVzdHNcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxuICpcbiAqL1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9ICdtaXhpbnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGFub255bW91cyBmdW5jdGlvbnMgd2hpY2ggZG8gbm90XG4vLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXG5mdW5jdGlvbiBpZGVudGl0eShmbikge1xuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xuXG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiAnT1ZFUlJJREVfQkFTRSdcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsICdwcm9wJyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzYnKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc3Jywgc3BlY1BvbGljeSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBfcHJvZEludmFyaWFudCgnODAnKSA6IHZvaWQgMDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbnZhciBkaWRXYXJuRGVwcmVjYXRlZCA9IGZhbHNlO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5EZXByZWNhdGVkLCAnJXM6IFJlYWN0LmNyZWF0ZUNsYXNzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDE2LiAnICsgJ1VzZSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzZXMgaW5zdGVhZC4gSWYgeW91XFwncmUgbm90IHlldCByZWFkeSB0byAnICsgJ21pZ3JhdGUsIGNyZWF0ZS1yZWFjdC1jbGFzcyBpcyBhdmFpbGFibGUgb24gbnBtIGFzIGEgJyArICdkcm9wLWluIHJlcGxhY2VtZW50LicsIHNwZWMgJiYgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5EZXByZWNhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBfcHJvZEludmFyaWFudCgnODMnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2xhc3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKSxcbiAgICBpc1ZhbGlkRWxlbWVudCA9IF9yZXF1aXJlLmlzVmFsaWRFbGVtZW50O1xuXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvZmFjdG9yeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoaXNWYWxpZEVsZW1lbnQpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJlYWN0IDE1LjUgcmVmZXJlbmNlcyB0aGlzIG1vZHVsZSwgYW5kIGFzc3VtZXMgUHJvcFR5cGVzIGFyZSBzdGlsbCBjYWxsYWJsZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhlcmVmb3JlIHdlIHJlLWV4cG9ydCBkZXZlbG9wbWVudC1vbmx5IHZlcnNpb24gd2l0aCBhbGwgdGhlIFByb3BUeXBlcyBjaGVja3MgaGVyZS5cbi8vIEhvd2V2ZXIgaWYgb25lIGlzIG1pZ3JhdGluZyB0byB0aGUgYHByb3AtdHlwZXNgIG5wbSBsaWJyYXJ5LCB0aGV5IHdpbGwgZ28gdGhyb3VnaCB0aGVcbi8vIGBpbmRleC5qc2AgZW50cnkgcG9pbnQsIGFuZCBpdCB3aWxsIGJyYW5jaCBkZXBlbmRpbmcgb24gdGhlIGVudmlyb25tZW50LlxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50KSB7XG4gIC8vIEl0IGlzIHN0aWxsIGFsbG93ZWQgaW4gMTUuNS5cbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSBmYWxzZTtcbiAgcmV0dXJuIGZhY3RvcnkoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjUuMyc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcblxuICAgICAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7IC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gZW5jYXBzdWxhdGVzIHRoZSBzdWJzY3JpcHRpb24gbG9naWMgZm9yIGNvbm5lY3RpbmcgYSBjb21wb25lbnQgdG8gdGhlIHJlZHV4IHN0b3JlLCBhc1xuLy8gd2VsbCBhcyBuZXN0aW5nIHN1YnNjcmlwdGlvbnMgb2YgZGVzY2VuZGFudCBjb21wb25lbnRzLCBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgdGhlXG4vLyBhbmNlc3RvciBjb21wb25lbnRzIHJlLXJlbmRlciBiZWZvcmUgZGVzY2VuZGFudHNcblxudmFyIENMRUFSRUQgPSBudWxsO1xudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge31cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpIHtcbiAgLy8gdGhlIGN1cnJlbnQvbmV4dCBwYXR0ZXJuIGlzIGNvcGllZCBmcm9tIHJlZHV4J3MgY3JlYXRlU3RvcmUgY29kZS5cbiAgLy8gVE9ETzogcmVmYWN0b3IrZXhwb3NlIHRoYXQgY29kZSB0byBiZSByZXVzYWJsZSBoZXJlP1xuICB2YXIgY3VycmVudCA9IFtdO1xuICB2YXIgbmV4dCA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgbmV4dCA9IENMRUFSRUQ7XG4gICAgICBjdXJyZW50ID0gQ0xFQVJFRDtcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnQgPSBuZXh0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICBuZXh0LnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGN1cnJlbnQgPT09IENMRUFSRUQpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICAgIG5leHQuc3BsaWNlKG5leHQuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViLCBvblN0YXRlQ2hhbmdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbik7XG5cbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIH1cblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZE5lc3RlZFN1YiA9IGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnVuc3Vic2NyaWJlKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnBhcmVudFN1YiA/IHRoaXMucGFyZW50U3ViLmFkZE5lc3RlZFN1Yih0aGlzLm9uU3RhdGVDaGFuZ2UpIDogdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlKTtcblxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb247XG59KCk7XG5cbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiBhcyBkZWZhdWx0IH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuLi91dGlscy9zaGFsbG93RXF1YWwnO1xuaW1wb3J0IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBEaXNwYXRjaFRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBTdGF0ZVRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIGZyb20gJy4vbWVyZ2VQcm9wcyc7XG5pbXBvcnQgZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSBmcm9tICcuL3NlbGVjdG9yRmFjdG9yeSc7XG5cbi8qXG4gIGNvbm5lY3QgaXMgYSBmYWNhZGUgb3ZlciBjb25uZWN0QWR2YW5jZWQuIEl0IHR1cm5zIGl0cyBhcmdzIGludG8gYSBjb21wYXRpYmxlXG4gIHNlbGVjdG9yRmFjdG9yeSwgd2hpY2ggaGFzIHRoZSBzaWduYXR1cmU6XG5cbiAgICAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgPT4gbmV4dEZpbmFsUHJvcHNcbiAgXG4gIGNvbm5lY3QgcGFzc2VzIGl0cyBhcmdzIHRvIGNvbm5lY3RBZHZhbmNlZCBhcyBvcHRpb25zLCB3aGljaCB3aWxsIGluIHR1cm4gcGFzcyB0aGVtIHRvXG4gIHNlbGVjdG9yRmFjdG9yeSBlYWNoIHRpbWUgYSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSBpcyBpbnN0YW50aWF0ZWQgb3IgaG90IHJlbG9hZGVkLlxuXG4gIHNlbGVjdG9yRmFjdG9yeSByZXR1cm5zIGEgZmluYWwgcHJvcHMgc2VsZWN0b3IgZnJvbSBpdHMgbWFwU3RhdGVUb1Byb3BzLFxuICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCBtZXJnZVByb3BzLFxuICBtZXJnZVByb3BzRmFjdG9yaWVzLCBhbmQgcHVyZSBhcmdzLlxuXG4gIFRoZSByZXN1bHRpbmcgZmluYWwgcHJvcHMgc2VsZWN0b3IgaXMgY2FsbGVkIGJ5IHRoZSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSB3aGVuZXZlclxuICBpdCByZWNlaXZlcyBuZXcgcHJvcHMgb3Igc3RvcmUgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goYXJnLCBmYWN0b3JpZXMsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IGZhY3Rvcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByZXN1bHQgPSBmYWN0b3JpZXNbaV0oYXJnKTtcbiAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBvZiB0eXBlICcgKyB0eXBlb2YgYXJnICsgJyBmb3IgJyArIG5hbWUgKyAnIGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJyArIG9wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWUgKyAnLicpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG4vLyBjcmVhdGVDb25uZWN0IHdpdGggZGVmYXVsdCBhcmdzIGJ1aWxkcyB0aGUgJ29mZmljaWFsJyBjb25uZWN0IGJlaGF2aW9yLiBDYWxsaW5nIGl0IHdpdGhcbi8vIGRpZmZlcmVudCBvcHRpb25zIG9wZW5zIHVwIHNvbWUgdGVzdGluZyBhbmQgZXh0ZW5zaWJpbGl0eSBzY2VuYXJpb3NcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0KCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmJGNvbm5lY3RIT0MgPSBfcmVmLmNvbm5lY3RIT0MsXG4gICAgICBjb25uZWN0SE9DID0gX3JlZiRjb25uZWN0SE9DID09PSB1bmRlZmluZWQgPyBjb25uZWN0QWR2YW5jZWQgOiBfcmVmJGNvbm5lY3RIT0MsXG4gICAgICBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPSBfcmVmLm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwU3RhdGVUb1Byb3BzRixcbiAgICAgIF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9IF9yZWYubWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBEaXNwYXRjaFRvUHJvID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBEaXNwYXRjaFRvUHJvLFxuICAgICAgX3JlZiRtZXJnZVByb3BzRmFjdG9yID0gX3JlZi5tZXJnZVByb3BzRmFjdG9yaWVzLFxuICAgICAgbWVyZ2VQcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1lcmdlUHJvcHNGYWN0b3IsXG4gICAgICBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYuc2VsZWN0b3JGYWN0b3J5LFxuICAgICAgc2VsZWN0b3JGYWN0b3J5ID0gX3JlZiRzZWxlY3RvckZhY3RvcnkgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgOiBfcmVmJHNlbGVjdG9yRmFjdG9yeTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge30sXG4gICAgICAgIF9yZWYyJHB1cmUgPSBfcmVmMi5wdXJlLFxuICAgICAgICBwdXJlID0gX3JlZjIkcHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJHB1cmUsXG4gICAgICAgIF9yZWYyJGFyZVN0YXRlc0VxdWFsID0gX3JlZjIuYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlc0VxdWFsID0gX3JlZjIkYXJlU3RhdGVzRXF1YWwgPT09IHVuZGVmaW5lZCA/IHN0cmljdEVxdWFsIDogX3JlZjIkYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIF9yZWYyJGFyZU93blByb3BzRXF1YSA9IF9yZWYyLmFyZU93blByb3BzRXF1YWwsXG4gICAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmMiRhcmVPd25Qcm9wc0VxdWEgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZU93blByb3BzRXF1YSxcbiAgICAgICAgX3JlZjIkYXJlU3RhdGVQcm9wc0VxID0gX3JlZjIuYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmMiRhcmVTdGF0ZVByb3BzRXEgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZVN0YXRlUHJvcHNFcSxcbiAgICAgICAgX3JlZjIkYXJlTWVyZ2VkUHJvcHNFID0gX3JlZjIuYXJlTWVyZ2VkUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9PT0gdW5kZWZpbmVkID8gc2hhbGxvd0VxdWFsIDogX3JlZjIkYXJlTWVyZ2VkUHJvcHNFLFxuICAgICAgICBleHRyYU9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsncHVyZScsICdhcmVTdGF0ZXNFcXVhbCcsICdhcmVPd25Qcm9wc0VxdWFsJywgJ2FyZVN0YXRlUHJvcHNFcXVhbCcsICdhcmVNZXJnZWRQcm9wc0VxdWFsJ10pO1xuXG4gICAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXRjaChtYXBTdGF0ZVRvUHJvcHMsIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWF0Y2gobWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1lcmdlUHJvcHMgPSBtYXRjaChtZXJnZVByb3BzLCBtZXJnZVByb3BzRmFjdG9yaWVzLCAnbWVyZ2VQcm9wcycpO1xuXG4gICAgcmV0dXJuIGNvbm5lY3RIT0Moc2VsZWN0b3JGYWN0b3J5LCBfZXh0ZW5kcyh7XG4gICAgICAvLyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzXG4gICAgICBtZXRob2ROYW1lOiAnY29ubmVjdCcsXG5cbiAgICAgIC8vIHVzZWQgdG8gY29tcHV0ZSBDb25uZWN0J3MgZGlzcGxheU5hbWUgZnJvbSB0aGUgd3JhcHBlZCBjb21wb25lbnQncyBkaXNwbGF5TmFtZS5cbiAgICAgIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAnQ29ubmVjdCgnICsgbmFtZSArICcpJztcbiAgICAgIH0sXG5cbiAgICAgIC8vIGlmIG1hcFN0YXRlVG9Qcm9wcyBpcyBmYWxzeSwgdGhlIENvbm5lY3QgY29tcG9uZW50IGRvZXNuJ3Qgc3Vic2NyaWJlIHRvIHN0b3JlIHN0YXRlIGNoYW5nZXNcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpLFxuXG4gICAgICAvLyBwYXNzZWQgdGhyb3VnaCB0byBzZWxlY3RvckZhY3RvcnlcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHM6IGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOiBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHM6IGluaXRNZXJnZVByb3BzLFxuICAgICAgcHVyZTogcHVyZSxcbiAgICAgIGFyZVN0YXRlc0VxdWFsOiBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWw6IGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWw6IGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWw6IGFyZU1lcmdlZFByb3BzRXF1YWxcblxuICAgIH0sIGV4dHJhT3B0aW9ucykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb25uZWN0KCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanMiLCJpbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ29iamVjdCcgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaCk7XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcsIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdF07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qcyIsImltcG9ydCBjcmVhdGVTdG9yZSBmcm9tICcuL2NyZWF0ZVN0b3JlJztcbmltcG9ydCBjb21iaW5lUmVkdWNlcnMgZnJvbSAnLi9jb21iaW5lUmVkdWNlcnMnO1xuaW1wb3J0IGJpbmRBY3Rpb25DcmVhdG9ycyBmcm9tICcuL2JpbmRBY3Rpb25DcmVhdG9ycyc7XG5pbXBvcnQgYXBwbHlNaWRkbGV3YXJlIGZyb20gJy4vYXBwbHlNaWRkbGV3YXJlJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICB3YXJuaW5nKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUsIGNvbWJpbmVSZWR1Y2VycywgYmluZEFjdGlvbkNyZWF0b3JzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2luZGV4LmpzIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIEFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKCdObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC9ob21lL2FmcmF6L25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jb21iaW5lUmVkdWNlcnMuanMiLCJmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gY29tcG9zZS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qcyIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICAgIHB1cmUgPSBfcmVmLnB1cmUsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmLmFyZU1lcmdlZFByb3BzRXF1YWw7XG5cbiAgICB2YXIgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNGdW5jdGlvbihtZXJnZVByb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NZXJnZVByb3BzSXNGdW5jdGlvbiwgd2hlbk1lcmdlUHJvcHNJc09taXR0ZWRdO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzIiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMobWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyksIG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpLCBvd25Qcm9wcyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIF9yZWYpIHtcbiAgdmFyIGFyZVN0YXRlc0VxdWFsID0gX3JlZi5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmLmFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmLmFyZVN0YXRlUHJvcHNFcXVhbDtcblxuICB2YXIgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICB2YXIgb3duUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBzdGF0ZVByb3BzID0gdm9pZCAwO1xuICB2YXIgZGlzcGF0Y2hQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIG1lcmdlZFByb3BzID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG5cbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcblxuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZCkgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHZhciBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKG5leHRTdGF0ZSwgc3RhdGUpO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuXG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcblxuLy8gSWYgcHVyZSBpcyB0cnVlLCB0aGUgc2VsZWN0b3IgcmV0dXJuZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHdpbGwgbWVtb2l6ZSBpdHMgcmVzdWx0cyxcbi8vIGFsbG93aW5nIGNvbm5lY3RBZHZhbmNlZCdzIHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byByZXR1cm4gZmFsc2UgaWYgZmluYWxcbi8vIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuIElmIGZhbHNlLCB0aGUgc2VsZWN0b3Igd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3XG4vLyBvYmplY3QgYW5kIHNob3VsZENvbXBvbmVudFVwZGF0ZSB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwgX3JlZjIpIHtcbiAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBfcmVmMi5pbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IF9yZWYyLmluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyA9IF9yZWYyLmluaXRNZXJnZVByb3BzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydpbml0TWFwU3RhdGVUb1Byb3BzJywgJ2luaXRNYXBEaXNwYXRjaFRvUHJvcHMnLCAnaW5pdE1lcmdlUHJvcHMnXSk7XG5cbiAgdmFyIG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBvcHRpb25zLmRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZhY3RvcnkgPSBvcHRpb25zLnB1cmUgPyBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA6IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIHNlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvaG9tZS9hZnJhei9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanMiLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIGZvciAnICsgbWV0aG9kTmFtZSArICcgaW4gJyArIGRpc3BsYXlOYW1lICsgJy4nKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghc2VsZWN0b3IuaGFzT3duUHJvcGVydHkoJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoJ1RoZSBzZWxlY3RvciBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIG9mICcgKyBkaXNwbGF5TmFtZSArICcgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycsIGRpc3BsYXlOYW1lKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL2hvbWUvYWZyYXovbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cblxuY2xhc3MgU2hvdyBleHRlbmRzIENvbXBvbmVudCB7XG4gXG4gICByZW5kZXIoKSB7XG5sZXQgeyBVc2VyTmFtZSB9ID0gdGhpcy5wcm9wcy5wYXJhbXM7XG4gICAgIHJldHVybiAoXG5cdFx0XHRcbiAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aDE+e1VzbmFtZX0gPC9oMT5cbiAgICAgICAgIDwvZGl2PlxuXHRcdFxuICAgICAgKTtcbiAgIH1cbn1cblxuXG5cbmV4cG9ydCBkZWZhdWx0IFNob3c7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvU2hvdy5qcyIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBBUEkgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS91c2Vycyc7XG5jbGFzcyBIb21lIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuXHRVc2VyTmFtZTogXCJcIixcblx0bmFtZTpcIlwiLFxuXHRyZXBvczpcIlwiLFxuXHRmb2xsb3dlcnM6XCJcIixcblx0Zm9sbG93aW5nOlwiXCIsXG5cdCBcbiAgICAgIH1cbiAgICBcblx0XG59ICBcbiBmZXRjaFByb2ZpbGUodXNlcm5hbWUpXG4geyBcbiBhbGVydChcIkhpXCIpO1xuICAgXG4gICAgbGV0IHVybCA9IGAke0FQSX0vJHt1c2VybmFtZX1gO1xuICAgIGZldGNoKHVybClcbiAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkgKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgVXNlck5hbWU6IGRhdGEubG9naW4sXG4gICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgIFxuICAgICAgICAgIHJlcG9zOiBkYXRhLnB1YmxpY19yZXBvcyxcbiAgICAgICAgICBmb2xsb3dlcnM6IGRhdGEuZm9sbG93ZXJzLFxuICAgICAgICAgIGZvbGxvd2luZzogZGF0YS5mb2xsb3dpbmcsXG4gICAgICAgICAgbm90Rm91bmQ6IGRhdGEubWVzc2FnZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGNvbnNvbGUubG9nKCdPb3BzISAuIFRoZXJlIElzIEEgUHJvYmxlbScpIClcbiAgfVxuSGkoKVxue1xuICAgICAgICB0aGlzLmZldGNoUHJvZmlsZSh0aGlzLnN0YXRlLlVzZXJOYW1lKTtcbiAgICB9XG5cblxuICAgcmVuZGVyKCkge1xuICAgICByZXR1cm4gKFxuXHRcdFx0XG4gICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGZvcm1cblx0XHRvblN1Ym1pdD17ZSA9PiB7ICBhbGVydChcIlZhbHVlcyBBZGRlZFwiKTsgdGhpcy5IaSgpOyAgfSB9PlxuICAgIFxuXHRcdFxuXHRcdDxkaXYgY2xhc3M9XCJmb3JtLXJvd1wiPlxuXG5cdFx0PGRpdiBjbGFzcz1cImNvbC0xMiAgY29sLW1kLTUgbWItMiBtYi1tZC0wXCI+XG5cdFx0PGlucHV0XG5cdFx0cmVxdWlyZWQ9XCJyZXF1aXJlZFwiXG5cdFx0bmFtZT1cImZpcnN0bmFtZVwiXG5cdFx0Y2xhc3M9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLWxnIFwiIFxuXHRcdHBsYWNlaG9sZGVyID0nVXNlck5hbWUnXG5cdFx0cmVxdWlyZWQgcGF0dGVybj1cIlthLXpBLVpdK1wiXG5cdFx0dmFsdWU9e3RoaXMuc3RhdGUuVXNlck5hbWV9IFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlPT50aGlzLnNldFN0YXRlKHtVc2VyTmFtZTplLnRhcmdldC52YWx1ZX0pfVxuICAgICAgICAgICAgICAgICAvPlxuXHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdFxuICAgIDwvZm9ybT5cblx0PGgxPkhpIGthc2hpZjwvaDE+XG5cdFx0XG4gICAgICAgICA8L2Rpdj5cblx0XHRcbiAgICAgICk7XG4gICB9XG59XG5cblxuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NsaWVudC9jb21wb25lbnRzL0hvbWUuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHBsaWNhdGlvbi5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2FwcGxpY2F0aW9uLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYXBwbGljYXRpb24uc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY2xpZW50L3Njc3MvYXBwbGljYXRpb24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICBiYWNrZ3JvdW5kOiAjQUNDRUVDO1xcbiAgY29sb3I6ICMwMDVDQzU7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zcmMvY2xpZW50L3Njc3MvYXBwbGljYXRpb24uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmIChzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==